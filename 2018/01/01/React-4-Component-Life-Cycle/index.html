<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Blog posted about front end development">
    <meta name="keyword" content="undefined">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        [React] 4. Component Life Cycle - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> FrontEnd Engineer, Jbee&#39;s blog </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        <div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/images/profile.jpeg" />
        </div>
        <div class="name">
            <i>
                Jbee</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>
                        HOME</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>
                        ARCHIVES</span>
                </a>
            </li>
            <li >
                <a href="https://jbee-resume.now.sh" target="_blank">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>
                        ABOUT</span>
                </a>
            </li>
            
        </ul>
    </div>
    
    <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#React-Lifecycle-Methods-how-and-when-to-use-them"><span class="toc-text">React Lifecycle Methods - how and when to use them</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Table-of-contents"><span class="toc-text">Table of contents</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Intro"><span class="toc-text">Intro</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Component-Life-Cycle"><span class="toc-text">React Component Life Cycle</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mounting"><span class="toc-text">Mounting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Updating"><span class="toc-text">Updating</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Props-Change"><span class="toc-text">Props Change</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#State-Change"><span class="toc-text">State Change</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unmounting"><span class="toc-text">Unmounting</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#componentWillMount"><span class="toc-text">componentWillMount</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#이-메소드의-가장-일반적인-사용-사례"><span class="toc-text">이 메소드의 가장 일반적인 사용 사례</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#componentDidMount"><span class="toc-text">componentDidMount</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#이-메소드의-가장-일반적인-사용-사례-1"><span class="toc-text">이 메소드의 가장 일반적인 사용 사례</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#componentWillReceiveProps"><span class="toc-text">componentWillReceiveProps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#이-메소드의-가장-일반적인-사용-사례-2"><span class="toc-text">이 메소드의 가장 일반적인 사용 사례</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shouldComponentUpdate"><span class="toc-text">shouldComponentUpdate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#이-메소드의-가장-일반적인-사용-사례-3"><span class="toc-text">이 메소드의 가장 일반적인 사용 사례</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#componentWillUpdate"><span class="toc-text">componentWillUpdate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#이-메소드의-가장-일반적인-사용-사례-4"><span class="toc-text">이 메소드의 가장 일반적인 사용 사례</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#componentDidUpdate"><span class="toc-text">componentDidUpdate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#이-메소드의-가장-일반적인-사용-사례-5"><span class="toc-text">이 메소드의 가장 일반적인 사용 사례</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#componentWillUnmount"><span class="toc-text">componentWillUnmount</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#이-메소드의-가장-일반적인-사용-사례-6"><span class="toc-text">이 메소드의 가장 일반적인 사용 사례</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conclusion"><span class="toc-text">Conclusion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#마무리"><span class="toc-text">마무리</span></a></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input" />
            <span id="begin-search">
                search</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> FrontEnd Engineer, Jbee&#39;s blog </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        [React] 4. Component Life Cycle
    </div>

    <div class="post-meta">
        <span class="attr">Post：<span>2018-01-01 17:08:03</span></span>
        
        <span class="attr">Tags：/
        
        <a class="tag" href="/tags/#React" title="React">React</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">Visit：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <p><img src="/images/react_logo.png" alt=""></p>
<h1 id="React-Lifecycle-Methods-how-and-when-to-use-them"><a href="#React-Lifecycle-Methods-how-and-when-to-use-them" class="headerlink" title="React Lifecycle Methods - how and when to use them"></a>React Lifecycle Methods - how and when to use them</h1><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="external">https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1</a></em></p>
<h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul>
<li>Intro</li>
<li>React Component Life Cycle<ul>
<li>componentWillMount</li>
<li>componentDidMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
</li>
</ul>
<p><br></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><img src="/images/react_component_life_cycle.png" alt=""></p>
<p>위 다이어그램은 React 컴포넌트의 출생(pre-mounting)과 사망 (unmounting)에서의 Life Cycle입니다. React의 장점은 복잡한 UI를 작은 크기로 나누는 것입니다. 따라서 앱을 각각의 컴포넌트 단위로 분류 할 수 있을 뿐만 아니라 각 컴포넌트에 대해 customize 할 수 있습니다.</p>
<p>React Component의 라이프 사이클 메소드를 통해 UI의 각 컴포넌트가 <strong>렌더링(rendering)</strong>, <strong>업데이트(update)</strong>, <strong>재렌더링(re-rendering)</strong> 될 때를 고려할 수 있으며 <strong>완전히 사라질 때(unmount)</strong> 일어나는 일을 제어 할 수 있습니다.</p>
<p><br></p>
<h2 id="React-Component-Life-Cycle"><a href="#React-Component-Life-Cycle" class="headerlink" title="React Component Life Cycle"></a>React Component Life Cycle</h2><p>React 컴포넌트의 생명 주기를 부분적으로 나누어 간단히 살펴보면 다음과 같습니다.</p>
<h3 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h3><p>React 컴포넌트의 인스턴스가 생성되고 DOM에 삽입되는 과정의 life cycle 입니다.</p>
<ol>
<li>constructor</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ol>
<h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p><code>prop</code> 또는 <code>state</code>의 변경으로 해당 컴포넌트가 re-render 되는 경우의 life cycle 입니다.</p>
<h4 id="Props-Change"><a href="#Props-Change" class="headerlink" title="Props Change"></a>Props Change</h4><ol>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h4 id="State-Change"><a href="#State-Change" class="headerlink" title="State Change"></a>State Change</h4><ol>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h3 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h3><ul>
<li>componentWillUnmount</li>
</ul>
<p>이제 각각에 대해서 살펴봅시다.</p>
<p><br></p>
<h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a><code>componentWillMount</code></h2><p>개발자가 정의한 컴포넌트는 눈 깜짝할 사이에 화면에 그려집니다. 이 순간 무엇을 할 수 있을까요? 그에 대한 대답은 사실 할 수 있는 것이 별로 없습니다. <code>componentWillMount</code> 메소드는 딱히 쓸모가 없습니다.</p>
<p><code>componentWillMount</code>에서는 아직 생성된 컴포넌트가 없으므로 DOM 관련 작업을 수행 할 수 없습니다. 또한 컴포넌트의 기본 구성(<code>props</code> or <code>state</code>)을 설정하는 생성자(constructor)가 호출된 이후에는 아무 것도 변경되지 않았습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sidebar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  tooltipsEnabled = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">analyticsOpen</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">requirementsOpen</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">brandInfoOpen</span>: <span class="literal">false</span>,</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>생성자가 호출되고 나면 그 상태가 바로 컴포넌트의 초기 상태가 됩니다. 추가적인 라이프 사이클 메소드를 복잡하게 사용하지 않고도 거의 모든 것이 컴포넌트 코드의 나머지 부분에서 처리되어야 합니다. 그 중에서도 예외가 있다면 초기에만 수행할 수있는 설정 즉, 외부 API에 연결하는 작업이 있을 것입니다. 예를 들어, 앱에 Firebase를 사용한다면, 앱이 처음 설치 될 때 설정을 가져와야합니다. 그러나 여기서 핵심은 이러한 작업은 앱의 최상위 컴포넌트 (루트 컴포넌트)에서 수행되어야 한다는 것입니다.</p>
<p>이는 컴포넌트의 99 %가 <code>componentWillMount</code>를 사용하지 않아야 함을 의미합니다. <code>componentWillMount</code>를 사용하여 컴포넌트에 대한 데이터를 로드하기 위해 AJAX 호출을 시작하는 사람들을 볼 수 있습니다. 하지만 이 글을 읽는 당신은 이러지 않았으면 좋겠습니다. 바로 다음 section인 두번째 section에서 이 부분에 대해 이야기하겠습니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례"><a href="#이-메소드의-가장-일반적인-사용-사례" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>루트 컴포넌트에서 App과 관련된 외부 API를 설정할 떄.</li>
<li>setState 호출(?) : <code>setState</code>도 호출하지 말고 constructor에서 설정한 <code>this.state</code>를 사용하세요.</li>
</ul>
<p><br></p>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a><code>componentDidMount</code></h2><p>이제 컴포넌트가 mount되고 사용할 준비가 되었습니다.</p>
<p><code>componentDidMount</code>는 가지고 놀 컴포넌트가 없을 때 할 수 없었던 것들을 모두 할 수 있는 메소드입니다. 몇 가지 예를 들면 다음과 같습니다.</p>
<ul>
<li><code>&lt;canvas&gt;</code> 에 렌더링을 수행한다.</li>
<li>요소 컬렉션에서 <a href="https://masonry.desandro.com/" target="_blank" rel="external">Masonry</a> 그리드 레이아웃을 초기화한다.</li>
<li>Event listener를 추가한다.</li>
</ul>
<p>기본적으로 여기에서는 DOM에 대한 접근이 필요한 모든 설정을 수행하고 필요한 데이터를 가져오기 시작합니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-1"><a href="#이-메소드의-가장-일반적인-사용-사례-1" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>Ajax 호출을 시작하여 컴포넌트에서 사용해야 하는 데이터를 로드합니다.</li>
<li>setState를 호출할 수 있습니다.</li>
</ul>
<p><br></p>
<h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><code>componentWillReceiveProps</code></h2><p>컴포넌트가 정상적으로 잘 동작하고 있었는데 새로운 <code>props</code>가 전달되었습니다. 아마 상위 컴포넌트에서 <code>componentDidMount</code>에 의해 로드된 데이터 중 일부가 내려왔을 것입니다.</p>
<p>새로운 <code>props</code>로 어떠한 작업을 수행하기 전 이 새로운 <code>props</code>를 인자로 하여 <code>componentWillReceiveProps</code>가 호출됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps(nextProps) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">parseInt</span>(nextProps.id, <span class="number">10</span>) !== <span class="built_in">parseInt</span>(<span class="keyword">this</span>.props.id, <span class="number">10</span>)) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">postsLoaded</span>: <span class="literal">false</span> &#125;);</div><div class="line">    <span class="keyword">this</span>.contentLoaded = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>우리는 이 메소드 안에서 <code>nextProps</code>를 통해 다음의 <code>props</code>(새로운 <code>props</code>)에 접근할 수 있고 <code>this.props</code>를 통해 현재의 <code>props</code>에 접근할 수 있습니다.</p>
<p>이 메소드에서 우리 해야하는 것은 다음과 같습니다.</p>
<ol>
<li>props가 바뀌었는지 확인합니다. 가끔 <code>props</code>가 변경되지 않은 경우에도 호출됩니다.</li>
<li>만약 <code>props</code>가 변경되었다면 그에 따라 로직을 구성해야 한다.</li>
</ol>
<p>새로운 <code>props</code>를 받았을 때, 다음과 같이 처리합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps(nextProps) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.percent !== nextProps.percent) &#123;</div><div class="line">    <span class="keyword">this</span>.setUpPercent(nextProps.percent);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>하나 더 주의해야 할 것은 <code>componentWillReceiveProps</code>는 초기 렌더링시 호출되지 않습니다. 코드 상으로는 컴포넌트가 <code>props</code>를 받는다는 것을 의미하지만 비교할 기존의 <code>props</code>가 없으므로 로직에 포함되지 않습니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-2"><a href="#이-메소드의-가장-일반적인-사용-사례-2" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>해당 컴포넌트의 상태 변경에 영향을 끼지는 <code>props</code>의 변경에 따라 로직을 구성합니다.</li>
<li>setState를 호출할 수 있습니다.</li>
</ul>
<p><br></p>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a><code>shouldComponentUpdate</code></h2><p>컴포넌트가 불안정한(?) 상태입니다. 이 메소드가 호출되었다는 것은 현재 컴포넌트의 상태와 view에 그려진 내용, 상태가 다르다는 것을 의미하기 때문입니다.</p>
<p>우리에게는 새로운 <code>props</code>가 있습니다. 전형적인 React 신조에 따르면 컴포넌트가 새로운 <code>props</code>나 새로운 <code>state</code>를 받으면 업데이트해야 한다고 말합니다.</p>
<p><code>shouldComponentUpdate</code> 메소드는 <code>nextProps</code>를 첫 번째 인수로 사용하고 <code>nextState</code>는 두 번째 인수로 사용합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.engagement !== nextProps.engagement</div><div class="line">    || nextState.input !== <span class="keyword">this</span>.state.input;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>shouldComponentUpdate</code>는 항상 <code>boolean</code>을 반환해야 합니다. 이것은 “해당 컴포넌트를 다시 렌더링(re-render)해야 하나요?”라는 질문에 대한 답이 됩니다. 해당 컴포넌트를 특별히 override하지 않는 이상 이 메소드는 기본적으로 <code>true</code>를 반환합니다.</p>
<p>하지만 불필요한 재렌더링(re-render)를 방지하기 위해서는 <code>shouldComponentUpdate</code>를 override 할 수 있습니다. 자세한 내용은 다음 <a href="https://engineering.musefind.com/how-to-benchmark-react-components-the-quick-and-dirty-guide-f595baf1014c" target="_blank" rel="external">링크</a>를 참고해주세요. (이 링크에서는 많은 필드가 있는 테이블에서 테이블이 다시 렌더링 될 때 각 필드가 다시 렌더링되어 작업속도가 느려지게 된다는 것을 보여주고 있습니다.)</p>
<p><code>shouldComponentupdate</code>를 사용하면 변화에 신경써야 하는 <code>props</code>의 변경에 대해서만 update를 진행할 수 있습니다. 하지만 이에 대한 설정을 잊으면 React 컴포넌트가 제대로 동작하지 않기 때문에 명심해야 합니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-3"><a href="#이-메소드의-가장-일반적인-사용-사례-3" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>해당 컴포넌트의 re-render를 제어할 때 사용합니다.</li>
<li>setState를 호출할 수 없습니다.</li>
</ul>
<p><br></p>
<h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a><code>componentWillUpdate</code></h2><p>방금 전까지 컴포넌트를 update하는데 집중을 했는데요, 이 메소드에서는 update가 발생하기 전 어떠한 작업이 필요한 경우 해당 메소드 안에서 해결할 수 있습니다.<br>이 메소드는 메소드 내에서 <code>this.setState</code>를 호출할 수 없다는 점을 제외하면 기본적으로 <code>componentWillReceiveProps</code>와 동일합니다.</p>
<p>이미 <code>shouldComponentUpdate</code>를 사용 중인데 또 <code>props</code>가 변경될 때 작업이 필요한 경우 이 메소드가 적절하겠지만 추가적인 유용성은 많이 주지는 못할 것입니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-4"><a href="#이-메소드의-가장-일반적인-사용-사례-4" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li><code>shouldComponentUpdate</code>가 이미 사용되고 있는 컴포넌트에서 <code>componentWillReceiveProps</code> 대신 사용됩니다. 단 해당 메소드 내에서는 이전 <code>props</code>에 접근할 수 없습니다.</li>
<li>setState를 호출할 수 없습니다.</li>
</ul>
<p><br></p>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a><code>componentDidUpdate</code></h2><p>이 메소드에서는 <code>componentDidMount</code>에서 했던 것과 동일한 작업을 수행할 수 있습니다. (예를 들면, 레이아웃을 다시 설정한다던가 canvas를 그린다던가) </p>
<p><code>shouldComponentUpdate</code>가 호출된 다음, <code>render</code>가 호출된 다음 호출되는 메소드입니다. 하지만 아쉽게도 이 메소드 내에서는 어떠한 이유로 update가 이루어졌는지 알 수 없습니다. 그렇기 때문에 변경된 데이터에 대해 DOM조작을 다시 해줘야하는 경우가 있다면 이 메소드에서 수행해줄 수 있습니다.</p>
<p><code>componentWillReceiveProps</code>에서도 충분히 해줄 수 있는 작업들이지만 불필요한 re-render를 방지하기 위해 DOM과 관련된 작업들을 주로 수행합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">componentDidUpdate() &#123;</div><div class="line">  <span class="keyword">this</span>.createGrid();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="이-메소드의-가장-일반적인-사용-사례-5"><a href="#이-메소드의-가장-일반적인-사용-사례-5" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li><code>prop</code> 또는 <code>state</code>에 따라서 DOM을 업데이트 합니다.</li>
<li>setState를 호출할 수 있습니다.</li>
</ul>
<p><br></p>
<h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a><code>componentWillUnmount</code></h2><p>컴포넌트가 unmount 되기 전 호출되는 메소드로 마지막으로 수행해야하는 작업이 있다면 이 메소드에서 수행해줄 수 있습니다. 여기서는 네트워크 요청을 취소하거나 컴포넌트와 관련된 모든 이벤트 리스터를 제거할 수 있습니다. 기본적으로 해당 컴포넌트와 관련있는 작업들만 수행합니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-6"><a href="#이-메소드의-가장-일반적인-사용-사례-6" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>컴포넌트와 관련된 것들을 제거하는 메소드입니다.</li>
<li>setState를 호출할 수 없습니다.</li>
</ul>
<p><br></p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>이상적인 애플리케이션에서는 life cycle 에 접근할 필요가 없습니다. 렌더링과 관련된 거의 모든 이슈는 <code>state</code>와 <code>props</code>만을 통해 제어될 수 있습니다. 하지만 몇몇의 경우, 컴포넌트의 업데이트 방법과 그 순간 순간에 대해 좀 더 명확히 제어할 필요가 있습니다. 때문에 life cycle에 접근하여 컴포넌트를 제어하는 것이 필요하다면 이상적인 동작에 영향이 끼치지 않도록 조심스럽게 사용해야 합니다.</p>
<p><br></p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>일부 의역이 들어갔으며 오역이 존재할 수 있습니다. 해당 사항에 대해서는 댓글로 피드백 주시면 감사하겠습니다. 더 좋은 포스팅으로 뵙겠습니다! 감사합니다.</p>
<p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="external">https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1</a></em></p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
    </div>
</div>
    </div>
</div>

<footer class="footer">
    <ul class="list-inline text-center">
        <li>
            <a target="_blank" href="https://twitter.com/JbeeLjyhanll">
                <span class="fa-stack fa-lg">
                    <i class="iconfont icon-twitter"></i>
                </span>
            </a>
        </li>
        <li>
            <a target="_blank" href="https://www.facebook.com/devjbee">
                <span class="fa-stack fa-lg">
                    <i class="iconfont icon-facebook"></i>
                </span>
            </a>
        </li>
        <li>
            <a target="_blank" href="https://github.com/JaeYeopHan">
                <span class="fa-stack fa-lg">
                    <i class="iconfont icon-github"></i>
                </span>
            </a>
        </li>
    </ul>
    <p>
        Created By <a href="https://hexo.io/">Hexo</a> Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a>
    </p>
</footer>


</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</html>


<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Devlog">
    <title>Archives: 2017/4 - Devlog</title>
    <meta name="author" content="Jbee">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/feed.xml">
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="blog posted about front end development">
<meta property="og:type" content="blog">
<meta property="og:title" content="Devlog">
<meta property="og:url" content="https://jaeyeophan.github.io/archives/2017/04/page/2/index.html">
<meta property="og:site_name" content="Devlog">
<meta property="og:description" content="blog posted about front end development">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Devlog">
<meta name="twitter:description" content="blog posted about front end development">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Devlog</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Search"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/" target="_blank" rel="noopener" title="Google +">
                    
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/profile/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/mailto"
                            title="Mail"
                        >
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/04/21/YARN-New-Package-Manger/">
                            YARN, 새로운 Package Manger
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-04-21T19:18:49+09:00">
	
		    Apr 21, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Tool/">Tool</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/fe_tool_yarn.jpg" alt=""></p>
<h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><p><code>YARN</code>이란 Facebook에서 만든 새로운 자바스크립트 패키지 매니저입니다. 기존에 존재하는 <code>npm</code>과 동일한 기능을 수행합니다. 그렇다면 Facebook은 <code>YARN</code>을 왜 만들었을까요? 이 부분에 대해서는 정리가 잘 되어 있는 링크를 첨부할게요!<br><a href="http://fetobe.co.kr/%EC%83%88%EB%A1%9C%EC%9A%B4-npm-client-yarn/" target="_blank" rel="external">&gt;새로운 NPM Client YARN&gt;</a></p>
<h2 id="YARN-설치하기"><a href="#YARN-설치하기" class="headerlink" title="YARN 설치하기"></a>YARN 설치하기</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install yarn</div></pre></td></tr></table></figure>
<p><code>Homebrew</code>를 통하여 설치할 수 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn --version</div></pre></td></tr></table></figure></p>
<p>어느 모듈이나 마찬가지로 설치된 version을 확인할 수 있습니다.</p>
<h2 id="YARN-사용하기"><a href="#YARN-사용하기" class="headerlink" title="YARN 사용하기"></a>YARN 사용하기</h2><h3 id="새-프로젝트-시작하기"><a href="#새-프로젝트-시작하기" class="headerlink" title="새 프로젝트 시작하기"></a>새 프로젝트 시작하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn init</div></pre></td></tr></table></figure>
<p><code>npm</code>과 마찬가지로 <code>init</code>이라는 명령어를 통해 시작할 수 있으며, <code>package.json</code>파일이 없는 경우에는 <code>대화형 인터페이스</code>가 출력되면서 프로젝트를 설정할 수 있습니다. 이미 <code>package.json</code>이 존재하는 경우에는 해당 파일을 재사용하게 됩니다.</p>
<h3 id="패키지-설치하기"><a href="#패키지-설치하기" class="headerlink" title="패키지 설치하기"></a>패키지 설치하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ yarn add [package_name]</div><div class="line">$ yarn add [package_name]@[version]</div><div class="line">$ yarn add [package_name]@[tag]</div></pre></td></tr></table></figure>
<p><code>add</code>라는 command로 패키지를 설치(add)할 수 있습니다. <code>@</code>로 설치할 <code>version</code>과 <code>tag</code>를 명시할 수 있습니다.</p>
<h4 id="add-option"><a href="#add-option" class="headerlink" title="add option"></a><code>add</code> option</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn add [package_name] --dev / -D</div></pre></td></tr></table></figure>
<p>해당 패키지가 <code>devDependencies</code>에 추가됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn add [package_name] --peer / -P</div></pre></td></tr></table></figure></p>
<p>해당 패키지가 <code>peerDependencies</code>에 추가됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn add [package_name] --optional / -O</div></pre></td></tr></table></figure></p>
<p>해당 패키지가 <code>optionalDependencies</code>에 추가됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn add [package_name] --exact / -E</div></pre></td></tr></table></figure></p>
<p><code>@</code>로 version을 명시할 수 있지만, 보다 strict하게 version을 명시하여 설치하는 경우에 사용합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn add [package_name] --tilde / -T</div></pre></td></tr></table></figure></p>
<p>기본적으로 가장 최근 release version의 패키지를 설치하지만, 좀 더 최신의 version을 설치하는 경우에 사용합니다.</p>
<h3 id="패키지-업그레이드"><a href="#패키지-업그레이드" class="headerlink" title="패키지 업그레이드"></a>패키지 업그레이드</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ yarn upgrade [package_name]</div><div class="line">$ yarn upgrade [package_name]@[version]</div><div class="line">$ yarn upgrade [package_name]@[tag]</div></pre></td></tr></table></figure>
<p><code>upgrade</code>라는 명령어를 통해 설치한 패키지를 업그레이드 할 수 있습니다.</p>
<h3 id="모듈-제거"><a href="#모듈-제거" class="headerlink" title="모듈 제거"></a>모듈 제거</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn remove [package]</div></pre></td></tr></table></figure>
<p><code>remove</code>라는 명령어를 통해 설치한 패키지를 제거할 수 있습니다.</p>
<h3 id="다른-Command"><a href="#다른-Command" class="headerlink" title="다른 Command"></a>다른 Command</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn global [add/ls/remove/upgrade]</div></pre></td></tr></table></figure>
<p><code>npm</code>에서의 <code>--global</code> 와 비슷한 기능을 수행하는 <code>global</code> 이 추가된 명령어입니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn clean</div></pre></td></tr></table></figure></p>
<p><code>clean</code> 명령어는 현재 설치된 패키지들의 의존성을 분석하여 사용하지 않는, 불필요한 파일들을 제거해줍니다. 이 명령어를 한 번 실행하면 <code>.yarnclean</code> 파일이 생성되며 version control에 추가해야 합니다. 한 번 실행된 후, 불필요한 파일들을 제거해주는 작업은 yarn 커맨드를 통해 어떠한 패키지를 설치하는 경우(<code>add</code> or <code>run</code> command)에 자동적으로 수행됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn info [package_name] [option]</div></pre></td></tr></table></figure></p>
<p><code>info</code> 명령어를 통해 해당 패키지의 정보를 볼 수 있습니다. <code>option</code>으로 <code>readme</code>를 입력하게 되면 해당 패키지에 작성된 <code>README.md</code>파일을 볼 수 있습니다.(다양한 option command가 존재합니다!)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn list [--depth]</div></pre></td></tr></table></figure></p>
<p><code>list</code> 명령어를 통해 현재 작업 중인 디렉토리의 모든 패키지들의 의존성 관계를 리스트로 확인할 수 있습니다. <code>depth</code> 옵션을 통해서 level을 지정할 수도 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn outdated [package]</div></pre></td></tr></table></figure></p>
<p><code>outdated</code> 명령어를 통해 패키지들의 현재 설치된 version(Current)과 권장하는 version(Wanted), 최신 version(Latest)을 보여줍니다. 특정 <code>[package]</code>를 입력하여 원하는 패키지에 대해서만 볼 수 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn pack</div></pre></td></tr></table></figure></p>
<p><code>pack</code> 명령어를 통해 패키지의 의존성들을 <code>gzip</code>으로 압축시킬 수 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn run [script] [--&lt;args&gt;]</div></pre></td></tr></table></figure></p>
<p><code>run</code> 명령어를 통해 <code>npm</code>에서 처럼 <code>package.json</code>에서 정의한 <code>scripts</code>를 실행할 수 있습니다.</p>
<p>거의 모든 명령어가 기존에 사용하던 <code>npm</code>과 동일한 것을 확인하실 수 있었습니다 :)</p>
<h3 id="yarn-lock"><a href="#yarn-lock" class="headerlink" title="yarn.lock"></a>yarn.lock</h3><p><code>yarn</code>으로 모듈을 설치하다보면 <code>yarn.lock</code>이라는 파일이 생성된 것을 확인할 수 있다. 이것은 설치한 모듈들의 각각 의존성 관리를 해줍니다.<br>이미 <code>package.json</code>이 하고 있는거 아닌가? 라는 생각이 드는데요, 하지만 페이스북이 <code>yarn</code>을 만든 이유 중 하나는 보다 정확하게 패키지들의 의존성을 관리하기 위함이었습니다. <code>yarn.lock</code> 파일에는 <code>package.json</code>에 있는 것보다 더 많은 정보를 갖고 있습니다. 그렇기 때문에 좀 더 엄격한 의존성 관리가 가능하다고 합니다. (위에서 언급한 <code>.yarnclean</code>파일과 함께  version control system에 추가해줘야 합니다.)</p>
<h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>기존의 NPM과 많이 다를 줄 알고 열심히 정리했는데 거의 정말 비슷하네요! 같은 값이면 다홍치마라고, 좀 더 빠르고 의존성 관리를 정확하게 해주는 <code>YARN</code>으로 옮겨갈 때인가요? 이상 <code>YARN</code>에 대한 포스팅이었습니다 :)</p>
<h4 id="참고할-만한-링크"><a href="#참고할-만한-링크" class="headerlink" title="참고할 만한 링크"></a>참고할 만한 링크</h4><ul>
<li><a href="https://www.pluralsight.com/guides/node-js/yarn-a-package-manager-for-node-js" target="_blank" rel="external">YARN vs NPM</a></li>
<li><a href="https://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc" target="_blank" rel="external">YARN Cheet Sheet</a></li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/04/21/YARN-New-Package-Manger/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/04/21/YARN-New-Package-Manger/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/04/21/ES6-9-Iterator/">
                            [ES6] 9. Iterator
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-04-21T17:15:09+09:00">
	
		    Apr 21, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/ECMAScript6/">ECMAScript6</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/javascript_es6.png" alt=""></p>
<h1 id="ES6-9-Iterator"><a href="#ES6-9-Iterator" class="headerlink" title="[ES6] 9. Iterator"></a>[ES6] 9. Iterator</h1><p><a href="https://jaeyeophan.github.io/2017/04/18/ES6-3-Iteration-and-for-of-statement/">&gt;&gt;3. Iterable and for-of statement&gt;&gt;</a><br><a href="https://jaeyeophan.github.io/2017/04/20/ES6-8-Symbol/">&gt;&gt;8. Symbol</a></p>
<p><em>이 포스팅은 이전에 작성된 두 포스팅을 기반으로 작성되었습니다.</em>  </p>
<p><code>iterator</code>는 순회 가능한 값들의 <code>시퀀스</code>를 만드는 방법을 정의한다.<br>대표적인 순회 가능한 것은 <code>Array</code>다. <code>Array</code> 오브젝트는 <code>Symbol.iterator</code>를 가지고 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr[<span class="built_in">Symbol</span>.iterator]);<span class="comment">// function</span></div></pre></td></tr></table></figure></p>
<p>위 예제 코드에서 정의한 <code>arr</code>의 <code>iterator</code>를 추출하여 <code>arr</code>를 순회할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: 2, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: 3, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p><code>iterator</code>를 추출하자마자 <code>head</code>(공식 용어는 아니고 설명을 위한 용어)는 배열의 시작점을 가리키게 된다.(첫 원소를 가리키는 것이 아니다.) 그 상태에서 <code>next()</code>메소드를 호출하게 되면, 첫번재 원소가 출력된다. 출력 값은 원소의 값인 <code>value</code>와 <code>done</code>이라는 <code>boolean</code> 값을 가지고 있는 <code>Object</code>이다. 마지막 원소까지 출력된 상태에서 <code>next()</code> 메소드를 호출하게 되면 <code>value</code>는 <code>undefined</code>가 되고 <code>done</code> 값은 <code>true</code>가 된다.</p>
<p>문자열에도 적용할 수 있다. <code>String</code> 오브젝트도 <code>iterable</code>프로토콜을 구현한 오브젝트이기 때문에 <code>iterator</code>를 사용할 수 있는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">"jbee"</span>;</div><div class="line"><span class="keyword">let</span> iterator = name[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: j, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: b, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: e, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: e, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p><code>Object</code>에는 기본적으로 <code>iterator</code>가 존재하지 않는다. 때문에 <code>for-of</code>로 순회할 수 없다. 하지만 <code>iterator</code>를 오브젝트에 추가하여 <code>iterable</code>하게 만들 수 있다. 또한 배열을 상속받은 객체는 <code>iterable</code> 객체이므로 <code>iterator</code>를 사용할 수 있다.</p>
<p><code>iterator</code>를 사용하다 보면 뭔가 Java의 <code>interface</code> 또는 <code>@FunctionalInterface</code> 같은 느낌도 든다. java에서 해당 <code>interface</code>를 <code>implements</code>하게 되면 해당 기능을 사용할 수 있는 것처럼 구현하고자 하는 <code>Symbol</code>, 즉 <code>iterator</code>를 프로퍼티에 추가해서 사용하면 <code>iterator</code> 기능을 사용할 수 있는 것이다.</p>
<p>어떻게 하면 <code>iterator</code>를 그럴싸하게 사용해볼 수 있을까?<br>다음 예제는 이렇게 사용하면 어떨까? 정도의 예제 코드이다. 가볍게 보고 넘어가자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Object to create id</span></div><div class="line"><span class="keyword">let</span> autoIncrement = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">    <span class="keyword">let</span> id = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      next() &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">          <span class="attr">value</span>: ++id,</div><div class="line">          <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Define User class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(id, name) &#123;</div><div class="line">    <span class="keyword">this</span>.id = id;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> idCreator = autoIncrement[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> User(idCreator.next().value, <span class="string">"jbee"</span>));<span class="comment">// &#123; id: 1, name: 'jbee' &#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> User(idCreator.next().value, <span class="string">"foo"</span>));<span class="comment">// &#123; id: 2, name: 'foo' &#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> User(idCreator.next().value, <span class="string">"bar"</span>));<span class="comment">// &#123; id: 3, name: 'bar' &#125;</span></div></pre></td></tr></table></figure></p>
<p><code>autoIncraement</code> 객체에 <code>iterator</code> 프로퍼티를 추가하여, <code>id</code>를 순차적으로 생성하게 만들었다. <code>id</code>에 대해서는 외부에서 접근할 수 없으므로 안정적인 <code>id</code>가 생성될 수 있지 않을까?</p>
<p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="external">Github Respository</a>에서 확인하실 수 있습니다.</p>
<p><em>9.end</em></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/04/21/ES6-9-Iterator/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/04/21/ES6-9-Iterator/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/04/20/ES6-8-Symbol/">
                            [ES6] 8. Symbol
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-04-20T11:53:45+09:00">
	
		    Apr 20, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/ECMAScript6/">ECMAScript6</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/javascript_es6.png" alt=""></p>
<h1 id="ES6-8-Symbol"><a href="#ES6-8-Symbol" class="headerlink" title="[ES6] 8. Symbol"></a>[ES6] 8. Symbol</h1><h2 id="Symbol이란-무엇인가"><a href="#Symbol이란-무엇인가" class="headerlink" title="Symbol이란 무엇인가?"></a>Symbol이란 무엇인가?</h2><blockquote>
<p>고유하고 수정 불가능한 데이터 타입(?)</p>
</blockquote>
<p>자바스크립트에는 <code>Primitive type</code>이라는 개념이 있다. ES5에는 <code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>로 총 <strong>5가지</strong>의 원시 자료형이 존재한다. 여기에 ES6부터 <code>symbol</code>이라는 타입이 추가되었다.</p>
<p><code>Primitive type</code>들에게는 각각 Wrapper Object가 존재한다.(undefined와 null은 wrapper object가 존재하지 않는다.) <code>String</code> 오브젝트, <code>Boolean</code>오브젝트가 그 예이다. <code>symbol</code>도 마찬가지로 <code>Symbol</code> 오브젝트라는 wrapper Object가 존재한다. 각각의 wrapper obect에는 값을 처리하기 위한 메서드와 프로퍼티가 존재한다. <code>valueOf()</code>메소드를 통해 primitive value를 구할 수 있는 것이다. 하지만, <code>symbol</code>은 값을 반환하지 않는다!</p>
<h2 id="Symbol-도입-배경"><a href="#Symbol-도입-배경" class="headerlink" title="Symbol 도입 배경"></a>Symbol 도입 배경</h2><blockquote>
<p>왜 Symbol이 도입되었을까?</p>
</blockquote>
<p>처음 <code>Symbol</code>을 봤을 때는 <code>고유한 값</code>이라는 말에 <code>const</code>를 떠올렸다. 하지만 <code>Symbol</code>은 프로그램 전체를 통틀어 유일한 값을 의미한다. <code>Symbol()</code>이 실행될 때마다 유일한 값을 생성하는 것이다. 약속된 <code>Symbol</code> 값을 가지고 객체에 어떠한 특성을 부여할 수 있지 않을까? <code>Symbol</code>이란 무엇인가 먼저 알아보자.<br><em>(사실 라이브러리를 만들거나 프레임워크를 만들지 않는 이상, 실무에서 사용할 일이 거의 없을 것 같다.)</em></p>
<h2 id="Symbol에-대해서"><a href="#Symbol에-대해서" class="headerlink" title="Symbol에 대해서"></a>Symbol에 대해서</h2><p><code>Symbol</code>은 두 가지 <code>스코프(scope)</code>에 <code>생성</code>하여 <code>저장</code>할 수 있다.</p>
<h3 id="Symbol-생성하기-1"><a href="#Symbol-생성하기-1" class="headerlink" title="Symbol 생성하기 1"></a>Symbol 생성하기 1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="string">"symbol description"</span>);</div><div class="line"><span class="comment">//Error: Symbol is not a constructor</span></div></pre></td></tr></table></figure>
<p><code>Symbol</code>은 <strong>객체가 아니다.</strong> 객체가 아닌 <code>Primitive type</code>이기 때문에 <code>new</code>키워드를 통해서 생성할 수 없다.<br><code>Symbol</code>을 생성할 때에는 다음과 같이 생성한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">"symbol description"</span>);</div></pre></td></tr></table></figure>
<p><code>console.log()</code>를 통해 <code>Symbol</code>의 특징을 살펴보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);<span class="comment">//symbol</span></div><div class="line"><span class="built_in">console</span>.log(s.toString());<span class="comment">//Symbol(symbol description)</span></div><div class="line"><span class="built_in">console</span>.log(s.valueOf());<span class="comment">//&#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(s);<span class="comment">//&#123;&#125;</span></div></pre></td></tr></table></figure></p>
<p>1) <code>Symbol</code>의 타입은 <code>symbol</code>이다.<br>2) 모든 built-in 오브젝트의 프로토타입에 연결되어 있는 <code>toString</code> 메소드를 통해서 <code>Symbol</code>의 <code>형태(description)</code>를 확인할 수 있다. 여기서 <code>형태</code>란 <code>Symbol</code>을 생성할 때 넘겨지는 parameter를 말한다. 주로 생성하는 <code>Symbol</code>을 설명하기 위한 문자열을 넘겨준다. 왠지 이 값을 통해 <code>Symbol</code>에 접근할 수 있을 것 같지만 그럴 수 없다.<br>3) 뒤에서 확인할 테지만 <code>Symbol</code>은 값을 외부로 노출시키지 않는다. 이러한 특성 때문에 <code>Symbol</code>을 출력하려고 하거나 <code>valueOf()</code> 메소드를 통해 값을 출력하려고 하면 <code>empty object</code>가 반환이 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"s1: "</span>, s1.toString());<span class="comment">//Symbol(foo)</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"s2: "</span>, s2.toString());<span class="comment">//Symbol(foo)</span></div><div class="line"><span class="built_in">console</span>.log(s1 == s2);<span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>두 <code>Symbol</code>은 같은 <code>description</code>을 갖고 있는 <code>Symbol</code>일 뿐, 다른 <code>Symbol</code>이다. <code>Symbol()</code>이 <strong>호출될 때마다</strong> 새로운 <code>Symbol</code>을 생성하기 때문이다. 이 때 <code>Symbol</code>은 생성한 <code>scope</code>에 <code>Symbol</code>값이 설정된다.</p>
<h3 id="Symbol-생성하기-2-key"><a href="#Symbol-생성하기-2-key" class="headerlink" title="Symbol 생성하기 2, key"></a>Symbol 생성하기 2, key</h3><p>아까 생성한 <code>Symbol</code>을 다시 사용할 니즈가 있을 것 같다. 그래서 고유한 값을 갖는 <code>Symbol</code>을 만들 때, <code>key</code>를 등록하고, <code>key</code>를 통해 접근한다.</p>
<ul>
<li><code>for</code> 메소드<br><code>for</code> 메소드를 사용하여 생성 또는 호출할 수 있다. <code>key</code> 값이 파라미터로 넘어가고 등록되어 있는 <code>Symbol</code>을 반환한다. 이 때 <code>key</code> 값에 해당하는 <code>Symbol</code>이 없다면 해당 <code>Symbol</code>을 <code>Symbol registry</code>에 등록한다. 즉 없으면 생성하는 것이다.</li>
<li><code>keyFor</code> 메소드<br><code>keyFor</code> 메소드는 <code>Symbol</code>을 받아서 해당 <code>Symbol</code>의 <code>description</code> 값을 반환한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sFor1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="keyword">let</span> sFor2 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">console</span>.log(sFor1.toString());<span class="comment">//Symbol(foo)</span></div><div class="line"><span class="built_in">console</span>.log(sFor2.toString());<span class="comment">//Symbol(foo)</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(sFor1));<span class="comment">//foo</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(sFor2));<span class="comment">//foo</span></div><div class="line"><span class="built_in">console</span>.log(sFor1 == sFor2);<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(sFor1 === sFor2);<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>같은 <code>key</code>값으로 <code>Symbol</code>을 호출하게 되면 두 <code>Symbol</code>은 같은 <code>Symbol</code>이다. 위에서 그냥 <code>Symbol()</code>을 통해 생성한 것과의 차이점은 <code>key</code>값과 함께 <code>Symbol</code>을 만들게 되면 <code>Global Symbol registry</code>에 해당 <code>Symbol</code>이 등록되어 <code>Symbol()</code>이 호출될 때마다 새로운 <code>Symbol</code>이 생성되지 않는다.<br><em>cf&gt; <code>Global Symbol registry</code>란 <code>Symbol</code>값을 공유하기 위한 영역으로 다른 자바스크립트 프레임워크에서도 공유할 수 있다.</em></p>
<h3 id="Symbol-특징-1"><a href="#Symbol-특징-1" class="headerlink" title="Symbol 특징 1"></a>Symbol 특징 1</h3><p>위의 예제에서도 살펴봤듯이, <code>Symbol</code>은 값을 외부에 노출시키지 않는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">"symbol description"</span>);</div><div class="line"><span class="built_in">console</span>.log (<span class="string">`symbol: <span class="subst">$&#123;sym&#125;</span>`</span>);</div><div class="line"><span class="comment">//TypeError: Cannot convert a Symbol value to string</span></div></pre></td></tr></table></figure></p>
<p>그렇기 때문에 <code>Template literal</code>에서 사용할 수 없다. 또한 <code>JSON.stringify()</code>메소드를 통해서 특정 오브젝트를 <code>stringify</code>하려고 해도 빈 객체가 리턴된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">"symbol description"</span>);</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [sym]: <span class="string">"value"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(obj);</div><div class="line"><span class="built_in">console</span>.log(str);<span class="comment">//&#123;&#125;</span></div></pre></td></tr></table></figure></p>
<p>값을 외부에 노출시키지 않기 때문이다.</p>
<h3 id="Symbol-특징-2"><a href="#Symbol-특징-2" class="headerlink" title="Symbol 특징 2"></a>Symbol 특징 2</h3><p>객체에 <code>Symbol</code>로 등록된 프로퍼티를 <code>symbol-keyed property</code>라고 하는데 이 <code>symbol-keyed property</code>는 Object의 <code>getOwnPropertyNames</code> 반환 값에서 제외된다.<br><figure class="highlight javascript"><figcaption><span>user.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> user = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>.for(<span class="string">"name"</span>)] : <span class="string">"jbee"</span>,</div><div class="line">  <span class="attr">age</span> : <span class="number">25</span>,</div><div class="line">  <span class="attr">major</span>: <span class="string">"Computer Science"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(user));<span class="comment">//['age', 'major']</span></div></pre></td></tr></table></figure></p>
<p>그렇기 때문에 <code>for-in statement</code>에서 열거되지 않는다.</p>
<figure class="highlight javascript"><figcaption><span>user.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> user) &#123;</div><div class="line">  <span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>&gt;</div><div class="line">age</div><div class="line">major</div></pre></td></tr></table></figure>
<p>Object의 <code>symbol-keyed property</code>는 <code>getOwnPropertySymbols()</code> 메소드를 통해 확인할 수 있다.<br><figure class="highlight javascript"><figcaption><span>user.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(user)[<span class="number">0</span>].toString());<span class="comment">//Symbol(name)</span></div></pre></td></tr></table></figure></p>
<p><code>symbol-keyed property</code>로 value에 접근할 때는 <code>[]</code>를 통해 접근해야 한다. <code>.</code>을 통해 접근하면 <code>undefined</code>가 반환된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>.for(<span class="string">"name"</span>);</div><div class="line"><span class="keyword">let</span> user = &#123;</div><div class="line">  [sym] : <span class="string">"jbee"</span>,</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(user.sym);<span class="comment">//undefined</span></div><div class="line"><span class="built_in">console</span>.log(user[sym]);<span class="comment">//jbee</span></div></pre></td></tr></table></figure></p>
<p><code>.</code>(dot)을 통해서 <code>getOwnPropertyNames</code>에서 반환되는 <strong>일반적인</strong> 프로퍼티에 접근했다면 <code>symbol-keyed property</code>에는<code>[]</code>을 통해 접근하는 것이라고 생각해볼 수 있겠다.</p>
<h2 id="Well-known-Symbols"><a href="#Well-known-Symbols" class="headerlink" title="Well-known Symbols"></a>Well-known Symbols</h2><p><code>built-in Symbol property</code>로 Override하여 기능을 추가 및 변경할 수 있다. 대표적인 세 가지에 대해 알아보자.(<code>iterator</code>는 다음 포스팅에서 따로 다룬다.)</p>
<h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>객체의 기본 설명(description)에 사용되는 문자열 값을 지정할 수 있으며 <code>Object.prototype.toString()</code> 메소드가 호출될 때 사용된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">"jbee"</span>);</div><div class="line"><span class="built_in">console</span>.log(user.toString());<span class="comment">//[object Object]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"jbee"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.toString());<span class="comment">//[object Object]</span></div><div class="line"></div><div class="line">User.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">"User"</span>;</div><div class="line"><span class="built_in">Object</span>.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">"Obj"</span>;</div><div class="line"><span class="built_in">console</span>.log(user.toString());<span class="comment">//[object User]</span></div><div class="line"><span class="built_in">console</span>.log(obj.toString());<span class="comment">//[object Obj]</span></div></pre></td></tr></table></figure></p>
<p><code>new</code> 키워드를 통해 생성한 인스턴스와 <code>객체 리터럴</code>로 생성한 객체 둘 다 <code>[object Object]</code>라는 값으로 출력되기 때문에 구분하는 것이 어렵다. <code>toStringTag</code> 프로퍼티를 오버라이드하여 customize할 수 있다.</p>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> sum = values + <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//1,2,3100</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sum);<span class="comment">//string</span></div></pre></td></tr></table></figure>
<p>배열이 <code>string</code>으로 casting이 되고 그 뒤에 연산되는 <code>100</code> 마저 <code>string</code>으로 casting이 된다. 그래서 결과값이 <code>string</code>타입의 <code>1,2,3100</code>이 되는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//overriding</span></div><div class="line">values[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(hint);</div><div class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> values) &#123;</div><div class="line">    result += item;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> sum2 = values + <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sum2: "</span>, sum2);<span class="comment">//106</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sum2);<span class="comment">//number</span></div></pre></td></tr></table></figure></p>
<p>위 예제 코드에서는 <code>toPrimitive</code>라는 값을 통해서 배열의 값이 어떻게 반환될 지를 결정한다. 이 예제 코드에서는 배열의 모든 element 값을 더한 값으로 설정했다.<br><code>hint</code>라는 값을 console로 찍어보기만 하고 아직 사용하지 않았는데, 이 <code>hint</code> 값을 통해서 어떠한 형태로 반환할 지 분기를 나눌 수 있다. 다음 코드를 살펴보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</div><div class="line">    <span class="keyword">if</span> (hint === <span class="string">"number"</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (hint === <span class="string">"string"</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">"문자열"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"default"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log (<span class="string">"default: "</span>, <span class="number">100</span> + obj);<span class="comment">//100default</span></div><div class="line"><span class="built_in">console</span>.log (<span class="string">"number: "</span>, <span class="number">1</span> * obj);<span class="comment">//number: 1</span></div><div class="line"><span class="built_in">console</span>.log (<span class="string">`string: <span class="subst">$&#123;obj&#125;</span>`</span>);<span class="comment">//string: 문자열</span></div><div class="line"><span class="built_in">console</span>.log(+obj +<span class="number">1</span>);<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p><code>[Symbol.toPrimitive]()</code>가 호출되면 자바스크립트 엔진은 parameter인 <code>hint</code>에 <code>number</code>, <code>string</code>, <code>default</code> 셋 중 하나를 설정하게 된다. 엔진은 어떻게 <code>hint</code>값을 설정할까? 네 개의 <code>console</code>을 찍어봤다.</p>
<ol>
<li><code>100 + obj</code>에서는 <code>obj</code>가 피연산자(연산 대상)이므로 <code>default</code>가 설정된다.</li>
<li><code>1 * obj</code>에서는 <code>*</code>연산 때문에 <code>number</code>가 설정된다. (곱셈 말고도 뺄셈, 나눗셈도 <code>number</code>가 설정된다.)</li>
<li><code>${obj}</code>에서는 <code>Template literal</code>로 사용되었으므로 <code>string</code>이 설정된다.</li>
<li><code>+obj +1</code>에서는 <code>+</code>라는 단항 연산자가 <code>obj</code>앞에 붙어서 <code>number</code>가 설정된다.</li>
</ol>
<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p><code>Array</code> 오브젝트의 <code>concat()</code>이라는 함수를 호출할 때의 상황을 지정하는 프로퍼티다. 두 배열을 결합할 때, 배열의 <code>펼침 여부</code>를 지정할 수 있다. <code>default value</code>는 <code>true</code>이다. 다음 예제 코드를 살펴보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> prev = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">let</span> post = [<span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(prev.concat(post));<span class="comment">//[1, 2, 3, 4]</span></div><div class="line"></div><div class="line">prev[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</div><div class="line"><span class="built_in">console</span>.log(prev.concat(post));<span class="comment">//[[1, 2], 3, 4]</span></div><div class="line">post[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</div><div class="line"><span class="built_in">console</span>.log(prev.concat(post));<span class="comment">//[[1, 2], [3, 4]]</span></div></pre></td></tr></table></figure></p>
<p>배열을 결합할 때, 펼치지 않고(프로퍼티 값을 <code>false</code>로 지정하고) 결합을 하게 되면, 배열의 구조를 그대로 유지하면서 합쳐진다. <code>Array-like</code> 오브젝트에서도 <code>concat()</code> 함수의 결과 형태를 지정할 수 있다.</p>
<h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>이 이외에도 <code>@@iterator</code>, <code>@@hasInstance</code>, <code>@@replace</code>, <code>@@species</code> 등 다양한 <code>Well-known Symbol</code>들이 존재한다. 이 <code>Well-known Symbol</code>들은 이미 ES5 스펙에서부터 존재했었고 자연스럽게 그것들을 사용해왔던 것이고 ES6에서 각 프로퍼티들을 오버라이드하여 좀 더 유연한 코드를 작성할 수 있게 끔 공개된 것이다.<br><em>cf&gt; <code>@@</code>은 <code>Symbol</code> 대신 사용할 수 있는 약자이다.</em></p>
<p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="external">Github Respository</a>에서 확인하실 수 있습니다.</p>
<h4 id="Symbol과-관련된-다른-글들"><a href="#Symbol과-관련된-다른-글들" class="headerlink" title="Symbol과 관련된 다른 글들"></a>Symbol과 관련된 다른 글들</h4><ul>
<li><a href="https://perfectacle.github.io/2017/04/16/ES6-Symbol/index.html" target="_blank" rel="external">(ES6) Symbol - 양권성님 블로그 글</a></li>
</ul>
<p><em>8. end</em></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/04/20/ES6-8-Symbol/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/04/20/ES6-8-Symbol/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/04/19/ES6-7-Template-literal/">
                            [ES6] 7. Template literal
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-04-19T16:26:04+09:00">
	
		    Apr 19, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/ECMAScript6/">ECMAScript6</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/javascript_es6.png" alt=""></p>
<h1 id="ES6-7-Template-literal"><a href="#ES6-7-Template-literal" class="headerlink" title="[ES6] 7. Template literal"></a>[ES6] 7. Template literal</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">`template literal`</span>);</div></pre></td></tr></table></figure>
<p>ES6에서 문자열 처리를 보다 간편하게 할 수 있는 <code>템플릿</code>을 제공한다. 문자열 처리를 위해 single quote나 double quote가 아닌 <strong>Backtick</strong>을 사용한다. 변수를 <code>${ }</code>로 감싸서 inline으로 표현할 수 있으며 \n을 작성할 필요없이 Backtick 안에서 개행을 해주면 된다. 기존의 템플릿 엔진들에서 제공하고 있었던 기능인 <code>${ }</code> 안에는 <code>변수</code> 또는 <code>연산식</code> 등의 <code>표현식</code>이 들어갈 수 있다.<br><em>Example code&gt;</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">"jbee"</span>;</div><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hi, "</span> + name + <span class="string">"!\nHave a nice day!"</span>);</div><div class="line"><span class="comment">// console&gt;</span></div><div class="line"><span class="comment">// Hi, jbee!</span></div><div class="line"><span class="comment">// Have a nice day!</span></div><div class="line"></div><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">let</span> grettingTemplate = <span class="string">`</span></div><div class="line">Hi, <span class="subst">$&#123;name&#125;</span>!</div><div class="line">Have a nice day!</div><div class="line">`;</div><div class="line"><span class="built_in">console</span>.log(grettingTemplate);</div><div class="line"><span class="comment">//console&gt;</span></div><div class="line"><span class="comment">// Hi, jbee!</span></div><div class="line"><span class="comment">// Have a nice day!</span></div></pre></td></tr></table></figure></p>
<p>Template literal을 사용하여 거추장스러운 <code>&#39;+&#39;</code>이나 <code>&#39;\n&#39;</code>을 더이상 사용하지 않아도 된다.</p>
<h2 id="tagged-template"><a href="#tagged-template" class="headerlink" title="tagged template"></a>tagged template</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">"jbee"</span></div><div class="line"><span class="keyword">let</span> num = <span class="number">27</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`hi, <span class="subst">$&#123;name&#125;</span>! Have a nice day! <span class="subst">$&#123;num&#125;</span> is your number`</span>);</div><div class="line"><span class="comment">//console&gt; hi, jbee! Have a nice day! 27 is your number</span></div></pre></td></tr></table></figure>
<p>위 템플릿 리터럴을 <code>tagged template</code>을 사용하여 <code>text</code>와 <code>value</code>로 분리할 수 있다. <code>text</code>는 공백 문자를 기준으로 <code>배열</code>의 형태로 파라미터가 들어오며, ${ } 안의 표현식은 <code>value</code>라는 파라미터로 <code>String</code> type으로 들어온다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">text, value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(text);</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> value);</div><div class="line">&#125;</div><div class="line">greet <span class="string">`hi, <span class="subst">$&#123;name&#125;</span>! Have a nice day! <span class="subst">$&#123;num&#125;</span> is your number`</span>;</div><div class="line"><span class="comment">//console&gt; [ 'hi, ', '! Have a nice day! ', ' is your number' ]</span></div><div class="line"><span class="comment">//console&gt; jbee</span></div><div class="line"><span class="comment">//console&gt; string</span></div></pre></td></tr></table></figure></p>
<p>parameter로 넘겨지는 <code>value</code>는 하나인데, 템플릿 리터럴에는 표현식이 두개가 존재한다. 그렇기 때문에 number에 해당하는 값이 함수로 넘겨지지 못했다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">text, value, value2</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(text);</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">    <span class="built_in">console</span>.log(value2);</div><div class="line">&#125;</div><div class="line">greet <span class="string">`hi, <span class="subst">$&#123;name&#125;</span>! Have a nice day! <span class="subst">$&#123;num&#125;</span> is your number`</span>;</div><div class="line"><span class="comment">//console&gt; [ 'hi, ', '! Have a nice day! ', ' is your number' ]</span></div><div class="line"><span class="comment">//console&gt; jbee</span></div><div class="line"><span class="comment">//console&gt; 27</span></div></pre></td></tr></table></figure></p>
<p>이렇게 해결할 수 있지만, 지난 chapter에서 다룬 <code>Rest parameter</code>를 사용할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">text, ...value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(text);</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line">greet <span class="string">`hi, <span class="subst">$&#123;name&#125;</span>! Have a nice day! <span class="subst">$&#123;num&#125;</span> is your number`</span>;</div><div class="line"><span class="comment">//console&gt; [ 'hi, ', '! Have a nice day! ', ' is your number' ]</span></div><div class="line"><span class="comment">//console&gt; [ 'jbee', 27 ]</span></div></pre></td></tr></table></figure></p>
<h3 id="템플릿-리터컬의-표현식-값-결정"><a href="#템플릿-리터컬의-표현식-값-결정" class="headerlink" title="템플릿 리터컬의 표현식 값 결정"></a>템플릿 리터컬의 표현식 값 결정</h3><p>템플릿 리터럴을 사용하여 문자열을 함수의 파라미터를 넘길 수 있을 것이다. 그렇다면 템플릿 러터럴 내부의 표현식의 값은 언제 결정될까?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Assign expression statement</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> name = <span class="string">`ecmascript`</span>;</div><div class="line">    <span class="built_in">console</span>.log(message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> name = <span class="string">`jbee`</span>;</div><div class="line">greeting(<span class="string">`Hi, <span class="subst">$&#123;name&#125;</span>`</span>);</div><div class="line"><span class="comment">//console&gt; Hi, jbee</span></div></pre></td></tr></table></figure></p>
<p>함수의 파라미터로 <strong>넘겨질 때부터</strong> 결정되어 넘어가기 때문에 <code>greeting</code>이라는 함수 내부에 있는 local variable인 <code>ecmascript</code>라는 단어가 <code>name</code>으로 들어가지 않고 <code>jbee</code>라는 문자열이 <code>name</code>의 값으로 결정되었다.</p>
<p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="external">Github Respository</a>에서 확인하실 수 있습니다.</p>
<p><em>7. end</em></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/04/19/ES6-7-Template-literal/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/04/19/ES6-7-Template-literal/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/04/19/TS-0-Quick-Start/">
                            [TS] 0. Quick Start
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-04-19T13:49:15+09:00">
	
		    Apr 19, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-0-Quick-Start"><a href="#TS-0-Quick-Start" class="headerlink" title="[TS] 0. Quick Start"></a>[TS] 0. Quick Start</h1><p>이 포스팅은 TypeScript Official Document를 번역 및 의역한 자료입니다. 직접 타이핑 해본 결과 5분정도 소요되는 짧은 Quick start 입니다:) 가볍게 봐주세요.</p>
<h2 id="Install-TypeScript"><a href="#Install-TypeScript" class="headerlink" title="Install TypeScript"></a>Install TypeScript</h2><p>npm을 통해서 간단하게 TypeScript를 설치할 수 있습니다. VSCode 등 타입스크립트를 지원하는 에디터에서는 플러그인을 통해서 설치가 가능합니다.</p>
<p>via npm<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g typescript</div></pre></td></tr></table></figure></p>
<p>command를 이용하여 또는 Editor를 열어 <code>greeter.ts</code>라는 파일을 만듭니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ touch greeter.ts</div></pre></td></tr></table></figure></p>
<p><code>greeter.ts</code>코드는 다음과 같습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + person;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> user = <span class="string">"Jane User"</span>;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</div></pre></td></tr></table></figure></p>
<p>TypeScript는 <code>.ts</code>라는 확장자를 사용합니다. 이 파일은 컴파일되어 <code>greeter.js</code>파일이 됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tsc greeter.ts</div></pre></td></tr></table></figure></p>
<p><code>tsc</code>라는 명령어를 통해서 TypeScript로 작성된 파일을 컴파일할 수 있습니다.<br>현재 <code>greeter.ts</code>에 작성되어있는 코드는 기존의 JavaScript와 다를 바가 없습니다. 이 JavaScript code인 <code>greeter.ts</code>에 TypeScript 문법을 하나씩 추가해보겠습니다.</p>
<h2 id="TypeScript가-제공하는-대표적인-기능"><a href="#TypeScript가-제공하는-대표적인-기능" class="headerlink" title="TypeScript가 제공하는 대표적인 기능"></a>TypeScript가 제공하는 대표적인 기능</h2><h3 id="Type-annotations"><a href="#Type-annotations" class="headerlink" title="Type annotations"></a>Type annotations</h3><p>동적으로 변수의 타입을 결정했던 JavaScript에게 타입이 생겼습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>TypeScript</strong>는 Type을 제공합니다. Type annotations는 함수가 받는 parameter에 타입을 지정해주어, 함수 내부에서 별도의 타입 체크 없이 parameter를 사용할 수 있게 해줍니다. 즉, <code>person</code>에 다른 타입의 parameter가 주어지면 error가 발생하게 됩니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + person;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> user = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</div></pre></td></tr></table></figure></p>
<p>error:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">greeter.ts(7,26): Supplied parameters do not match any signature of call target</div></pre></td></tr></table></figure></p>
<p>타입스크립트는 코드의 구조와 작성된 <code>type annotation</code>으로 정적 분석을 제공합니다. 위와 같이 error가 발생하더라도 타입스크립트 파일은 컴파일되어 <code>.js</code>파일을 만들게 됩니다. TypeScript의 역할은 제대로 동작하지 않을 것 같은 코드에 대해 개발자에게 <code>warning</code>해주는 역할이라고 생각해도 될 것 같습니다 :)</p>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>Java개발자라면 익숙한 <code>interface</code> 문법입니다. 위에서 사용했던 예제를 <code>interface</code>를 사용하여 확장해보겠습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Person &#123;</div><div class="line">    firstName: <span class="built_in">string</span>;</div><div class="line">    lastName: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + person.firstName + <span class="string">" "</span> + person.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> user = &#123; firstName: <span class="string">"Jane"</span>, lastName: <span class="string">"User"</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</div></pre></td></tr></table></figure></p>
<p>함수의 parameter에 <code>String</code>이라는 타입 대신 인터페이스(interface)를 적용했습니다. Java의 Generic과 비슷하게 보이는데요, interface를 사용하여 함수가 넘겨받는 parameter의 타입을 보다 구체적으로 정의할 수 있게 되었습니다. 위의 예제 코드와 마찬가지로 정의된 type과 맞지 않은 type의 parameter가 전달되면 error를 출력합니다.</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>ES6(ECMAScript2015)에서부터 추가된 <code>Class</code> 문법입니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Student &#123;</div><div class="line">    fullName: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> firstName, <span class="keyword">public</span> middleInitial, <span class="keyword">public</span> lastName</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.fullName = firstName + <span class="string">" "</span> + middleInitial + <span class="string">" "</span> + lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> Student(<span class="string">"Jane"</span>, <span class="string">"M."</span>, <span class="string">"User"</span>);</div></pre></td></tr></table></figure></p>
<p>ES6의 <code>Class</code>와는 약간 다른 모습을 보입니다. 바로 Class 내부에서 <code>field member</code>를 갖게 된 것입니다. 하지만 그 근본은 ES6의 <code>Class</code>와 같습니다. JavaScript에서 프로토타입을 통해 구현했던 OOP를 보다 간결한 방법으로 문법을 제공하는 것입니다.</p>
<p>공식 문서에서 제공하는 Quick Start를 통해서 TypeScript 맛보기를 해봤습니다. 감사합니다.</p>
<p><em>0. Quick start end</em></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/04/19/TS-0-Quick-Start/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/04/19/TS-0-Quick-Start/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/04/19/TypeScript-Recent/">
                            TypeScript 근황
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-04-19T13:39:38+09:00">
	
		    Apr 19, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TypeScript-근황"><a href="#TypeScript-근황" class="headerlink" title="TypeScript 근황"></a>TypeScript 근황</h1><p>얼마 전, 구글의 발표에 타입스크립트에 관심을 갖게 되었습니다. 기술적인 내용보다는 여러 기술 소식이 담긴 포스팅입니다.<br>이 포스팅은 17년 4월 중순 경에 작성되었으며 작성되는 시점의 TypeScript version은 <code>2.2 version</code>입니다.<br>(4월 28일, 2.3 version이 release되었습니다.)</p>
<h2 id="JavaScript의-미래"><a href="#JavaScript의-미래" class="headerlink" title="JavaScript의 미래"></a>JavaScript의 미래</h2><p>올해가 벌써 2017년이니, 재작년인 2015년에 <code>ECMAScript2015(aka ECMAScript6 or ES6)</code>가 JavaScript 표준으로 정의되었고, 작년에는 <code>ECMAScript2016(aka ECMAScript7 or ES7)</code>이 발표되었습니다. 머지않아 <code>ECMAScript2017</code>도 발표될 예정(6월 예정)이라고 합니다. <code>Node.js</code>의 등장으로 JavaScript가 소프트웨어 개발 환경에서 막대한 비중을 차지하자 현재 <a href="https://github.com/tc39/tc39-notes" target="_blank" rel="external">tc39</a>라는 커뮤니티에서 끊임없이 JavaScript라는 언어의 표준을 명세하고 있습니다. 이것은 무엇을 의미할까요?</p>
<p>TypeScript에 대한 이야기를 하기 위해 JavaScript에 관한 내용은 다음 글을 참조하시면 좋을 것 같아 링크를 첨부합니다. <a href="http://d2.naver.com/helloworld/2809766" target="_blank" rel="external">2017년과 이후 JavaScript의 동향 - JavaScript(ECMAScript)</a></p>
<h2 id="TypeScript의-정체"><a href="#TypeScript의-정체" class="headerlink" title="TypeScript의 정체"></a>TypeScript의 정체</h2><blockquote>
<p>TypeScript란 JavaScript의 <code>super set</code>이다.</p>
</blockquote>
<p>어디선가 이런 말을 많이 들어봤을것 같은데요.<br><img src="/images/typescript_javascript.png" alt=""><br>사실, TypeScript는 JavaScript입니다. 기존의 JavaScript와는 다르게 <code>.ts</code>라는 확장자를 갖고 있지만 결국 JavaScript로 compile되는 언어입니다. JavaScript의 성장과 동시에 언어 자체의 한계점을 인지한 MicroSoft는 JavaScript에 <code>타입(Type)</code>을 추가해서 TypeScript를 만듭니다.(TypeScript의 Type system을 <a href="https://en.wikipedia.org/wiki/Structural_type_system" target="_blank" rel="external">Structural Type System</a>이라고 합니다.) 그리고 2016년 9월에 TypeScript 2.0 버전이 공개되었습니다.(현재는 <a href="http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html" target="_blank" rel="external">2.2 version</a> 이네요!)</p>
<p>이와 같은 움직임은 Google에서 개발한 <code>Dart</code>에서도 찾아볼 수 있습니다. 하지만 얼마 전, 프론트엔드 개발자들의 눈길을 끌만한 소식이 들려왔습니다.</p>
<blockquote>
<p><a href="http://www.zdnet.co.kr/news/news_view.asp?artice_id=20170413085316&amp;lo=z45" target="_blank" rel="external">MS 타입스크립트, 구글 사내 표준 언어되다.</a></p>
</blockquote>
<p>Google이 만든 프론트엔드 프레임워크 Angular2(얼마 전, <a href="http://angularjs.blogspot.kr/2017/03/angular-400-now-available.html" target="_blank" rel="external">Angular4.0</a>이 release되었습니다.)도 Dart, JavaScript를 지원하지만 TypeScript를 공식 언어로 지정할만큼 TypeScript의 위상이 높아졌다는 것을 확인하실 수 있습니다.</p>
<p>이에 더해, 다들 아실만한 협업 툴인 Slack이 TypeScript로 전환했습니다. 다음 링크는 Slack이 코드베이스를 TypeScript로 전환하는 과정에 대한 글로, 정적 분석의 필요성에 대해 인지했다는 내용입니다. <a href="https://slack.engineering/typescript-at-slack-a81307fa288d" target="_blank" rel="external">TypeScript at Slack</a></p>
<p>Facebook에서 개발한 정적 타입 분석기(static typechecker of javascript) <code>Flow</code>도 마찬가지 행보가 아닐까 생각합니다. 애플리케이션의 규모가 커질 수록 안정성에 대한 수요는 높아지기 마련입니다. 동적 타입이라는 JavaScript가 갖고 있는 장점이자 한계점인 이 부분을 해결하기 위해 정적 분석의 중요도가 높아지고 있습니다.</p>
<h2 id="TypeScript의-현주소"><a href="#TypeScript의-현주소" class="headerlink" title="TypeScript의 현주소"></a>TypeScript의 현주소</h2><p>이젠 개발자들에게 없어서는 안 될 존재인 <code>Github</code>의 <a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="external">star</a>를 보니 <code>21,076개</code>입니다! (star개수가 64,556개인 React에 비하면 한참 멀었네요!) 올라온 Issue는 2,351개고 진행중인 Pull Request는 82개가 되네요.<br><img src="/images/github_typescript.png" alt=""><br>다음 자료는 Github과 마찬가지로 개발자들에게 없어선 안 되는 <a href="http://stackoverflow.com/insights/survey/2017/#most-loved-dreaded-and-wanted" target="_blank" rel="external">Stackoverflow의 조사 자료</a>입니다. 개발자들이 가장 사랑하는 언어로 Rust, Smalltalk에 이어 TypeScript가 3위를 당당히 차지했습니다.(오, 이 정도인가요?)<br><img src="/images/stackoverflow_survey.png" alt=""></p>
<p>추가된 Type System을 바탕으로 여러 가지 Tool과 구문 완성(content assist) 등의 도움을 받을 수 있는 TypeScript 소개였습니다. 얼마 전 공개된 <a href="https://github.com/Microsoft/reactxp" target="_blank" rel="external">ReactXP</a>를 만든 Microsoft의 지지로 React에서도 TypeScript 방향으로 가지 않을까 생각해봅니다.(Flow 의문의 1패?) 무엇을 공부해야 하나 걱정할 필요없는 프론트엔드 개발자분들을 응원합니다. 감사합니다 :)</p>
<p><em>cf. 짤막하게 정리해본 <a href="https://jaeyeophan.github.io/2017/04/19/TS-0-Quick-Start/">TypeScript Quick Start</a>입니다.</em></p>
<h3 id="TypeScript와-관련된-글과-그룹"><a href="#TypeScript와-관련된-글과-그룹" class="headerlink" title="TypeScript와 관련된 글과 그룹"></a>TypeScript와 관련된 글과 그룹</h3><ul>
<li><a href="https://github.com/Microsoft/TypeScript-Handbook" target="_blank" rel="external">Microsoft/TypeScript-Handbook</a></li>
<li><a href="https://www.facebook.com/groups/TSKorea/?hc_ref=SEARCH" target="_blank" rel="external">TypeScript Korea 페이스북 그룹</a></li>
<li><a href="http://han41858.tistory.com/14" target="_blank" rel="external">TypeScript를 무서워하지 않아도 되는 이유(번역)</a></li>
<li><a href="https://hyunseob.github.io/2016/09/25/typescript-introduction/index.html" target="_blank" rel="external">TypeScript 소개(hyunseob님 블로그)</a></li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/04/19/TypeScript-Recent/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/04/19/TypeScript-Recent/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a class="btn btn--default btn--small" href="/archives/2017/04/">
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/2017/04/page/3/">
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 2 of 3</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Jbee. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Jbee</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->



    </body>
</html>


<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Devlog">
    <title>Archives - Devlog</title>
    <meta name="author" content="Jbee">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/feed.xml">
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="blog posted about front end development">
<meta property="og:type" content="blog">
<meta property="og:title" content="Devlog">
<meta property="og:url" content="https://jaeyeophan.github.io/archives/index.html">
<meta property="og:site_name" content="Devlog">
<meta property="og:description" content="blog posted about front end development">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Devlog">
<meta name="twitter:description" content="blog posted about front end development">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Devlog</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Search"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/" target="_blank" rel="noopener" title="Google +">
                    
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/profile/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/mailto"
                            title="Mail"
                        >
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/06/16/TS-8-enum-vs-const-enum/">
                            [TS] 8. enum vs const enum
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-06-16T15:02:44+09:00">
	
		    Jun 16, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-8-enum-vs-const-enum"><a href="#TS-8-enum-vs-const-enum" class="headerlink" title="[TS] 8. enum vs const enum"></a>[TS] 8. enum vs const enum</h1><p>TypeScript 문법 중 <code>enum</code> 이라는 것이 있다. 주로 상수를 선언할 때 namespace 를 줘서 상수끼리의 응집도를 높이고 그 의미를 더할 수 있으며 VSCode 의 auto complete 의 지원을 받을 때 유용하다. 이 <code>enum</code> 키워드를 사용하는 방법에는 두 가지가 존재한다. 그냥 <code>enum</code> 키워드를 사용해 선언할 수 있으며 <code>const</code> 키워드와 함께 사용하여 <code>const enum</code>으로 선언할 수 있다.</p>
<p>이 두 가지는 무엇이 다를까.</p>
<p><a href="http://www.typescriptlang.org/play/" target="_blank" rel="external">TypeScript Playground</a>에 가서 JavaScript 로 compile 된 모습을 먼저 살펴보자.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> JustEnumNumber &#123;</div><div class="line">  zero,</div><div class="line">  one</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(JustNumber.one); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>간단한 <code>enum</code> 을 선언했다. 이 <code>JustEnumNumber</code>는 다음과 같이 transpile 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> JustEnumNumber;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">JustEnumNumber</span>) </span>&#123;</div><div class="line">  JustEnumNumber[(JustEnumNumber[<span class="string">"zero"</span>] = <span class="number">0</span>)] = <span class="string">"zero"</span>;</div><div class="line">  JustEnumNumber[(JustEnumNumber[<span class="string">"one"</span>] = <span class="number">1</span>)] = <span class="string">"one"</span>;</div><div class="line">&#125;)(JustEnumNumber || (JustEnumNumber = &#123;&#125;));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(JustNumber.one); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p><code>enum</code>에 대해 알아본 적이 있다면 익숙한 JavaScript 형태로 transpile 되는 것을 확인할 수 있다. 사실 저 코드는 조금 복잡해보여도 다음과 같은 코드이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> JustEnumNumber;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">JustEnumNumber</span>) </span>&#123;</div><div class="line">  JustEnumNumber[<span class="string">"zero"</span>] = <span class="number">0</span>;</div><div class="line">  JustEnumNumber[<span class="string">"one"</span>] = <span class="number">1</span>;</div><div class="line">  JustEnumNumber[<span class="number">0</span>] = <span class="string">"zero"</span>;</div><div class="line">  JustEnumNumber[<span class="number">1</span>] = <span class="string">"one"</span>;</div><div class="line">&#125;)(JustEnumNumber || (JustEnumNumber = &#123;&#125;));</div></pre></td></tr></table></figure>
<p>이젠 <code>const enum</code>을 보자.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">enum</span> ConstEnumNumber &#123;</div><div class="line">  zero,</div><div class="line">  one</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ConstEnumNumber.one); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>아까와 같은 간단한 <code>enum</code>을 선언했고 플레이그라운드에서 JavaScript 도 transpile 을 해보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="comment">/* one */</span>); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p><code>enum</code> 구현체는 다 사라지고 console 을 위한 코드만 남아있다. <code>const</code> 키워드를 사용하고 안 하고의 차이가 좀 큰 것 같다.</p>
<p>다시 <code>`JustEnumNumber</code>코드를 보자.<code>enum</code>만으로 선언할 경우, namespace 를 위한 변수가 선언이 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> JustEnumNumber;</div></pre></td></tr></table></figure>
<p>그리고 선언된 변수를 객체로 우리가 원하는 상수값들을 선언하게 된다. 이 때 선언된 변수는 transpile 되어서도 남아있게 되어 우리는 <code>enum</code>으로 선언한 객체 자체에 접근할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(JustEnumNumber); <span class="comment">// [object object]</span></div></pre></td></tr></table></figure>
<p>하지만 <code>const enum</code>으로 enum 을 선언하게 되면 compile 단계에서 namespace 가 날라가게 되므로 접근할 수 없다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(ConstEnumNumber); <span class="comment">// [ERROR] 'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query.</span></div></pre></td></tr></table></figure>
<p>내부 상수값들이 전부 compile 단계에서 대치된 것이다. 내부 필드를 전부 상수로 변경하기 때문에 런타임에 의존 모듈의 영향을 받지 않게 되며, 코드 크기가 더 적기 때문에 더 선호된다고 한다.</p>
<p>사실 이 부분은 TypeScript Official Document 에 다음과 같이 나와있다.</p>
<blockquote>
<p>To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use <code>const</code> enums.</p>
</blockquote>
<p>그렇다면 <code>enum</code>만으로 선언하는 경우는 언제일까.</p>
<p>우선 namespace 가 남아있으니 우리는 enum 을 이렇게도 사용할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(JustEnumNumber[JustEnumNumber.one]); <span class="comment">// one</span></div></pre></td></tr></table></figure>
<p>상수만으로 로그가 찍히면 알아보기 힘드니 reverse 참조를 하여 로그를 찍을 수 있다. lookup object 로 사용하는 것이다. 하지만 이렇게 선언된 enum 은 런타임에 이 lookup object 를 통해 참조가 이루어지므로 조심해야 한다. 물론 webpack 환경에서는</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이렇게 scope 를 쳐주지만 test 환경에서는 browser 객체(ex. window…)를 참조하는 경우 에러가 발생할 수 있다.</p>
<p>참고한 블로그의 문장을 인용하여 해당 글을 마친다.</p>
<blockquote>
<p><code>const enum</code> is a <strong>compile-time only</strong> feature, while the original <code>enum</code> is a <strong>runtime + compile-time</strong>feature. Most projects will be well suited for <code>const enum</code>, but there may be cases where <code>enum</code> is preferred.</p>
</blockquote>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="external">https://www.typescriptlang.org/docs/handbook/enums.html</a></li>
<li><a href="https://www.sitepoint.com/10-essential-typescript-tips-tricks-angular/?WT.mc_id=link-twitter-jeliknes" target="_blank" rel="external">https://www.sitepoint.com/10-essential-typescript-tips-tricks-angular/?WT.mc_id=link-twitter-jeliknes</a></li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/06/16/TS-8-enum-vs-const-enum/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2018/06/16/TS-8-enum-vs-const-enum/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/01/10/TS-7-TypeScript-type-system/">
                            [TS] 7. TypeScript type system
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-10T13:31:30+09:00">
	
		    Jan 10, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-7-Typescript’s-Type-System"><a href="#TS-7-Typescript’s-Type-System" class="headerlink" title="[TS] 7. Typescript’s Type System"></a>[TS] 7. Typescript’s Type System</h1><h3 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h3><ul>
<li>TypeScript의 Type Checking System</li>
<li>Type Inference</li>
<li>Type Assertion</li>
<li>Type Guards</li>
<li>Type Compatibility</li>
</ul>
<p><br></p>
<h2 id="TypeScript의-Typing-Checking-System"><a href="#TypeScript의-Typing-Checking-System" class="headerlink" title="TypeScript의 Typing Checking System"></a>TypeScript의 Typing Checking System</h2><p><code>TypeScript</code>에서의 Type System에 대한 이해를 하기 전, 기존 프로그래밍 언어의 큰 두 축인 정적 언어와 동적 언어에 대한 정의를 다시 한 번 살펴볼 필요가 있습니다.</p>
<h3 id="정적언어-Static-Language"><a href="#정적언어-Static-Language" class="headerlink" title="정적언어 (Static Language)"></a>정적언어 (Static Language)</h3><ul>
<li>변수(variables) 또는 함수(function)의 <code>Type</code>을 <strong>미리</strong> 지정해야 한다.</li>
<li>컴파일되는 시점에 Type Check를 수행한다.</li>
</ul>
<h3 id="동적-언어-Dynamic-Language"><a href="#동적-언어-Dynamic-Language" class="headerlink" title="동적 언어 (Dynamic Language)"></a>동적 언어 (Dynamic Language)</h3><ul>
<li>변수(variables) 또는 함수(function)의 <code>Type</code>을 지정하지 않는다.</li>
<li>Type Check는 런타임(runtime) 환경에서나 알 수 있다.</li>
</ul>
<h3 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h3><p>덕 타이핑(Duck Typing)이라고 많이 들어보셨을 텐데요, 현재 이 덕 타이핑 체계를 기반으로 동적 언어에 타입을 추론하는 언어는 GoLang과 Python 등이 있습니다. 하지만 TypeScript는 이 덕타이핑과는 조금 다른 체계로 <strong>Typing</strong>을 하고 있습니다.</p>
<blockquote>
<p>덕 타이핑에 대한 보다 자세한 내용은 <a href="https://www.google.co.kr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwjj5dzEl8PYAhXCNJQKHfG9DdYQFggxMAE&amp;url=http%3A%2F%2Fwww.popit.kr%2Fgolang%25EC%259C%25BC%25EB%25A1%259C-%25EB%25A7%258C%25EB%2582%2598%25EB%25B3%25B4%25EB%258A%2594-duck-typing%2F&amp;usg=AOvVaw1dXNKFpMsVofdtJ-QOglzu" target="_blank" rel="external">여기</a>를 참고해주세요.</p>
</blockquote>
<h3 id="Structural-typing"><a href="#Structural-typing" class="headerlink" title="Structural typing"></a>Structural typing</h3><p>TypeScript는 <strong>Structural typing</strong> (구조적 타이핑)을 기반으로 타입 시스템을 갖추고 있습니다. 구조적 타이핑이란, <code>멤버</code>에 따라 타입을 <strong>연관짓는</strong> 방법을 말합니다. 구조적 타이핑과 반대인 방법으로 <code>nominal typing</code>이 있습니다. 우리가 알고 있는 일반적인 정적 언어인 C#, Java는 이 <code>nominal typing</code> 방식으로 <strong>type checking</strong>이 이루어집니다.</p>
<p><em>Official Document</em>에 나온 예제를 통해 설명드립니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Named &#123;</div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Person &#123;  </div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p: Named;</div><div class="line">p = <span class="keyword">new</span> Person(); <span class="comment">// Ok, because of structural typing</span></div></pre></td></tr></table></figure></p>
<p>위 코드를 C# 또는 Java의 문법에 맞게 변경한다면 동작하지 않는 잘못된 코드가 됩니다. 하지만 TypeScript에서는 정상적으로 동작합니다. <code>Named</code>와 <code>Person</code> 두 가지는 오로지 <code>name</code>이라는 프로퍼티(or 멤버)만 갖고 있는 타입이므로 서로 <code>compatibility</code> 하다고 볼 수 있습니다. 때문에 위 코드는 문제되지 않습니다. (compatibility에 대해서는 뒤에서 알아봅니다.)</p>
<p><br></p>
<h2 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h2><p>‘누가봐도 이 변수는 이 타입이다.’라는 것에 대해 TypeScript가 지원해주는 것을 <strong>타입 추론</strong> 이라고 합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">`jbee`</span>;</div></pre></td></tr></table></figure></p>
<p><code>name</code>이라는 변수는 <code>string</code> 타입의 변수가 됩니다. 그렇기 때문에 굳이 <code>: string</code>이라고 타입을 지정해주지 않아도 다음과 같이 에러가 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name = <span class="number">1</span>; <span class="comment">// Error: Type '1' is not assignable to type 'string'.</span></div></pre></td></tr></table></figure></p>
<p>그렇다면 다음과 같은 경우에는 어떻게 추론될까요?<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mixedArr = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">`jbee`</span>];</div></pre></td></tr></table></figure></p>
<p><code>number</code>에 해당되는 value와 <code>string</code>에 해당하는 value가 공존하기 때문에 위 코드에서 <code>mixedArr</code>은 <code>(number | string)[]</code>의 타입을 갖게 됩니다. 이렇게 여러 타입이 공존하는 경우에 추론하여 지정되는 타입을 <strong>Best common type</strong>이라고 합니다.</p>
<p><br></p>
<h2 id="Type-Assertion"><a href="#Type-Assertion" class="headerlink" title="Type Assertion"></a>Type Assertion</h2><p>이 변수의 타입은 분명 <code>A</code>인데 TypeScript에서 보수적으로 처리하여 에러를 발생시키는 경우가 있습니다. 이럴 경우 해당 변수를 <code>A</code>라고 명시하여 에러를 사라지게 할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">type</span> Todo = &#123;</div><div class="line">  id: <span class="built_in">number</span>;</div><div class="line">  text: <span class="built_in">string</span>;</div><div class="line">  completed: <span class="built_in">boolean</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">type</span> Todos = Todo[];</div></pre></td></tr></table></figure></p>
<p>위와 같이 <code>Todo</code> 타입과 <code>Todos</code> 타입을 지정한 상황이라고 했을 때를 예로 들어보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState: Todos = [</div><div class="line">  &#123;</div><div class="line">    id: <span class="number">0</span>,</div><div class="line">    text: <span class="string">'Study RxJS'</span>,</div><div class="line">    completed: <span class="literal">false</span>,</div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>위 코드에서 <code>Todos</code>에 해당하는 타입을 제대로 지정해줬지만 뭔가 아쉬움이 남을 수 있는데요, 이 때 두 가지 방법을 사용할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState: Todos = [</div><div class="line">  &lt;TODO&gt;&#123;</div><div class="line">    id: <span class="number">0</span>,</div><div class="line">    text: <span class="string">'Study RxJS'</span>,</div><div class="line">    completed: <span class="literal">false</span>,</div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>위 코드처럼 <code>&lt;&gt;</code>을 사용하거나<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState: Todos = [</div><div class="line">  &#123;</div><div class="line">    id: <span class="number">0</span>,</div><div class="line">    text: <span class="string">'Study RxJS'</span>,</div><div class="line">    completed: <span class="literal">false</span>,</div><div class="line">  &#125; <span class="keyword">as</span> Todo</div><div class="line">];</div></pre></td></tr></table></figure></p>
<p>위 코드처럼 <code>as</code> 키워드를 사용할 수 있습니다. 두 가지 모두 동일하지만 <code>tsx</code>와 함께 사용하기 위해서는 <code>as</code> 키워드를 사용하는 것이 좋습니다.</p>
<blockquote>
<p>[!] 이 Type Assertion은 Type Casting과는 다릅니다. 자세한 내용은 <a href="https://hyunseob.github.io/2017/12/12/typescript-type-inteference-and-type-assertion/" target="_blank" rel="external">DailyEngineering - 타입 추론과 타입 단언</a>을 참고해주세요!</p>
</blockquote>
<p><br></p>
<h2 id="Type-Guards"><a href="#Type-Guards" class="headerlink" title="Type Guards"></a>Type Guards</h2><p>자바스크립트에서는 <code>typeof</code> 또는 <code>instanceof</code>와 같은 오퍼레이터가 타입을 확인해주는 역할을 했었습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.state[key] !== <span class="keyword">typeof</span> newData) &#123;</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>하지만 이 방법은 런타임에서 타입 체크를 수행하게 됩니다. 따라서 컴파일 시점에서는 올바른 타입인지 알 수 없습니다. TypeScript에서는 컴파일 시점에서 타입 체크를 수행할 수 있도록 <code>Type Guard</code>를 지원합니다.</p>
<p><br></p>
<h3 id="typeof-instanceof"><a href="#typeof-instanceof" class="headerlink" title="typeof, instanceof"></a><code>typeof</code>, <code>instanceof</code></h3><p>TypeScript에서도 마찬가지로 <code>typeof</code>와 <code>instanceof</code> 오퍼레이터를 지원합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setNumberOrString</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x.subtr(<span class="number">1</span>)); <span class="comment">// Error</span></div><div class="line">    <span class="built_in">console</span>.log(x.substr(<span class="number">1</span>)); <span class="comment">// OK</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(typof x); <span class="comment">// number</span></div><div class="line">  &#125;</div><div class="line">  x.substr(<span class="number">1</span>); <span class="comment">// Error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위 코드에서 <code>if-block</code>내에서의 <code>x</code>변수의 타입은 <code>string</code>일 수 밖에 없다는 것을 컴파일 시점에 체크하여 transpiler가 Error를 발생시키는 경우입니다. 이 예제와 비슷한 방법으로 <code>instanceof</code> 오퍼레이터를 사용할 수 있습니다. <code>instanceof</code>는 클래스를 기반으로 생성된 인스턴스의 타입을 판단하는데 사용됩니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Pet &#123;</div><div class="line">  name = <span class="number">123</span>;</div><div class="line">  common = <span class="string">'123'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Basket &#123;</div><div class="line">  size = <span class="number">123</span>;</div><div class="line">  common = <span class="string">'123'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">arg: Pet | Basket</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Pet) &#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.name); <span class="comment">// OK</span></div><div class="line">    <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error!</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Basket) &#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.name); <span class="comment">// Error!</span></div><div class="line">    <span class="built_in">console</span>.log(arg.size); <span class="comment">// OK</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(arg.common); <span class="comment">// OK</span></div><div class="line">  <span class="built_in">console</span>.log(arg.name); <span class="comment">// Error!</span></div><div class="line">  <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error!</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>typeof</code>와 마찬가지로 <code>instanceof</code>로 필터링 된 block 내부에서 <strong>Type checking</strong>이 이루어집니다.</p>
<p><br></p>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> A &#123;</div><div class="line">  x: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> B &#123;</div><div class="line">  y: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">q: A | B</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="string">'x'</span> <span class="keyword">in</span> q) &#123;</div><div class="line">    <span class="comment">// q: A</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// q: B</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>A</code> 또는 <code>B</code>를 유니온 타입으로 받을 수 있는 <code>execute</code> 함수 내에서 각각에 대해 다른 처리를 할 경우, <code>in</code>이라는 오퍼레이터를 사용할 수 있습니다. 해당 오퍼레이터는 check하고자 하는 타입에 해당 프로퍼티가 존재하는지의 유무를 판단할 수 있습니다.</p>
<p><br></p>
<h3 id="kind-Literal-Type-Guard"><a href="#kind-Literal-Type-Guard" class="headerlink" title=".kind Literal Type Guard"></a><code>.kind</code> Literal Type Guard</h3><p>사용자에 의해 <code>type</code>으로 정의된 타입에 대해서, 즉 TypeScript 내부에서 지원하는 primitive type이 아닌 <strong>사용자 정의 타입에 대해서 타입 검사를 수행할 때</strong>, <code>.kind</code>를 사용할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Foo = &#123;</div><div class="line">  kind: <span class="string">'foo'</span>, <span class="comment">// Literal type </span></div><div class="line">  foo: <span class="built_in">number</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> Bar = &#123;</div><div class="line">  kind: <span class="string">'bar'</span>, <span class="comment">// Literal type </span></div><div class="line">  bar: <span class="built_in">number</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">arg: Foo | Bar</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arg.kind === <span class="string">'foo'</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.foo); <span class="comment">// OK</span></div><div class="line">    <span class="built_in">console</span>.log(arg.bar); <span class="comment">// Error!</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위 코드에서 처럼 <code>type</code> 키워드를 사용하여 별도 타입을 지정할 때, <code>kind</code>라는 프로퍼티를 추가하여 타입 검사를 수행할 수 있습니다.</p>
<p><br></p>
<h3 id="User-Defined-Type-Guards"><a href="#User-Defined-Type-Guards" class="headerlink" title="User Defined Type Guards"></a>User Defined Type Guards</h3><p>메소드를 별도로 분리하여 Type Guard를 지정할 수 있습니다. 아까 지정한 interface A로 만들어보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> A &#123;</div><div class="line">  x: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Define Type Guard</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isA</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">arg</span> <span class="title">is</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> arg.x !== <span class="literal">undefined</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>arg is A</code>라는 타입으로 <code>isA</code> 메소드가 Type Guard의 역할을 수행한다는 것을 명시할 수 있습니다. if 내부에 들어가는 로직을 별도로 추출하여 보다 가독서이 좋은 코드를 작성할 수 있습니다.</p>
<p><br></p>
<h2 id="Type-Compatibility"><a href="#Type-Compatibility" class="headerlink" title="Type Compatibility"></a>Type Compatibility</h2><p>한국어로 번역하게 되면 <strong>타입 호환성</strong> 정도로 할 수 있겠는데요, TypeScript는 위에서 언급했듯이 <strong>Structural subtyping</strong>을 기반으로 Type checking을 하기 때문에 이를 기반으로 타입 간의 호환성을 고려할 수 있습니다.</p>
<h4 id="1-Comparing-two-Objects"><a href="#1-Comparing-two-Objects" class="headerlink" title="1. Comparing two Objects"></a>1. Comparing two Objects</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = &#123;name: <span class="string">`Jbee`</span>&#125;;</div><div class="line"><span class="keyword">let</span> y = &#123;name: <span class="string">`James`</span>, age: <span class="number">34</span>&#125;;</div><div class="line"></div><div class="line">x = y; <span class="comment">// OK!</span></div><div class="line">y = x; <span class="comment">// Error!</span></div></pre></td></tr></table></figure>
<p>위 코드에서 <code>x</code>는 <code>{name: string}</code> 타입으로 추론되며, <code>y</code>는 <code>{name: string, age: number}</code>로 추론됩니다. 이 경우 <code>x = y</code>는 <code>y</code>에 <code>name</code>이라는 속성이 있으므로 가능하지만 <code>y = x</code>의 경우, <code>x</code>에는 <code>age</code>라는 속성이 없으므로 에러가 발생합니다.</p>
<h4 id="2-Comparing-two-functions"><a href="#2-Comparing-two-functions" class="headerlink" title="2. Comparing two functions"></a>2. Comparing two functions</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">y = x; <span class="comment">// OK</span></div><div class="line">x = y; <span class="comment">// Error</span></div></pre></td></tr></table></figure>
<p>함수일 경우에는 객체인 경우와 조금 다른 것을 볼 수 있습니다. 위 코드에서 두 <code>x</code>, <code>y</code>함수는 parameter 만 다르게 정의되어 있습니다. 이 경우, <code>x</code> 함수에 전달할 수 있는 parameter의 경우의 수가 y에 모두 해당하므로 <code>y = x</code>가 정상적으로 동작합니다. 하지만 그 반대인 <code>x = y</code>는 <code>y</code> 함수에 전달할 수 있는 parameter를 <code>x</code>가 모두 포용할 수 없으므로 에러가 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">`Jbee`</span>&#125;);</div><div class="line"><span class="keyword">let</span> y = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">`James`</span>, age: <span class="number">34</span>&#125;);</div><div class="line"></div><div class="line">x = y; <span class="comment">// OK!</span></div><div class="line">y = x; <span class="comment">// Error!</span></div></pre></td></tr></table></figure></p>
<p>이번에는 return value의 type이 다른 경우입니다. 이 경우에는 함수의 경우를 따르지 않고 객체인 경우를 따르게 됩니다.</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>TypeScript의 단순한 문법을 조금 넘어서 어떻게 Type Checking이 이루어지는지 살펴봤습니다.<br>감사합니다.</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/type-inference.html" target="_blank" rel="external">TypeScript Official Document - Type Inference</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="external">TypeScript Official Document - Type Compatibility</a></li>
<li><a href="http://www.popit.kr/golang%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%82%98%EB%B3%B4%EB%8A%94-duck-typing/" target="_blank" rel="external">Golang으로 만나보는 duck typing</a></li>
<li><a href="https://medium.com/@thejameskyle/type-systems-structural-vs-nominal-typing-explained-56511dd969f4" target="_blank" rel="external">Type Systems: Structural vs Nominal typing explained</a></li>
<li><a href="https://basarat.gitbooks.io/typescript/docs/types/typeGuard.html" target="_blank" rel="external">TypeScript Deep dive - Type Guard</a></li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/01/10/TS-7-TypeScript-type-system/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2018/01/10/TS-7-TypeScript-type-system/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/01/09/TS-6-Decorator/">
                            [TS] 6. Decorator
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-09T09:59:14+09:00">
	
		    Jan 09, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-6-Decorators"><a href="#TS-6-Decorators" class="headerlink" title="[TS] 6. Decorators"></a>[TS] 6. Decorators</h1><p>이번 포스팅에서는 현재 JavaScript에서도 <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="external">ts39/proposal stage-2</a>에 올라와있는 <code>Decorator</code>에 대해 알아보겠습니다.</p>
<h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul>
<li>Setup</li>
<li>Intro</li>
<li>Decorator to method</li>
<li>Decorator to class</li>
<li>Decorator with parameter</li>
</ul>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>자바스크립트 babel환경에서 데코레이터를 테스트해보기 위해서는 babel 플러그인이 추가적으로 필요합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install babel-core babel-plugin-transform-decorators-legacy --save-dev</div></pre></td></tr></table></figure></p>
<p><code>babel-core</code>를 기본으로 하며, babel-plugin을 추가적으로 설치해줍니다.<br><figure class="highlight"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  //...</div><div class="line">  "plugins": ["transform-decorators-legacy"]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>해당 프로젝트의 babel설정을 담고 있는 <code>.babelrc</code>파일에 설치한 플러그인을 추가해줍니다. 보다 구체적인 해당 개발환경은 <a href="https://github.com/JaeYeopHan/esnext_labs" target="_blank" rel="external">여기</a>를 참고해주세요.</p>
<p>TyeScript에서는 <code>tsconfig.json</code>의 <code>compilerOption</code>을 다음과 같이 변경해줍니다.<br><figure class="highlight json"><figcaption><span>tsconfig.json</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"compilerOptions"</span>: &#123;</div><div class="line">        <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</div><div class="line">        <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>TypeScript(JavaScript)에서 <code>@</code>이라는 character로 사용하는 문법을 <code>Decorator(데코레이터)</code>라고 합니다. 자바를 경험해보신 분이라면 <code>Annotation</code>인가? 라고 생각하기 쉬운데요, 조금 다릅니다. 데코레이터는 <strong>함수</strong> 라고 할 수 있습니다. 데코레이터는 말 그대로 코드 조각을 장식해주는 역할을 하며 타입스크립트에서는 그 기능을 함수로 구현할 수 있습니다.</p>
<p>Decorator는 클래스 선언, 메서드, 접근 제어자, 속성 또는 매개 변수에 첨부 할 수 있는 특별한 종류의 선언입니다. 데코레이터는 <code>@expression</code> 형식을 사용하는데, expression은 데코레이팅 된 선언에 대한 정보와 함께 존재하며 이는 <strong>런타임에</strong> 호출됩니다.</p>
<h4 id="참조-reference"><a href="#참조-reference" class="headerlink" title="참조(reference)"></a>참조(reference)</h4><p>데코레이터는 <code>@decorator</code>과 같이 사용할 수 있으며 <code>@[name]</code>의 형식일 때 <code>name</code>에 해당하는 이름의 함수를 참조하게 됩니다.</p>
<h4 id="실행-시점-execute-time"><a href="#실행-시점-execute-time" class="headerlink" title="실행 시점(execute time)"></a>실행 시점(execute time)</h4><p>이렇게 데코레이터로 정의된 함수는 데코레이터가 적용된 메소드가 실행되거나 클래스가 <code>new</code>라는 키워드를 통해 인스턴스화 될 때가 아닌 런타임 때 실행됩니다. 즉, 매번 실행되지 않습니다.</p>
<p><em>그럼 데코레이터가 메소드에 적용되는 경우, 클래스에 적용되는 경우, 프로퍼티에 적용되는 경우 이렇게 세 가지로 나누어 코드를 살펴보겠습니다.</em></p>
<p><br></p>
<h2 id="Decorator-to-Method"><a href="#Decorator-to-Method" class="headerlink" title="Decorator to Method"></a>Decorator to Method</h2><blockquote>
<p>메소드에 적용되는 경우</p>
</blockquote>
<p>우선 데코레이터로 사용할 <code>chaining</code>이라는 함수를 정의해줍니다.<br><figure class="highlight ts"><figcaption><span>decorator.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">chaining</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>): <span class="title">any</span> </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(target); <span class="comment">// &#123;bark: f, constructor: f&#125;</span></div><div class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// bark</span></div><div class="line">  <span class="built_in">console</span>.log(descriptor); <span class="comment">// &#123;value: f, writable: true, enumerable: true, configurable: true&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위 함수는 추후 메소드에 <code>@chaining</code> 형식으로 사용될 함수입니다. <code>@</code>과 함께 함수가 호출되는 경우 받게 되는 파라미터는 다음과 같습니다.</p>
<blockquote>
<ul>
<li>target : 속성을 정의하고자 하는 객체</li>
<li>name : 속성의 이름</li>
<li>descriptor : 새로 정의하고자 하는 속성에 대한 설명</li>
</ul>
</blockquote>
<p>이는 <code>Object.defineProperty()</code>를 통해 이를 정의하고 있기 때문입니다.</p>
<p><code>target</code>은 해당 메소드가 속해있는 클래스 프로토타입을 가리키게 되며 <code>Pet</code>의 프로토타입에는 <code>constructor</code>와 <code>bark</code>메소드가 있는 것을 확인할 수 있습니다. <code>name</code>은 데코레이터가 적용된 메소드의 이름이 됩니다. <code>descriptor</code>는 <code>defineProperty</code>에서 정의할 수 있는 각각의 속성값들이 됩니다.</p>
<p>Object의 <code>defineProperty</code>에 해당하는 보다 자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">여기</a>에서 살펴보실 수 있습니다. 그럼 각각을 활용해서 <code>chaining</code> 기능을 구현해보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Decorator to method</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">chaining</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>): <span class="title">any</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> fn: <span class="built_in">Function</span> = descriptor.value;</div><div class="line"></div><div class="line">  descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</div><div class="line">    fn.apply(target, args);</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>descriptor의 <code>value</code>가 데코레이터가 적용된 함수, 즉 실행 대상이라고 할 수 있습니다. <code>descriptor.value</code>를 재정의(override)하기 전에 <code>fn</code>이라는 변수로 caching해둔 다음, 호출한 후의 일을 정의하기 위해 위와 같이 재정의 해줍니다. 재정의 하기 전 caching 해둔 함수를 호출하기 위해서 <code>apply</code> 함수를 사용했습니다. 어떠한 변수가 얼만큼 전달될지 모르니 rest parameter를 통해 <code>fn</code>을 호출해주는 코드입니다.</p>
<p>위와 같이 <code>descriptor.value</code>가 재정의 되면 <code>chaining</code>이 적용된 메소드는 재정의된대로 호출되게 됩니다.</p>
<blockquote>
<p><code>apply</code> 함수에 대한 내용은 <a href="https://www.google.co.kr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwj9wKqt1cDYAhUBtpQKHQNvC34QFggmMAA&amp;url=https%3A%2F%2Fdeveloper.mozilla.org%2Fko%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fapply&amp;usg=AOvVaw2tqAzWzgnT49rXId1wsV11" target="_blank" rel="external">여기</a>를 참고해주세요.</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Pet &#123;</div><div class="line">  <span class="meta">@chaining</span></div><div class="line">  bark() &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위와 같이 적용해보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Pet();</div></pre></td></tr></table></figure></p>
<p><code>Pet</code>클래스에서 <code>bark</code>라는 메소드는 <code>Pet.prototype.bark</code>로 됩니다. class syntax 내부에서 위 코드에서는 <code>bark</code>라는 메소드가 <code>Pet</code>의 prototype의 프로퍼티로 추가되기 전에 <code>decorate</code> 함수가 실행되어 본래 <code>bark</code>라는 메소드에서 정의된 것에 추가적인 <strong>‘장식’</strong> 을 더해 prototype에 추가되도록 합니다.</p>
<blockquote>
<p>만약 compile target이 ES5보다 낮다면 <code>PropertyDescriptor</code> 값으로 <code>undefined</code>이 전달됩니다.</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pet.bark().bark();</div></pre></td></tr></table></figure>
<p>위 데코레이터의 효과로 <code>return this;</code>를 해주지 않아도 chaining 기능을 사용하여 메소드를 호출할 수 있습니다.</p>
<p><br></p>
<h2 id="Decorator-to-Class"><a href="#Decorator-to-Class" class="headerlink" title="Decorator to Class"></a>Decorator to Class</h2><p>하지만 데코레이터가 class에 적용되었을 때는 그 signature가 조금 달라집니다. 클래스 데코레이터는 클래스 선언 바로 전에 선언됩니다. 클래스 데코레이터는 클래스 생성자에 적용되며 클래스 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다.</p>
<p>클래스 데코레이터가 값을 반환하면 클래스 선언을 제공된 생성자 함수로 바꿉니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(target); <span class="comment">// ...</span></div><div class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></div><div class="line">  <span class="built_in">console</span>.log(descriptor); <span class="comment">//undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>메소드에 데코레이터를 적용하듯이 데코레이터 함수를 선언하면 올바른 선언을 할 수 없습니다. 클래스에 적용되는 데코레이터 함수에 전달되는 인자는 <code>constructor</code>하나입니다. 제대로 된 데코레이터 선언은 다음과 같습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;<span class="keyword">new</span>(...args:<span class="built_in">any</span>[]):&#123;&#125;&#125;&gt;(<span class="keyword">constructor</span>:T) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> <span class="keyword">constructor</span> &#123;</div><div class="line">    newProperty = <span class="string">"new property"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>클래스에 적용되는 데코레이터 함수 내에서 새로운 생성자 함수를 반환하면 원래 프로토타입을 유지해야 합니다. 런타임에 데코레이터를 적용하는 로직은 이를 수행하지 않기 때문입니다. 위 코드에서는 기존의 프로토타입을 유지하기 위해 적용되는 클래스의 <code>constructor</code>를 <code>extends</code> 합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@classDecorator</span></div><div class="line"><span class="keyword">class</span> Pet &#123;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Pet(<span class="string">"async"</span>);</div><div class="line"><span class="built_in">console</span>.log(pet.newProperty); <span class="comment">// new Property</span></div></pre></td></tr></table></figure>
<p><code>classDecorator</code> 데코레이터가 적용된 <code>Pet</code> 클래스의 인스턴스에는 <code>newProperty</code>가 존재하지 않지만 데코레이터 함수에서 해당 클래스의 constructor를 재정의했기 대문에 <code>newProperty</code>에 접근할 수 있습니다.</p>
<p><br></p>
<h2 id="Decorator-with-parameter"><a href="#Decorator-with-parameter" class="headerlink" title="Decorator with parameter"></a>Decorator with parameter</h2><blockquote>
<p>파라미터를 받는 데코레이터</p>
</blockquote>
<p>데코레이터 함수에 인자를 넘겨줄 수 있습니다. 이 인자는 무엇이든 될 수 있습니다. 예제 코드로 descriptor의 <code>enumerable</code> 속성을 변경하는 데코레이터를 만들어보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerableToFalse</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">  descriptor.enumerable = <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이렇게 정의하면 <code>enumerableToFalse</code>이 적용된 메소드의 enumerable 속성은 false가 됩니다. 위 <code>enumerableToFalse</code> 함수를 한 번 감싸서 반환하는 함수를 만들면 다음과 같습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">    descriptor.enumerable = value;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 이 함수를 데코레이터 함수로 사용할 수 있습니다. <code>value</code>에 해당하는 값으로 데코레이터를 적용하는 메소드의 <code>enumerable</code>속성을 제어할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Pet &#123;</div><div class="line">  <span class="meta">@enumerable</span>(<span class="literal">false</span>)</div><div class="line">  bark() &#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위와 같이 <code>false</code>라는 인자를 받는 데코레이터를 정의했습니다. 저 인자에는 함수도 들어갈 수 있으며 데코레이터도 들어갈 수 있습니다.</p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>target을 ES5로 지정해야 제대로 된 데코레이터를 사용할 수 있어서 아직 한계가 있는 Decorator지만 React에서는 HOC(High-Order-Component)에 많이 사용하고 있는 Decorator 였습니다!</p>
<p>감사합니다.</p>
<p><em>6. Decorator in TypeScript end</em></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="external">TypeScript Official Document - Generics</a></li>
<li><a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="external">https://github.com/wycats/javascript-decorators</a></li>
<li><a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841" target="_blank" rel="external">https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841</a></li>
<li><a href="https://www.sitepoint.com/javascript-decorators-what-they-are/" target="_blank" rel="external">https://www.sitepoint.com/javascript-decorators-what-they-are/</a></li>
<li><a href="https://cabbageapps.com/fell-love-js-decorators/" target="_blank" rel="external">https://cabbageapps.com/fell-love-js-decorators/</a></li>
<li><a href="https://javarouka.github.io/blog/2016/09/30/decorator-exploring/#class-il-gyeongu" target="_blank" rel="external">https://javarouka.github.io/blog/2016/09/30/decorator-exploring/#class-il-gyeongu</a></li>
<li><a href="https://github.com/jayphelps/core-decorators" target="_blank" rel="external">https://github.com/jayphelps/core-decorators</a></li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/01/09/TS-6-Decorator/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2018/01/09/TS-6-Decorator/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/01/02/React-tips-for-beginners/">
                            [번역] React를 본격적으로 하기 전 알면 좋은 6가지
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-02T13:36:04+09:00">
	
		    Jan 02, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/react_special_1.png" alt=""></p>
<h1 id="I-wish-I-knew-these-before-diving-into-React"><a href="#I-wish-I-knew-these-before-diving-into-React" class="headerlink" title="I wish I knew these before diving into React"></a>I wish I knew these before diving into React</h1><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488" target="_blank" rel="external">https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488</a></em></p>
<h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul>
<li>By default, setState triggers a re-render</li>
<li>setState updates the local state asynchronously</li>
<li>Component Lifecycle is important!</li>
<li>Use componentWillReceiveProps</li>
<li>Use React Developer Tools</li>
<li>Use CRA(Create React App)</li>
</ul>
<p><br></p>
<h2 id="1-By-default-setState-triggers-a-re-render"><a href="#1-By-default-setState-triggers-a-re-render" class="headerlink" title="1. By default, setState triggers a re-render"></a>1. By default, setState triggers a re-render</h2><blockquote>
<p>기본적으로 <code>setState</code> 메소드는 해당 컴포넌트의 재렌더링(re-render)을 발생시킨다.</p>
</blockquote>
<p>리액트의 기본 동작은 애플리케이션을 구성하고 있는 컴포넌트에서 발생하는 모든 변경사항에 대해서 다시 렌더링 하는 것이고 대부분의 경우 이 이러한 기본 동작에 맡겨도 정상적으로 동작합니다. 하지만 불필요한 re-render는 컴포넌트의 라이프 사이클 압장에서 봤을 때, Best practice일 수 없습니다.</p>
<p>각각의 컴포넌트들은 <code>shouldComponentUpdate</code>라는 메소드를 가지고 있고 이것은 <code>state</code>가 변경되거나 부모 컴포넌트로부터 새로운 <code>props</code>를 전달받을 때 실행됩니다. React는 이 메소드(<code>shouldComponentUpdate</code>)의 반환 값에 따라서 re-render를 할지에 대한 여부를 결정하게 됩니다.</p>
<p>기본적으로 <code>shouldComponentUpdate</code> 메소드는 <code>true</code>를 반환합니다. 하지만 React 개발자는 re-render를 원하지 않는 경우에, 이 return value를 <code>false</code>로 오버라이드 할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">    <span class="keyword">const</span> vitalPropsChange = <span class="keyword">this</span>.props.bar !== nextProps.bar;</div><div class="line">    <span class="keyword">const</span> vitalStateChange = <span class="keyword">this</span>.state.foo !== nextState.foo;    </div><div class="line">    <span class="keyword">return</span> vitalPropsChange || vitalStateChange;</div><div class="line">&#125;</div><div class="line"><span class="comment">// React will not re-render the component unless vitalPropsChange</span></div><div class="line"><span class="comment">// or vitalStateChange is true.</span></div></pre></td></tr></table></figure>
<h3 id="important-notes"><a href="#important-notes" class="headerlink" title="important notes:"></a>important notes:</h3><ol>
<li><code>shouldComponentUpdate</code>를 잘못 설정하거나 이러한 설정을 잊어 버리면 구성 요소가 예상대로 업데이트되지 않아 애플리케이션에 문제가 발생할 수 있습니다.</li>
<li><code>shouldComponentUpdate</code>에서 계산을 실행하는 것은 성능과 노력면에서 비용이 많이들 수 있으므로 그만한 가치가 있는지 확인해야합니다. <a href="https://reactjs.org/docs/perf.html" target="_blank" rel="external">React ‘s Performance Tools</a>를 사용하여 <code>shouldComponentUpdate</code> 사용 전후에 낭비되는 사이클 수를 확인하는 것이 좋습니다. 아주 간단한 사용법이 있습니다.<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Perf.start() </div><div class="line"><span class="comment">// React operations in-between are recorded for analyses.</span></div><div class="line">Perf.stop()</div><div class="line">Perf.printWasted()</div></pre></td></tr></table></figure>
</li>
</ol>
<p><br></p>
<h2 id="2-setState-updates-the-local-state-asynchronously"><a href="#2-setState-updates-the-local-state-asynchronously" class="headerlink" title="2. setState updates the local state asynchronously"></a>2. setState updates the local state asynchronously</h2><blockquote>
<p><code>setState</code> 메소드는 <strong>비동기</strong>로 state를 업데이트 한다.</p>
</blockquote>
<p><code>setState</code>메소드는 즉시 실행되는, 동기적으로 실행되는 것이 아니라 하나의 <strong>요청</strong>이라고 생각해야 합니다. 즉, <code>setState</code>를 통해 상태를 변경하더라도 해당 메소드가 실행된 직후에 변경된 상태가 적용되는 것이 아닙니다.</p>
<p><code>setState</code>를 호출한 직후에 <code>this.state</code>에 접근하는 것은 흔한 실수 입니다. 일반적으로, <code>setState</code> 메소드 내에서 <code>this.state</code>를 사용하는 것은 신뢰할 수 없습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this.state.value is initially 0</span></div><div class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line"><span class="comment">// this.state.value is 1 instead of 3</span></div></pre></td></tr></table></figure></p>
<p>만약 이전의 상태에 기반하여 상태를 변경해야 한다면 가장 좋은 방법 중 하나는 <code>updater</code> 함수를 사용하는 것입니다. <code>updater</code>함수를 <code>setState</code> 메소드의 첫번째 인자로 넘기는 방식으로 사용할 수 있습니다. ( <code>setState(updater, [callback])</code> ) 예제 코드입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;<span class="attr">value</span>: prevState.value + <span class="number">1</span>&#125;));</div></pre></td></tr></table></figure></p>
<p>여기서 <code>[callback]</code>은 optional argument로 <code>setState</code>의 실행이 완료된 후 실행되며 해당 <code>callback</code>이 실행된 후에 해당 컴포넌트의 re-render가 이루어집니다. <code>updater</code>에 대한 보다 자세한 내용은 다음 <a href="https://reactjs.org/docs/react-component.html#setstate" target="_blank" rel="external">링크</a>를 참고하세요.</p>
<p><br></p>
<h2 id="3-Component-Lifecycle-is-important"><a href="#3-Component-Lifecycle-is-important" class="headerlink" title="3. Component Lifecycle is important!"></a>3. Component Lifecycle is important!</h2><blockquote>
<p>컴포넌트의 라이프 사이클이 중요하다!</p>
</blockquote>
<p>React를 이해하는데 있어서 가장 첫번째로 이해해야 하는 부분이 바로 <strong>Component life cycle</strong>입니다. 각각의 React 컴포넌트는 component의 life cycle 안에서 특정 시간에 호출할 수 있는 메소드들을 내장하고 있습니다. 이 컴포넌트 내장 메소드들을 올바르게 사용하기 위해서는 해당 메소드들이 실행되는 순서를 이해해야만 합니다. 이 라이프 사이클을 세 부분으로 나눌 수 있습니다.</p>
<h3 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h3><p>React 컴포넌트의 인스턴스가 생성되고 DOM에 삽입되는 과정의 life cycle 입니다.</p>
<ol>
<li>constructor</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ol>
<h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p><code>prop</code> 또는 <code>state</code>의 변경으로 해당 컴포넌트가 re-render 되는 경우의 life cycle 입니다.</p>
<h4 id="Props-Change"><a href="#Props-Change" class="headerlink" title="Props Change"></a>Props Change</h4><ol>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h4 id="State-Change"><a href="#State-Change" class="headerlink" title="State Change"></a>State Change</h4><ol>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h3 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h3><ul>
<li>componentWillUnmount</li>
</ul>
<h3 id="Life-Cycle과-관련된-좋은-Article"><a href="#Life-Cycle과-관련된-좋은-Article" class="headerlink" title="Life Cycle과 관련된 좋은 Article"></a>Life Cycle과 관련된 좋은 Article</h3><ul>
<li>React Lifecycle Methods - how and when to use them<ul>
<li><a href="https://jaeyeophan.github.io/2018/01/01/React-4-Component-Life-Cycle/">번역 링크</a></li>
<li><a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="external">원본 링크</a></li>
</ul>
</li>
<li><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="external">React Official Document</a></li>
</ul>
<p><br></p>
<h2 id="4-Use-componentWillReceiveProps"><a href="#4-Use-componentWillReceiveProps" class="headerlink" title="4. Use componentWillReceiveProps"></a>4. Use componentWillReceiveProps</h2><blockquote>
<p><code>componentWillReceiveProps</code> 메소드를 사용해라.</p>
</blockquote>
<p>만약 <code>props</code>의 변경에 따라서 상태를 변경해야 한다면, 이 <code>componentWillReceiveProps</code> 메소드가 필요합니다. <code>this.props</code>와 <code>nextProps</code>를 비교해서 중요한 변화(significant change)가 있다면 해당 메소드를 실행합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps(nextProps) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.foo !== nextProps.foo) &#123;</div><div class="line">    <span class="keyword">this</span>.whenFooChanges();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.porps.bar !== nextProps.bar) &#123;</div><div class="line">    <span class="keyword">this</span>.whenBarChanges();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Two-important-notes"><a href="#Two-important-notes" class="headerlink" title="Two important notes:"></a>Two important notes:</h3><ol>
<li><code>props</code>가 변경되지 않아도 <code>componentWillReceiveProps</code>는 실행하기 때문에 <code>this.props</code>와 <code>nextProps</code>를 비교하는 것이 중요합니다.</li>
<li><code>componentWillReceiveProps</code>은 해당 컴포넌트가 <strong>mounted</strong> 되기 전에 실행되어 새로운 <code>props</code>를 받습니다. 이것은 React가 mount 중에는 초기 props에 대해 <code>componentWillReceiveProps</code>를 호출하지 않는다는 것을 의미합니다.</li>
</ol>
<h3 id="추가-내용"><a href="#추가-내용" class="headerlink" title="추가 내용"></a>추가 내용</h3><p>React version 16에서 <code>componentWillReceiveProps</code>를 사용하여 상태를 변경할 때는 <strong>동기적으로</strong> 업데이트 해야 합니다.(dispatch request 또는 <code>setTimeout</code>과 같은 비동기적 요청은 해당 메소드에서 처리하면 안 됩니다.)<br><strong>React Fiber</strong> 를 사용하면 라이프 사이클이 진행되기 전에 <code>componentWill[*]</code> 메서드가 여러 번 호출 될 수 있습니다. <code>props</code>이 변경될 때 상태를 비동기적으로 업데이트하려면 <code>componentDidUpdate</code>를 사용해야 합니다.</p>
<p><br></p>
<h2 id="5-Use-React-Developer-Tools"><a href="#5-Use-React-Developer-Tools" class="headerlink" title="5. Use React Developer Tools"></a>5. Use React Developer Tools</h2><blockquote>
<p>각종 React 개발자 도구를 사용해라.</p>
</blockquote>
<p>React Developer Tools를 사용하면 애플리케이션을 구성하고 있는 React 컴포넌트의 계층, 컴포넌트의 <code>props</code> 및 <code>state</code>를 검사 할 수 있습니다. React는 모두 컴포넌트에 관한 것이기 때문에 많은 경우, 매우 유용합니다. 브라우저 확장 프로그램 (<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="external">Chrome용</a> 및 <a href="https://addons.mozilla.org/ko/firefox/addon/react-devtools/" target="_blank" rel="external">Firefox 용</a>)과 <a href="https://github.com/facebook/react-devtools/tree/master/packages/react-devtools" target="_blank" rel="external">독립 실행 형 앱</a>으로 존재합니다.</p>
<p><br></p>
<h2 id="6-Use-CRA-Create-React-App"><a href="#6-Use-CRA-Create-React-App" class="headerlink" title="6. Use CRA(Create React App)"></a>6. Use CRA(Create React App)</h2><blockquote>
<p>CRA를 사용해라.</p>
</blockquote>
<p>Facebook의 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">Create React App</a>을 사용하면 빌드 구성없이 React 앱을 만들 수 있습니다. CRA는 사용하기가 매우 쉽고 잘 갖춰진 documentation을 가지고 있습니다. Node&gt; = 6 만 있으면 되며 macOS, Windows 및 Linux에서 작동합니다. 개발 생산성을 높여주는 HRM도 해당 scaffolding 모듈에서 지원하고 있습니다. (개인적으로는 글로벌로 설치해도 아쉽지 않은 녀석입니다!)</p>
<p><br></p>
<h3 id="역자-덧붙임"><a href="#역자-덧붙임" class="headerlink" title="역자 덧붙임"></a>역자 덧붙임</h3><p>좋은 참고자료를 첨부합니다.</p>
<ul>
<li><a href="https://github.com/reactkr/learn-react-in-korean" target="_blank" rel="external">한국어로 배우는 리액트</a></li>
<li><a href="https://github.com/Microsoft/TypeScript-React-Starter" target="_blank" rel="external">TypeScript-React-Stater</a></li>
<li><a href="https://github.com/chantastic/reactpatterns.com" target="_blank" rel="external">react-patterns (영어)</a></li>
</ul>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>일부 의역이 들어갔으며 오역이 존재할 수 있습니다. 해당 사항에 대해서는 댓글로 피드백 주시면 감사하겠습니다. 더 좋은 포스팅으로 뵙겠습니다! 감사합니다.</p>
<p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488" target="_blank" rel="external">https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488</a></em></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/01/02/React-tips-for-beginners/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2018/01/02/React-tips-for-beginners/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/01/01/React-4-Component-Life-Cycle/">
                            [React] 4. Component Life Cycle
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-01T17:08:03+09:00">
	
		    Jan 01, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/react_logo.png" alt=""></p>
<h1 id="React-Lifecycle-Methods-how-and-when-to-use-them"><a href="#React-Lifecycle-Methods-how-and-when-to-use-them" class="headerlink" title="React Lifecycle Methods - how and when to use them"></a>React Lifecycle Methods - how and when to use them</h1><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="external">https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1</a></em></p>
<h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul>
<li>Intro</li>
<li>React Component Life Cycle<ul>
<li>componentWillMount</li>
<li>componentDidMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
</li>
</ul>
<p><br></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><img src="/images/react_component_life_cycle.png" alt=""></p>
<p>위 다이어그램은 React 컴포넌트의 출생(pre-mounting)과 사망 (unmounting)에서의 Life Cycle입니다. React의 장점은 복잡한 UI를 작은 크기로 나누는 것입니다. 따라서 앱을 각각의 컴포넌트 단위로 분류 할 수 있을 뿐만 아니라 각 컴포넌트에 대해 customize 할 수 있습니다.</p>
<p>React Component의 라이프 사이클 메소드를 통해 UI의 각 컴포넌트가 <strong>렌더링(rendering)</strong>, <strong>업데이트(update)</strong>, <strong>재렌더링(re-rendering)</strong> 될 때를 고려할 수 있으며 <strong>완전히 사라질 때(unmount)</strong> 일어나는 일을 제어 할 수 있습니다.</p>
<p><br></p>
<h2 id="React-Component-Life-Cycle"><a href="#React-Component-Life-Cycle" class="headerlink" title="React Component Life Cycle"></a>React Component Life Cycle</h2><p>React 컴포넌트의 생명 주기를 부분적으로 나누어 간단히 살펴보면 다음과 같습니다.</p>
<h3 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h3><p>React 컴포넌트의 인스턴스가 생성되고 DOM에 삽입되는 과정의 life cycle 입니다.</p>
<ol>
<li>constructor</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ol>
<h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p><code>prop</code> 또는 <code>state</code>의 변경으로 해당 컴포넌트가 re-render 되는 경우의 life cycle 입니다.</p>
<h4 id="Props-Change"><a href="#Props-Change" class="headerlink" title="Props Change"></a>Props Change</h4><ol>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h4 id="State-Change"><a href="#State-Change" class="headerlink" title="State Change"></a>State Change</h4><ol>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h3 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h3><ul>
<li>componentWillUnmount</li>
</ul>
<p>이제 각각에 대해서 살펴봅시다.</p>
<p><br></p>
<h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a><code>componentWillMount</code></h2><p>개발자가 정의한 컴포넌트는 눈 깜짝할 사이에 화면에 그려집니다. 이 순간 무엇을 할 수 있을까요? 그에 대한 대답은 사실 할 수 있는 것이 별로 없습니다. <code>componentWillMount</code> 메소드는 딱히 쓸모가 없습니다.</p>
<p><code>componentWillMount</code>에서는 아직 생성된 컴포넌트가 없으므로 DOM 관련 작업을 수행 할 수 없습니다. 또한 컴포넌트의 기본 구성(<code>props</code> or <code>state</code>)을 설정하는 생성자(constructor)가 호출된 이후에는 아무 것도 변경되지 않았습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sidebar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  tooltipsEnabled = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">analyticsOpen</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">requirementsOpen</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">brandInfoOpen</span>: <span class="literal">false</span>,</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>생성자가 호출되고 나면 그 상태가 바로 컴포넌트의 초기 상태가 됩니다. 추가적인 라이프 사이클 메소드를 복잡하게 사용하지 않고도 거의 모든 것이 컴포넌트 코드의 나머지 부분에서 처리되어야 합니다. 그 중에서도 예외가 있다면 초기에만 수행할 수있는 설정 즉, 외부 API에 연결하는 작업이 있을 것입니다. 예를 들어, 앱에 Firebase를 사용한다면, 앱이 처음 설치 될 때 설정을 가져와야합니다. 그러나 여기서 핵심은 이러한 작업은 앱의 최상위 컴포넌트 (루트 컴포넌트)에서 수행되어야 한다는 것입니다.</p>
<p>이는 컴포넌트의 99 %가 <code>componentWillMount</code>를 사용하지 않아야 함을 의미합니다. <code>componentWillMount</code>를 사용하여 컴포넌트에 대한 데이터를 로드하기 위해 AJAX 호출을 시작하는 사람들을 볼 수 있습니다. 하지만 이 글을 읽는 당신은 이러지 않았으면 좋겠습니다. 바로 다음 section인 두번째 section에서 이 부분에 대해 이야기하겠습니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례"><a href="#이-메소드의-가장-일반적인-사용-사례" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>루트 컴포넌트에서 App과 관련된 외부 API를 설정할 떄.</li>
<li>setState 호출(?) : <code>setState</code>도 호출하지 말고 constructor에서 설정한 <code>this.state</code>를 사용하세요.</li>
</ul>
<p><br></p>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a><code>componentDidMount</code></h2><p>이제 컴포넌트가 mount되고 사용할 준비가 되었습니다.</p>
<p><code>componentDidMount</code>는 가지고 놀 컴포넌트가 없을 때 할 수 없었던 것들을 모두 할 수 있는 메소드입니다. 몇 가지 예를 들면 다음과 같습니다.</p>
<ul>
<li><code>&lt;canvas&gt;</code> 에 렌더링을 수행한다.</li>
<li>요소 컬렉션에서 <a href="https://masonry.desandro.com/" target="_blank" rel="external">Masonry</a> 그리드 레이아웃을 초기화한다.</li>
<li>Event listener를 추가한다.</li>
</ul>
<p>기본적으로 여기에서는 DOM에 대한 접근이 필요한 모든 설정을 수행하고 필요한 데이터를 가져오기 시작합니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-1"><a href="#이-메소드의-가장-일반적인-사용-사례-1" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>Ajax 호출을 시작하여 컴포넌트에서 사용해야 하는 데이터를 로드합니다.</li>
<li>setState를 호출할 수 있습니다.</li>
</ul>
<p><br></p>
<h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><code>componentWillReceiveProps</code></h2><p>컴포넌트가 정상적으로 잘 동작하고 있었는데 새로운 <code>props</code>가 전달되었습니다. 아마 상위 컴포넌트에서 <code>componentDidMount</code>에 의해 로드된 데이터 중 일부가 내려왔을 것입니다.</p>
<p>새로운 <code>props</code>로 어떠한 작업을 수행하기 전 이 새로운 <code>props</code>를 인자로 하여 <code>componentWillReceiveProps</code>가 호출됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps(nextProps) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">parseInt</span>(nextProps.id, <span class="number">10</span>) !== <span class="built_in">parseInt</span>(<span class="keyword">this</span>.props.id, <span class="number">10</span>)) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">postsLoaded</span>: <span class="literal">false</span> &#125;);</div><div class="line">    <span class="keyword">this</span>.contentLoaded = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>우리는 이 메소드 안에서 <code>nextProps</code>를 통해 다음의 <code>props</code>(새로운 <code>props</code>)에 접근할 수 있고 <code>this.props</code>를 통해 현재의 <code>props</code>에 접근할 수 있습니다.</p>
<p>이 메소드에서 우리 해야하는 것은 다음과 같습니다.</p>
<ol>
<li>props가 바뀌었는지 확인합니다. 가끔 <code>props</code>가 변경되지 않은 경우에도 호출됩니다.</li>
<li>만약 <code>props</code>가 변경되었다면 그에 따라 로직을 구성해야 한다.</li>
</ol>
<p>새로운 <code>props</code>를 받았을 때, 다음과 같이 처리합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps(nextProps) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.percent !== nextProps.percent) &#123;</div><div class="line">    <span class="keyword">this</span>.setUpPercent(nextProps.percent);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>하나 더 주의해야 할 것은 <code>componentWillReceiveProps</code>는 초기 렌더링시 호출되지 않습니다. 코드 상으로는 컴포넌트가 <code>props</code>를 받는다는 것을 의미하지만 비교할 기존의 <code>props</code>가 없으므로 로직에 포함되지 않습니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-2"><a href="#이-메소드의-가장-일반적인-사용-사례-2" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>해당 컴포넌트의 상태 변경에 영향을 끼지는 <code>props</code>의 변경에 따라 로직을 구성합니다.</li>
<li>setState를 호출할 수 있습니다.</li>
</ul>
<p><br></p>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a><code>shouldComponentUpdate</code></h2><p>컴포넌트가 불안정한(?) 상태입니다. 이 메소드가 호출되었다는 것은 현재 컴포넌트의 상태와 view에 그려진 내용, 상태가 다르다는 것을 의미하기 때문입니다.</p>
<p>우리에게는 새로운 <code>props</code>가 있습니다. 전형적인 React 신조에 따르면 컴포넌트가 새로운 <code>props</code>나 새로운 <code>state</code>를 받으면 업데이트해야 한다고 말합니다.</p>
<p><code>shouldComponentUpdate</code> 메소드는 <code>nextProps</code>를 첫 번째 인수로 사용하고 <code>nextState</code>는 두 번째 인수로 사용합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.engagement !== nextProps.engagement</div><div class="line">    || nextState.input !== <span class="keyword">this</span>.state.input;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>shouldComponentUpdate</code>는 항상 <code>boolean</code>을 반환해야 합니다. 이것은 “해당 컴포넌트를 다시 렌더링(re-render)해야 하나요?”라는 질문에 대한 답이 됩니다. 해당 컴포넌트를 특별히 override하지 않는 이상 이 메소드는 기본적으로 <code>true</code>를 반환합니다.</p>
<p>하지만 불필요한 재렌더링(re-render)를 방지하기 위해서는 <code>shouldComponentUpdate</code>를 override 할 수 있습니다. 자세한 내용은 다음 <a href="https://engineering.musefind.com/how-to-benchmark-react-components-the-quick-and-dirty-guide-f595baf1014c" target="_blank" rel="external">링크</a>를 참고해주세요. (이 링크에서는 많은 필드가 있는 테이블에서 테이블이 다시 렌더링 될 때 각 필드가 다시 렌더링되어 작업속도가 느려지게 된다는 것을 보여주고 있습니다.)</p>
<p><code>shouldComponentupdate</code>를 사용하면 변화에 신경써야 하는 <code>props</code>의 변경에 대해서만 update를 진행할 수 있습니다. 하지만 이에 대한 설정을 잊으면 React 컴포넌트가 제대로 동작하지 않기 때문에 명심해야 합니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-3"><a href="#이-메소드의-가장-일반적인-사용-사례-3" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>해당 컴포넌트의 re-render를 제어할 때 사용합니다.</li>
<li>setState를 호출할 수 없습니다.</li>
</ul>
<p><br></p>
<h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a><code>componentWillUpdate</code></h2><p>방금 전까지 컴포넌트를 update하는데 집중을 했는데요, 이 메소드에서는 update가 발생하기 전 어떠한 작업이 필요한 경우 해당 메소드 안에서 해결할 수 있습니다.<br>이 메소드는 메소드 내에서 <code>this.setState</code>를 호출할 수 없다는 점을 제외하면 기본적으로 <code>componentWillReceiveProps</code>와 동일합니다.</p>
<p>이미 <code>shouldComponentUpdate</code>를 사용 중인데 또 <code>props</code>가 변경될 때 작업이 필요한 경우 이 메소드가 적절하겠지만 추가적인 유용성은 많이 주지는 못할 것입니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-4"><a href="#이-메소드의-가장-일반적인-사용-사례-4" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li><code>shouldComponentUpdate</code>가 이미 사용되고 있는 컴포넌트에서 <code>componentWillReceiveProps</code> 대신 사용됩니다. 단 해당 메소드 내에서는 이전 <code>props</code>에 접근할 수 없습니다.</li>
<li>setState를 호출할 수 없습니다.</li>
</ul>
<p><br></p>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a><code>componentDidUpdate</code></h2><p>이 메소드에서는 <code>componentDidMount</code>에서 했던 것과 동일한 작업을 수행할 수 있습니다. (예를 들면, 레이아웃을 다시 설정한다던가 canvas를 그린다던가) </p>
<p><code>shouldComponentUpdate</code>가 호출된 다음, <code>render</code>가 호출된 다음 호출되는 메소드입니다. 하지만 아쉽게도 이 메소드 내에서는 어떠한 이유로 update가 이루어졌는지 알 수 없습니다. 그렇기 때문에 변경된 데이터에 대해 DOM조작을 다시 해줘야하는 경우가 있다면 이 메소드에서 수행해줄 수 있습니다.</p>
<p><code>componentWillReceiveProps</code>에서도 충분히 해줄 수 있는 작업들이지만 불필요한 re-render를 방지하기 위해 DOM과 관련된 작업들을 주로 수행합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">componentDidUpdate() &#123;</div><div class="line">  <span class="keyword">this</span>.createGrid();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="이-메소드의-가장-일반적인-사용-사례-5"><a href="#이-메소드의-가장-일반적인-사용-사례-5" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li><code>prop</code> 또는 <code>state</code>에 따라서 DOM을 업데이트 합니다.</li>
<li>setState를 호출할 수 있습니다.</li>
</ul>
<p><br></p>
<h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a><code>componentWillUnmount</code></h2><p>컴포넌트가 unmount 되기 전 호출되는 메소드로 마지막으로 수행해야하는 작업이 있다면 이 메소드에서 수행해줄 수 있습니다. 여기서는 네트워크 요청을 취소하거나 컴포넌트와 관련된 모든 이벤트 리스터를 제거할 수 있습니다. 기본적으로 해당 컴포넌트와 관련있는 작업들만 수행합니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-6"><a href="#이-메소드의-가장-일반적인-사용-사례-6" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>컴포넌트와 관련된 것들을 제거하는 메소드입니다.</li>
<li>setState를 호출할 수 없습니다.</li>
</ul>
<p><br></p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>이상적인 애플리케이션에서는 life cycle 에 접근할 필요가 없습니다. 렌더링과 관련된 거의 모든 이슈는 <code>state</code>와 <code>props</code>만을 통해 제어될 수 있습니다. 하지만 몇몇의 경우, 컴포넌트의 업데이트 방법과 그 순간 순간에 대해 좀 더 명확히 제어할 필요가 있습니다. 때문에 life cycle에 접근하여 컴포넌트를 제어하는 것이 필요하다면 이상적인 동작에 영향이 끼치지 않도록 조심스럽게 사용해야 합니다.</p>
<p><br></p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>일부 의역이 들어갔으며 오역이 존재할 수 있습니다. 해당 사항에 대해서는 댓글로 피드백 주시면 감사하겠습니다. 더 좋은 포스팅으로 뵙겠습니다! 감사합니다.</p>
<p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="external">https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1</a></em></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/01/01/React-4-Component-Life-Cycle/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2018/01/01/React-4-Component-Life-Cycle/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/12/30/TS-5-Generics-in-TypeScript/">
                            [TS] 5. Generics in TypeScript
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-12-30T16:11:41+09:00">
	
		    Dec 30, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-5-Generics-in-TypeScript"><a href="#TS-5-Generics-in-TypeScript" class="headerlink" title="[TS] 5. Generics in TypeScript"></a>[TS] 5. Generics in TypeScript</h1><p><code>Generics</code>는 자바스크립트 개발자에게 친숙하지 않은 용어일꺼라고 생각됩니다. 하지만 정적 타이핑에 있어서 큰 부분을 차지하고 있는 Generics syntax에 대해 알아봅니다.</p>
<h4 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h4><ul>
<li>Generics?</li>
<li>Generics to Class</li>
<li>Generics to Function</li>
</ul>
<p><br></p>
<h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics?"></a>Generics?</h2><p>이전에 다뤘던 인터페이스가 어떠한 ‘틀’을 지정하여 함수 또는 클래스를 정의했다면, 제네릭을 통하여 함수 또는 클래스에 ‘틀’을 ‘주입’하여 그 확장성을 보다 높일 수 있습니다. 즉, 제네릭의 목적은 재사용성(reusable)을 높이고 함수나 클래스의 확장성을 높여 중복된 코드를 방지하기 위함이라고 할 수 있습니다.</p>
<p><br></p>
<h2 id="Generics-to-Class"><a href="#Generics-to-Class" class="headerlink" title="Generics to Class"></a>Generics to Class</h2><p>어떠한 장바구니(Basket)에 물건(Item)을 넣어야 한다고 가정을 해봅시다. 이 때, 하나의 장바구니에는 모두 동일한 타입의 물건이 들어있어야 합니다. 이 경우 모든 경우의 수에 해당하는 장바구니를 각각의 클래스로 만들어줘야 하는 문제점이 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BookBasket &#123; ... &#125;</div><div class="line"><span class="keyword">class</span> CupBasket &#123; ... &#125;</div><div class="line"><span class="keyword">class</span> DollBasket &#123; ... &#125;</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure></p>
<p>이럴 경우, 제네릭을 사용하여 하나의 클래스에서 타입을 <strong>주입받아</strong> 모든 경우의 수에 해당하는 장바구니를 만들 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Basket&lt;T&gt; &#123;</div><div class="line">  <span class="keyword">private</span> item: T[];</div><div class="line"></div><div class="line">  getItem(index: <span class="built_in">number</span>): T &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.item[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>아주 간단한 <code>Basket</code>클래스를 만들어 보았습니다. 일반 클래스를 정의할 때와는 다르게 <code>&lt;T&gt;</code>라는 것이 클래스 이름 옆에 추가된 것을 확인하실 수 있는데요, 해당 클래스 내에서 사용할 타입을 <code>T</code>라는 값으로 받을 수 있게 되는 것입니다. 여기서 <code>T</code>는 별 뜻이 있는게 아니라 Type의 약자입니다. 이렇게 정의한 클래스를 이용하여 여러 경우에 해당하는 장바구니를 생성할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bookBasket = <span class="keyword">new</span> Basket&lt;Book&gt;();</div><div class="line"><span class="keyword">const</span> cupBasket = <span class="keyword">new</span> Basket&lt;Cup&gt;();</div><div class="line"><span class="keyword">const</span> dollBasket = <span class="keyword">new</span> Basket&lt;Doll&gt;();</div></pre></td></tr></table></figure></p>
<p><code>new</code> 키워드를 통해 인스턴스를 생성할 때 정의할 때와 마찬가지로 <code>&lt;&gt;</code>와 함께 타입을 지정하여 인스턴스를 생성해줍니다. (<code>Book</code>, <code>Cup</code>, <code>Doll</code>에 대한 인터페이스 정의는 생략합니다.)</p>
<p><br></p>
<h2 id="Generics-to-Function"><a href="#Generics-to-Function" class="headerlink" title="Generics to Function"></a>Generics to Function</h2><p>제네릭스는 클래스 뿐만 아니라 함수에도 적용될 수 있는데요, 이전에 살펴보았던 AjaxUtils를 예제로 제네릭에 대해 알아보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">param: fetchDataParam</span>): <span class="title">Promise</span>&lt;<span class="title">DataFormat</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위 함수는 <code>fetchDataParam</code>이라는 타입의 인자만 받을 수 있으며 <code>Promise&lt;DataFormat&gt;</code>이라는 타입의 반환만 할 수 있게 설계되어 있습니다. 그러나 함수의 body가 여러 곳에서 중복된다면 <code>fetchDataParam</code> 또는 <code>DataFormat</code>을 위 함수에 주입하여 여러 상황에 대응할 수 있는 함수로 변환시킬 수 있습니다. 이 때, 제네릭이 사용됩니다.</p>
<p>위 함수에 제네릭을 적용하여 함수의 재사용성을 높여보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchDataOf</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">param: T</span>): <span class="title">Promise</span>&lt;<span class="title">U</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`<span class="subst">$&#123;param&#125;</span>`</span>);</div><div class="line">    <span class="keyword">return</span> response.json();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>arrow function에도 마찬가지로 적용할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fetchDataOf = <span class="keyword">async</span> &lt;T, U&gt;(param: T): <span class="built_in">Promise</span>&lt;U&gt; =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`<span class="subst">$&#123;param&#125;</span>`</span>);</div><div class="line">    <span class="keyword">return</span> response.json();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>이렇게 정의를 하면 다음과 같이 호출할 수 있습니다. 여기서 T와 U는 그냥 type의 종류를 나타내는 character라고 생각하시면 됩니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> data: DataFormat = <span class="keyword">await</span> fetchDataOf&lt;<span class="built_in">string</span>, DataFormat&gt;(baseUrl);</div></pre></td></tr></table></figure>
<p><code>param</code>으로 넘겨주게 되는 인자의 타입이 다르거나, 반환하게 되는 값의 타입이 다를 경우에도 <code>&lt;&gt;</code>에 해당 타입을 지정하여 하나의 함수를 사용할 수 있게 됩니다.</p>
<p>물론 <any>의 형식으로도 사용할 수 있지만(이럴바에 차라리 자바스크립트를 사용하는 것이 생산성 측면에서 더 좋을 것 같습니다.) 특정 타입을 받아 해당 타입으로 반환한다는 측면에 있어서 안정성과 확장성 두 마리 토끼를 모두 잡을 수 있습니다.</any></p>
<p><br></p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>실제 개발해서보다는 라이브러리를 개발할 때 많이 사용할 수 있는 Generics에 대해 알아봤습니다. 해당 포스팅 외 다른 타입스크립트 포스팅은 <a href="https://github.com/JaeYeopHan/typescript_tutorial_docs" target="_blank" rel="external">여기</a>에서 보실 수 있으며 예제에 사용된 코드는 <a href="https://github.com/JaeYeopHan/typescript_playground" target="_blank" rel="external">여기</a>에서 확인하실 수 있습니다.<br>감사합니다.</p>
<p><em>5. Generic in TypeScript end</em></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="external">TypeScript Official Document - Generics</a></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/12/30/TS-5-Generics-in-TypeScript/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/12/30/TS-5-Generics-in-TypeScript/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/page/2/">
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 1 of 7</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Jbee. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Jbee</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->



    </body>
</html>

{"meta":{"title":"Devlog","subtitle":"Front End Developer, Jbee's blog","description":"blog posted about web front development","author":"Jbee","url":"https://jaeyeophan.github.io"},"pages":[],"posts":[{"title":"[ES6] 5. Destructuring and Default Parameter","slug":"ES6-5-Destructuring-and-Default-Parameter","date":"2017-04-18T11:59:34.000Z","updated":"2017-04-18T12:01:31.000Z","comments":true,"path":"2017/04/18/ES6-5-Destructuring-and-Default-Parameter/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/ES6-5-Destructuring-and-Default-Parameter/","excerpt":"","text":"[ES6] 5. Destructuring and Default ParameterDestructuringshorthand 방식을 이용하여 함수의 반환값을 바로 객체에 할당할 수 있다. 이 때 함수에서 반환되는 프로퍼티 값과 지역 변수의 이름이 같아야 가능하다. 이렇게 하면 함수의 반환 값을 임시 객체에 저장하고 그 객체의 프로퍼티를 통해 접근하여 지역 변수에 할당하는 과정을 축소할 수 있다. 굳이 전체를 객체에 할당하지 않고 부분적으로만 할당도 가능하다. 즉, 리턴되는 값이 객체일 경우, 그 객체를 분해하여 바로 지역변수로 접근이 가능하다는 것이다. (iterable protocol을 구현해야만 destructuring이 가능하다.)123456789function buildUser(first, last)&#123; let fullName = first + \" \" + last; return &#123;first, last, fullName&#125;;&#125;let &#123; first, last, fullName &#125; = buildUser(\"Sam\", \"Williams\");console.log(first); // Samconsole.log(last); // Williamsconsole.log(fullName); // Sam Williams 굳이 전체를 객체에 할당하지 않고 부분적으로만 할당도 가능하다.12let &#123; fullName &#125; = buildUser(\"Sam\", \"Williams\");console.log( fullName ); // Sam Williams Method Initializer Shorthand객체에 함수를 추가할 때, 객체의 프로퍼티에 익명 함수를 추가하는 방식을 사용했다. ES6에서는 메소드를 활용한다. 비교를 위해 ES5도 함께 제시한다.ES6code&gt;&gt;123456789function buildUser(first, last, postCount)&#123; return &#123; first, last, isActive : function( ) &#123; //... &#125; &#125;&#125; ES6code&gt;&gt;123456789function buildUser(first, last, postCount)&#123; return &#123; first, last, isActive( ) &#123; //... &#125; &#125;&#125; Destructuring Assignment오른쪽의 배열을 분할하여 왼쪽 변수에 값을 할당한다. 인덱스 번째의 엘리먼트 값을 인덱스 번째의 변수에 할당하는 것이다. 엘리먼트가 아직 남았는데 할당할 변수가 없다면 그대로 할당되지 않고, 엘리먼트가 남지 않았는데 할당한 변수가 있다면 그 변수는 undefined로 할당된다.1234567891011121314let one, two, three, four;//case1[one, two] = [1, 2];console.log(one); //1console.log(two); //2//case2[one, two, three] = [1, 2];console.log(one); //1console.log(two); //2console.log(three);//undefined//case3[one, two] = [1, 2, 3];console.log(one); two//1console.log(two); //2 이전 Chapter에서 다뤘던 Spread 연산자를 사용할 수 있으며, 공백으로 두어 해당 값을 건너 뛰고 할당할 수 있다.1234567[one, ...other] = [1, 23, 24, 25];console.log(one); //1console.log(other); //[23, 24, 25][one, , , four] = [1, 2, 3, 4];console.log(one); //1console.log(four); //4 Default Valuedestructuring을 통해 값을 할당할 때, 해당하는 값이 없을 때, undefined 대신 할당할 default value를 지정해줄 수 있다.123456789let [first, second, third = 3] = [1, 2];console.log(first); //1 by destructuringconsole.log(second); //2 by destructuringconsole.log(third); //3 by default valuelet [fourth, fifth, sixth = 6] = [4, 5, 66];console.log(first); //4 by destructuringconsole.log(second); //5 by destructuringconsole.log(third); //66 by destructuring Default Parameterparameter에 값이 넘어가지 않아도, default value로 설정된 값이 해당 파라미터 대신 값이 할당된다. parameter에서도 마찬가지로 기존의 default value는 undefined 값이었지만, 그 값을 코드 상에서 설정할 수 있게 된 것이다.12345let somethingFunction = (prev, post = 20) =&gt; prev + post;console.log(somethingFunction(1)); //21 by default parameterconsole.log(somethingFunction(1, 2)); //3console.log(somethingFunction(1, undefined)); //21 by default parameterconsole.log(somethingFunction(1, null)); //1 함수에도 length라는 property가 따로 존재한다. 그런데 이 때, default parameter는 length에서 무시된다.123getTotal(100); //1getTotal(100, 0.05); //2console.log(getTotal.length); //1 한 가지 주의할 점이 있다. let으로 선언했을 때의 값은 Default parameter와는 다르기 때문에, Destructuring으로 값을 덮어쓸 수 있다. let으로 선언했을 때 할당하는 것과는 다르다.default parameter code&gt;&gt;123let salary = [100, 200, 300];let [low, avg, high = 500] = salary;console.log(high); //500 let assignment code123let low, avg, high = 500;let [low, avg, high] = salary;console.log(high); //300 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 5. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 4. Spread, Rest parameter","slug":"ES6-4-Spread-Rest-parameter","date":"2017-04-18T11:59:13.000Z","updated":"2017-04-18T12:01:30.000Z","comments":true,"path":"2017/04/18/ES6-4-Spread-Rest-parameter/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/ES6-4-Spread-Rest-parameter/","excerpt":"","text":"[ES6] 4. Spread, Rest parameterSpread이터러블 오브젝트(Iterable object)의 엘리먼트를 하나씩 분리하여 전개한다. 전개한 결과를 변수에 할당하거나 호출하는 함수의 파라미터 값으로 사용할 수 있다.1234let prev = [3,4];let post = [7,8];let spreadObj = [1, 2, ...prev, 5, 6, ...post, 9];console.log(spreadObj); // [1,2,3,4,5,6,7,8,9] 문자열도 가능하다.12let sObj = [...\"javascript\"];console.log(sObj); // [\"j\", \"a\", \"v\", \"a\", \"s\", \"c\", \"r\", \"i\", \"p\", \"t\"] Rest Parameter함수를 호출할 때 spread 연산자로 파라미터를 작성한 형태를 Rest parameter라고 한다. 함수안의 코드를 확인하지 않고도 호출문의 형태만 보더라도 Rest parameter 의 범위를 확인할 수 있어 가독성이 높아진다. 또한 Rest parameter는 Array, 즉 배열이므로 Array 오브젝트의 메서드를 사용할 수 있다. 그리고 arrow funtion에서도 사용 가능하다.12let price = [12, 20, 18];Math.max(12, 20, 18); built in Object인 Math의 메소드 max()를 사용하기 위해서는 위 코드처럼 하나씩 넘겨줘야 한다.또는 다음과 같은 방식을 사용했다.1Math.max.call(Math, price); 하지만 Rest parameter를 사용하면 보다 깔끔하게 작성할 수 있다.1let maxPrice = Max.max(...price); Rest parameter는 동적(dynamic)으로 생성된 파라미터라고 할 수 있기 때문에 함수의 length에서 포함되지 않는다. 기본적으로 함수의 length 프로퍼티는 파라미터의 개수를 의미한다.12345let getElementByRestWithParam = (param, ...rest) =&gt; &#123; console.log(param); console.log(rest);&#125;console.log(getElementByRestWithParam.length); // 1 위 getElementByRestWithParam메소드에 spread operator를 사용하여 인자를 넘겨보자.12const values = [10, 20, 30];getElementByRestWithParam(...values); //10 \\n [20, 30] param에 해당하는 인자가 따로받아지고 나머지 인자들은 ...rest로 넘겨지면서 다시 배열로 넘겨지게 된다! Rest parameter를 사용했을 때와 기존의 자바스크립트에서 arguments를 사용했을 때의 차이점을 살펴보기 위해 arguments에 대해서 잠깐 살펴보자. arguments는 Array-Like Object라는 공식 명칭을 하고 있는 유사 배열이다. Array-like Object(유사배열)배열의 특징 중 하나는 index를 갖고 있어서 임의 접근(random access)가 가능하고, 그 index가 순차적으로 증가한다는 것이다. 만약 Object가 key값이 순차적으로 증가하는 값이고, 그에 따른 value가 존재한다고 했을 때, Array-like Object라고 한다.배열의 인덱스 값을 프로퍼티 key 값으로 사용하는 것이다. 그리고 length라는 프로퍼티 값을 갖고 있어서 전개를 할 때는 다음과 같이 한다.1234567891011// Array-like objectlet arrLikeObj = &#123; 0 : \"zero\", 1 : \"one\", 2 : \"two\", length : 3&#125;;for (let i = 0; i &lt; arrLikeObj.length; i++) &#123; console.log(arrLikeObj[i]);&#125; Array-like Object는 다음 두 가지 규칙을 모두 만족시켜야 한다.1) 프로퍼티 값을 0부터 1씩 증가하면서 순차적으로 작성해야 한다.2) length를 프로퍼티 키로 하여 전체 프로퍼티 수를 작성해야 한다. Rest parameter와 arguments의 차이arguments도 Array-like object이기 때문에 for statement로 전개할 수 있다. 하지만 Array 오브젝트의 메서드를 사용할 수 없다. 이것이 치명적인 단점인 것이다. 또 arrow function에서는 arguments를 사용할 수 없다. 이것으로 미루어보아, ES6에서는 arguments를 사용하는 것을 최대한 자제하라는 느낌이다. 사실 Rest parameter에 익숙해지기만 하면 arguments를 통해 인자를 받는 것보다 유연한 코드를 작성할 수 있다. 한 가지 더 한계점을 지적하자면 arguments는 함수 내부를 봐야 어느 부분에서 arguments 객체를 사용하는지 알 수 있어 코드의 가독성이 떨어지게 된다. 그렇기 때문에 arguments 대신 Rest parameter를 도입한 것이다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 4. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 3. Iteration and for-of statement","slug":"ES6-3-Iteration-and-for-of-statement","date":"2017-04-18T04:52:45.000Z","updated":"2017-04-18T04:54:08.000Z","comments":true,"path":"2017/04/18/ES6-3-Iteration-and-for-of-statement/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/ES6-3-Iteration-and-for-of-statement/","excerpt":"","text":"[ES6] 3. Iteration and for-of statementIterationES6에서 이터레이션 프로토콜은 Iterable 프로토콜과 Iterator 프로토콜로 구성된다. 결론부터 말하자면 Iterable 프로토콜은 반복 가능한 오브젝트를 나타내는 프로토콜이며 Iterator 프로토콜은 이터러블 오브젝트(Iterable 프로토콜을 따르는 오브젝트)의 값을 작성한 순서대로 처리하는 프로토콜이다. Iterable 프로토콜오브젝트의 반복 처리 규약을 정의한다.Iterable Object String, Array, Map, Set, TypedArray, Argument 오브젝트 그리고 DOM의 NodeList 위 built in 오브젝트들은 디폴트로 이터러블 프로토콜을 갖고 있다. 오브젝트에 Symbol.iterator가 있어야 한다. Symbol.iterator가 있는 오브젝트는 이터러블 오브젝트이다. 또한 상속받은 prototype chain에 있어도 이터러블 오브젝트이다. (Symbol에 대해서는 다음 포스팅에서 다룰 예정이다.) 오브젝트에 프로퍼티 존재 여부를 체크할 때, Symbol의 경우에는 arrayObj[Symbol.iterator]와 같이 대괄호 []안에 작성해야 한다.1234let arr = [];console.log(arr[Symbol.iterator]); //function values() &#123; [native code] &#125;let obj = &#123;a:1&#125;;console.log(obj[Symbol.iterator]); //undefined Array 오브젝트는 기본적으로 iterable 프로토콜을 구현한다. 하지만 Object 오브젝트는 iterable 프로토콜을 구현하지 않는다.1let iteratorObj = arr[Symbol.iterator](); //iterator object 위와 같은 방식으로 Array 오브젝트는 iterator를 받을 수 있다. JavaScript’s for statementforEachforEach 문은 arrow function과 조합해서 사용하면 추가적인 변수 사용 없이 코드가 깔끔해질 수 있다.12345678let categories = [\"Korean\", \"English\", \"Science\"];categories.forEach(subject =&gt; &#123; console.log(subject);&#125;);console&gt;KoreanEnglishScience 그러나 for문 중간에 continue or break or return 선언문을 사용할 수 없다. 기존의 for-statement를 사용하는 경우를 보자.1234567for (let i = 0; i &lt; subject.length; i++) &#123; console.log(categoried[i]);&#125;console&gt;KoreanEnglishScience i의 역할이 index를 잡아주는 것 외에 별 다른 기능이 없다. 그래서 기존에는 for-in statement를 사용했다. 하지만 for-in statement 은 문자열 키를 가진 일반 Object 객체들을 위해 만들어졌다.1234567for (let item in categories) &#123; console.log(item);&#125;console&gt;012 그래서 ES6에서 for-of statement가 등장했다.for-in loop statement는 객체의 프로퍼티들을 루프시키지만 for-of loop statement는 데이터, 즉 배열 내의 value들을 루프시킨다. 또한 for-of는 배열 뿐만 아니라 다양한 Collection에도 동작한다. DOM의 NodeList 같은 유사배열 객체들에도 동작하고 문자열에도 동작한다. 문자열을 유니코드 문자의 배열로 취급하는 것이다. Set, Map에 대해서도 물론 동작한다. key-value 형식의 Map에 대해서는 for (let [key, value] of …) 형식의 destructuring을 사용한다.1234567for (let item of categories) &#123; console.log(item);&#125;console&gt;KoreanEnglishScience 단 for-of 가 만능은 아니다. Object의 프로퍼티를 루프시키려면 for-in statement를 사용해야 한다. 사실 for-in statement의 원래 목적이 Object 프로퍼티 순회이다. Object를 순회하는 경우를 살펴보자.12345let obj = &#123; one : 1, two : 2, three : 3&#125;; 위와 같은 obj라는 오브젝트를 정의한다.12345678for (let key in obj) &#123; console.log(key);&#125;// console&gt;// one// two// three for-in statement를 통해서 정의한 오브젝트(obj)의 key를 순회했다.1234567for (let key in obj) &#123; console.log(obj[key]);&#125;// console&gt;// 1// 2// 3 오브젝트를 for-of statment로 순회하면 어떻게 될까?12345for (let item of obj) &#123; console.log(item);&#125;// console&gt;// Uncaught TypeError: obj[Symbol.iterator] is not a function JavaScript의 Object는 iterable 프로토콜을 구현하고 있지 않기 때문에, Symbol.iterator가 존재하지 않는다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 3. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 2. Arrow function","slug":"ES6-2-Arrow-function","date":"2017-04-18T04:51:49.000Z","updated":"2017-04-18T04:54:06.000Z","comments":true,"path":"2017/04/18/ES6-2-Arrow-function/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/ES6-2-Arrow-function/","excerpt":"","text":"[ES6] 2. Arrow Function Always apply to ‘Anonymous function’ 자바스크립트의 Scope자바스크립트에서 생성자 함수를 통해 객체를 생성하면 변수 scope가 변경된다. 즉, 생성자 함수 내부에서의 this는 자신을 호출한 대상이 아닌 생성자 함수를 가리키게 된다. 생성자 함수를 통해 생성되는 객체의 과정 때문이다. 그래서 우리는 여태껏 별의 별짓을 다해왔다. self며 bind며 jQuery에서는 proxy라는 녀석도 사용했다. 새로운 function의 등장하지만 이제는 새로 도입된 Arrow function 을 사용하여 변수 스코프를 보존하자. Arrow function를 통해서 함수를 정의하게 되면, 변수들이 사용되는 위치와는 상관없이 변수들이 정의되어 있는 값으로 scope가 binding 된다. 한 가지 특징을 덧붙이자면, arrow function을 사용하게 되면 arguments 객체가 생성되지 않는다. 하지만 우리는 ES6 문법을 사용하는 이상, arguments는 필요하지 않다! Arrow function RuleES6의 arrow function에는 몇 가지 규칙이 존재하며 대부분의 lamda에서도 비슷한 규칙을 가지고 있어서 lamda를 사용해본 경험이 있다면 어색하지 않을 것이다.1) Parameter와 화살표 사이에서 개행할 수 없다.2) Parameter가 하나일 때는 괄호를 생략할 수 있다.3) Parameter가 없으면 소괄호( ( ) )만 작성한다.4) Block scope({ })를 지정하지 않고 한 줄로 arrow function을 사용할 때는 return이 생략될 수 있다.5) 그 반대로 block scope를 사용한다면 return을 명시해줘야 한다. Arrow Function은 this를 bind하지 않는다!12345678//ES5document.getElementById(\"todos\").addEventListener(\"click\", function() &#123; console.log(this); //#todos&#125;);//ES6document.getElementById(\"todos\").addEventListener(\"click\", () =&gt; &#123; console.log(this); //Window&#125;); this의 정체ES5에서 this 결정되는 세 가지 조건을 짚고 넘어가자.1) 생성자 내에서생성자 함수를 new라는 키워드를 통해 호출하면 내부에서 this는 인스턴스 그 자체를 가리킨다. 생성자 함수 내부에서 return this;가 생략되어 있기 때문이다.2) 함수 내에서this는 생략된 매개 변수이다. 무엇이 함수를 호출했는가가 this를 결정한다.3) bind, apply, call method or proxy method of jQuerythis는 메소드로 바꿔준 대상을 가리키게 된다. 그렇다면 arrow function 내에서 this는 무엇을 가리키는가. 해당 function을 정의한 영역의 this를 가져온다. 한 단계 더 위의 element를 가리키는 것이다. 그렇기 때문에 prototype에 함수를 정의할 때 arrow function을 사용할 때 내부적으로 this를 사용하게 되면 객체를 가리키지 않고 window 객체를 가리키게 된다. 또한 arrow function은 명식적으로 bind, call로 this를 넣어줘도 이를 무시한다. ES6의 arrow function은 단순히 함수를 간단하게 작성할 수 있는 문법이 아니다. 기존의 방식대로 function을 작성해야만 의도대로 작동하는 function이 존재할 수 있고, arrow function으로 기존의 function을 작성하던 방식보다 편하게 작성할 수 있게 된 것이다. 두 가지 방식의 차이점을 제대로 이해하고 새로운 문법과 기존의 문법을 적재적소에서 사용하는 것이 중요해졌다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 2. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 1. let-const","slug":"let-const","date":"2017-04-18T04:48:49.000Z","updated":"2017-04-18T06:48:56.000Z","comments":true,"path":"2017/04/18/let-const/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/let-const/","excerpt":"","text":"[ES6] 1. let &amp; const자바스크립트의 정체ES6의 문법을 알아보기 전에 자바스크립트의 정체부터 짚고 넘어가자. 자바스크립트(JavaScript)는 스크립트 언어(script language)이다. 스크립트 언어란 언어를 해석하고 실행하는 소프트웨어가 따로 존재하는 언어를 말한다. 자바스크립트를 해석하고 실행하는 소프트웨어는 브라우저이다. 이러한 의미에서 Node.js는 스크립트 언어라고 부르기 애매하고 자바스크립트의 문법을 차용한 다른 종류의 언어라고 생각해도 된다. 우선 자바스크립트가 해석되고 실행될 때 일어나는 확보, 선언, 할당의 차이를 짚고 넘어가야 한다. 확보브라우저가 자바스크립트를 해석할 때 두 번 파싱(parsing)하는데 첫번째 파싱 과정이 Lexical parsing이다. 실행하려는 자바스크립트 파일이 어느 정도의 메모리를 필요로 하는지를 파악하기 위해 거치는 파싱 과정인 것이다. 이 때 자바스크립트의 모든 선언문은 호이스팅(Hoisting)된다. 선언말 그대로 선언하는 것이다. 값을 할당하지 않는다. 자바스크립트에서는 선언만 하고 값을 할당하지 않으면 undefined값이 할당된다. 확보만 하고 선언하지 않으면 Reference error가 발생하고 선언을 하게 되면 undefined 값이 나타난다. 할당특정 변수에 값을 할당하는 과정이다. 위 세 가지를 파악해야 var와 let 그리고 const의 차이를 이해할 수 있다 let 으로 변수 선언 및 할당하기let으로 정의된 변수들은 호이스팅 되지 않는다(?) 많은 책에서 이렇게 표현을 하고 있지만 이것은 잘못된 표현이다. let으로 선언해도 호이스팅된다. lexical parsing 단계에서 해당 자바스크립트 파일을 실행하기 위한 메모리 공간을 확보해야하기 때문이다. 다만 let 변수로 선언이 되기 전 해당 변수를 사용하려고 하면 Reference error를 발생시키는 것이다. 예제 코드를 보자.123456789101112//ES5 code :: var&gt;&gt;console.log(foo); //undefinedvar foo;console.log(foo); //undefinedfoo = 123;console.log(foo); //123//ES6 code :: let&gt;&gt;console.log(foo); //ReferenceErrorlet foo;console.log(foo); //undefinedfoo = 123;console.log(foo); //123 let은 유효범위의 시작에서부터 선언될 때까지 temporary dead zone(일시적 사각지대)에 있다. 이 dead zone에서 사용하게 되면 ReferenceError가 발생한다. let - in for looplet으로 정의된 변수들은 가장 가까운 블록으로 scope이 지정된다. 여기서 블록이란 if, else, for, while 같은 문법으로 지정된 { } 블록을 의미한다. let 키워드를 사용한 변수들은 그들 각각의 함수 block에 귀속된다. var 변수는 함수의 상단으로 호이스팅(hoisting) 된 다음에, 각 루프의 반복 변수가 공유하게 된다. 그 결과, 콜백이 실행될 때는 i 변수가 루프의 마지막 변수로 할당된다. 즉 콜백에서 반복문을 제어하는 변수에 접근할 때 문제가 발생하는 것이다. 이러한 문제를 해결하기 위해 let을 사용할 수 있다. 123456789101112131415//ES5 codefunction loadFiles( userNames ) &#123; for(var i in userNames)&#123; _fetchProfiles(userNames[i], function() &#123; console.log(userNames[i]); &#125; &#125;&#125;loadFiles([\"A\", \"B\", \"C\", \"D\"]);console &gt;D // userNames[4]D // userNames[4]D // userNames[4]D // userNames[4] ES6 code123456789101112131415//ES6 codefunction loadFiles( userNames )&#123; for( let i in userNames )&#123; _fetchProfile(userNames[i], function()&#123; console.log(userNames[i]); &#125; &#125;&#125;loadFiles([\"A\", \"B\", \"C\", \"D\"]);console &gt;A // userNames[1]B // userNames[2]C // userNames[3]D // userNames[4] let cannot be redeclaredlet으로 정의된 변수는 같은 블록에서 재할당될 수는 있지만 재정의는 될 수 없다.123456789101112//ES6 codelet a = 'hello';a = 'world' // availablelet a = 'hello';let a = 'world'; // false -&gt; TypeError : Identifier ‘a’ has already been declaredlet flashMessage = 'hello';function loadFiles(userNames)&#123; let flashMessage = 'world'; // available return flashMessage;&#125; const - declarationconst 키워드는 상수라고 불리는 읽기 전용 변수를 생성하는 키워드이다. 한 번 할당되면, 상수는 새로운 값으로 할당될 수 없다. 명시적으로 변경을 시도해도 바뀌지 않는다. const 로 정의된 변수는 초기에 정의할 때, 반드시 값을 할당해줘야 한다. 그렇지 않으면 Syntax Error가 발생하게 된다. const 로 정의된 변수는 let과 마찬가지로, 가장 가까운 블록에 scope이 지정된다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. chapter 1. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]}]}
{"meta":{"title":"Devlog","subtitle":"Front End Developer, Jbee's blog","description":"blog posted about web front development","author":"Jbee","url":"https://jaeyeophan.github.io"},"pages":[],"posts":[{"title":"ES8 Standard Release Overview","slug":"ES8-Standard-Release-Overview","date":"2017-07-16T10:11:00.000Z","updated":"2017-07-16T10:11:56.000Z","comments":true,"path":"2017/07/16/ES8-Standard-Release-Overview/","link":"","permalink":"https://jaeyeophan.github.io/2017/07/16/ES8-Standard-Release-Overview/","excerpt":"","text":"ES8 Standard Release Overview얼마 전, standard release가 되었는데요, 이 글은 ECMAScript2017 (a.k.a es8)의 주요 스펙에 대해 간단하게 살펴보는 포스팅입니다. 1$ npm install --save-dev babel-core babel-preset-es2017 아시다시피 babel을 통해서 바로 es2017을 사용해보실 수 있습니다. babel-preset-es2017 es8_playground Repository ES8 Overviewes8의 주요 기능은 다음과 같습니다. String.prototype.padStart/String.prototype.padEnd Object.entries/Object.values Object.getOwnPropertyDescriptors Trailing Commas in Function Param Lists Async Functions 간단한 예제를 통해 알아보겠습니다 :) String paddingString 객체에 두 개의 메소드 padStart, padEnd가 추가되었습니다.12String.prototype.padStart(targetLength [, padString])String.prototype.padEnd(targetLength [, padString]) 메소드를 호출하는 문자열의 길이를 주어진 targetLength에 도달하도록 하는 메소드입니다. padString으로 전달된 문자열을 통해 주어진 길이에 도달할 수 있습니다. padString 값을 따로 전달하지 않는 경우 공백으로 문자열의 길이가 도달하게 됩니다. padStarat의 경우는 문자열의 시작 부분에 값을 추가하여 문자열의 길이를 조정하고 padEnd는 문자열의 끝 부분에 값을 추가하여 문자열의 길이를 조정합니다. targetLength의 크기가 함수를 호출하는 문자열의 길이보다 작을 경우 문자열의 길이는 변하지 않습니다. padString으로 넘겨진 문자열로 길이를 맞출 경우, 각각의 문자열에 대해서 채워지고 길이를 넘어가게 되면 버려지게 됩니다. 12345678910111213// String.prototype.padStart'hi'.padStart(1); // 'hi''hi'.padStart(2); // 'hi''hi'.padStart(5); // ' hi''hi'.padStart(5, 'p'); // 'ppphi''hi'.padStart(5, 'power');// 'ppwhi'// String.prototype.padEnd'hi'.padEnd(1); // 'hi''hi'.padEnd(2); // 'hi''hi'.padEnd(5); // 'hi ''hi'.padEnd(5, 'p'); // 'hippp''hi'.padEnd(5, 'power'); //'hipow' Object.entries(), Object.values()Object에 entries() 함수와 values() 함수가 추가되었습니다.12Object.entries(obj);Object.values(obj); entries 함수는 파라미터로 전달된 객체의 key-value를 배열로 반환합니다. values 함수는 파라미터로 전달된 객체의 value만을 배열로 반환합니다.123const obj = &#123;\"1\": \"one\", \"2\":\"two\", \"3\": \"three\"&#125;;Object.entries(obj);// [[\"1\", \"one\"], [\"2\", \"two\"], [\"3\", \"three\"]]Object.values(obj);// [\"one\", \"two\", \"three\"] Object.getOwnPropertyDescriptorsES5 스펙에서부터 Object.getOwnPropertyDescriptor란 녀석이 있었는데요, 이번에 추가된 함수는 getOwnPropertyDescriptors입니다. (뒤에 ‘s’가 추가되었네요.)12345678const object = &#123;\"1\": \"one\", \"2\":\"two\", \"3\": \"three\"&#125;;Object.getOwnPropertyDescriptor(object, \"1\");// &#123;// value: \"one\",// writable: true,// enumerable: true,// configurable: true// &#125; Object.getOwnPropertyDescriptor(obj, prop) 메서드는 주어진 객체 자신의 속성(즉, 객체에 직접 제공하는 속성, 객체의 프로토타입 체인을 따라 존재하는 덕택에 제공하는 게 아닌)에 대한 속성 설명자(descriptor)를 반환합니다. ES5에서는 obj 파라미터에 원시 데이터 타입이 전달될 경우 TypeError가 발생했지만 ES6에서는 객체로 강제하기 때문에 에러가 발생하지 않습니다. ES8에서는 .getOwnPropertyDescriptors를 제공하여 전달된 객체의 모든 프로퍼티에 대한 descriptor에 접근할 수 있습니다. {1: Object, 2: Object, ...} 형태인 객체로 반환되어 접근할 수 있습니다. (배열로 반환하지 않습니다.)12345678910111213141516const object = &#123;\"1\": \"one\", \"2\":\"two\", \"3\": \"three\"&#125;;Object.getOwnPropertyDescriptors(object);// &#123;// 1: &#123;// configurable: true,// enumerable: true,// value: \"one\",// writable: true,// &#125;,// 2: &#123;// ...// &#125;,// 3: &#123;// ...// &#125;// &#125; 함수 매개 변수 목록에서 후행 쉼표함수 매개 변수에서 후행 쉼표가 가능해졌습니다. 기존에는 syntax error를 발생시켰습니다. 추가된 이 문법은 다음을 가능하게 합니다.1234567891011class Person &#123; constructor( firstName, lastName, age, ) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; &#125;&#125; 객체를 선언할 때, 후행 comma를 통해 선언한 경우와 비슷하다고 생각됩니다. 수정이 필요할 경우, 수정이 필요한 파라미터의 한 줄만 수정하면 됩니다. 함수를 호출할 때도 마찬가지로 후행 comma를 사용할 수 있습니다.12345678910111213function tailingComma( param1, param2, param3,) &#123; console.log(`$&#123;param1&#125; $&#123;param2&#125; $&#123;param3&#125;`);&#125;tailingComma( 'hello', 'es8', 'world',); Async functions이미 많이 들 사용하고 계실거라 생각됩니다만 ES8부터 공식 release되었습니다. 간단한 예제로만 설명하고 넘어갑니다 :)123456789101112131415161718192021222324252627282930const fetchData = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('fetch complete!'); &#125;, 2000); &#125;);&#125;;console.log(`before`);fetchData().then((data) =&gt; console.log(data));console.log(`after`);// console&gt;// before// after// fetch complete!// Use Async functionconst sayComplete = async () =&gt; &#123; const message = await fetchData(); console.log(`status: $&#123;message&#125;`);&#125;console.log(`before`);sayComplete();console.log(`after`);// console&gt;// before// after// status: fetch complete! 감사합니다 :) Reference https://hackernoon.com/es8-was-released-and-here-are-its-main-new-features-ee9c394adf66 async function tip MDN Object.getOwnPropertyDescriptor() MDN Object.getOwnPropertyDescriptors()","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"ecma","slug":"ecma","permalink":"https://jaeyeophan.github.io/tags/ecma/"}]},{"title":"[React] 3. Props and State in Component","slug":"React-3-Props-and-State-in-Component","date":"2017-06-13T02:23:14.000Z","updated":"2017-06-13T02:23:39.000Z","comments":true,"path":"2017/06/13/React-3-Props-and-State-in-Component/","link":"","permalink":"https://jaeyeophan.github.io/2017/06/13/React-3-Props-and-State-in-Component/","excerpt":"","text":"[React] 3. Props and State in ComponentReact Component에는 props라는 것이 존재합니다. propsProps은 컴포넌트가 가지고 있는 속성으로 컴포넌트 내부에서는 this.props.[xxx]와 같은 형식으로 접근할 수 있는 것을 말합니다. Props은 외부에서 컴포넌트로 전달하는 값이기 때문에 컴포넌트 내부에서 전달받은 props을 변경해서는 안됩니다. 즉 Props은 immutable한 속성을 갖고 있습니다. Use Props함수로 작성된 Component의 경우와 class 문법으로 작성된 Component의 경우, 두 가지에 대해서 props를 살펴봅니다.12345678function App(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;ReactDOM.render( &lt;App name=\"Jbee\" /&gt;, document.getElementById('root')); Component 외부(해당 Component를 사용하는 Component 또는 render 메소드)에서 name이라는 속성을 props라는 객체를 통해 전달할 수 있습니다. 함수로 작성된 Component에서는 파라미터를 통해 props를 전달받아 이를 내부에서 사용할 수 있습니다. ES6의 destructuring 문법을 사용하면 다음과 같이 사용할 수 있습니다.12345678function App(&#123;name&#125;) &#123; return &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;;&#125;ReactDOM.render( &lt;App name=\"Sara\" /&gt;, document.getElementById('root')); class 문법을 사용하여 Component를 정의하는 경우에는 constructor를 통해 props를 받아 사용할 수 있습니다.1234567891011121314class App extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return &#123; &lt;div&gt;Hello! &#123;this.props.name&#125;&lt;/div&gt; &#125; &#125;&#125;ReactDOM.render( &lt;App name=\"Jbee\"/&gt;, document.getElementById('root')); constructor(props)내부에 super(props)이 부분이 보이시나요? 이 부분을 빠뜨리면 에러가 발생합니다. ES6 문법에서도 어떠한 클래스를 상속받은 다음 super를 호출해주지 않으면 에러가 발생하는데요, 그와 같은 원리라고 생각하시면 됩니다. TypeChecking to Props컴포넌트가 외부와의 데이터를 주고 받기 위해 props를 사용했는데요, 이럴 경우 props의 Type을 확인해줘야 하는 필요성이 생깁니다. (물론 애플리케이션의 크기가 작을 때는 props를 주고 받는 것이 한 눈에 보이기 때문에 필수적이지는 않습니다. 하지만 정적 언어를 주로 사용하셨던 분들에게는 적지 않은 찝찝함이 남아있을 거라생각합니다.) 이러한 니즈를 충족시키기 위해 기존에는 React.PropTypes라는 방식을 사용했지만 React v15.5 부터 prop-types라는 npm을 통해 해결합니다. Facebook에서 개발한 Flow를 사용하는 방법도 존재하고, MS의 TypeScript를 사용하는 것도 한 가지 방법이겠습니다 :) 기존의 방식과 npm을 설치하는 방법은 import 구문이 추가되는 것을 제외하고 모두 동일합니다.App Component에서 받는 props에 대한 TypeChecking 예제 코드입니다.12345App.propTypes = &#123; title: React.PropType.string, author: React.PropType.string.isRequired onSubmit: React.PropType.func&#125; 기존의 React에 포함되어 있는 PropType을 사용하는 경우에는 위와 같이 사용하면 됩니다. 필수적으로 요구하는 값에 대해서는 isRequired라는 속성을 더해줍니다. (포스팅을 작성하는 시점에서는 경고 메시지만 로그로 찍힐 뿐 실행에는 문제가 없습니다.) Prop-Types npm 설치는 다음과 같습니다.123$ npm install --save prop-types# or$ yarn add prop-types 그리고 해당 npm을 import하여 사용할 수 있습니다.123456import PropTypes from 'prop-types';App.propTypes = &#123; title: PropType.string, author: PropType.string.isRequired, onSubmit: PropType.func&#125; Prop-Typenpm에서는 다음과 같은 Type들을 제공합니다.array, bool,func,number,object,string,symbol,node,element또한 다음과 같은 메소드를 제공하여 보다 강력한 TypeChecking을 제공합니다.instanceOf(),oneOf([[array]]),oneOfType([[array]]) etc…보다 더 자세한 내용은 다음 링크를 참고하시면 됩니다. reactjs/prop-types Set Default PropsComponent에서 외부로부터 받기로 한 props가 전달되지 않았을 경우를 대비해 props에 대한 default value도 지정해줘야 합니다. default props를 지정하는 것은 props의 type을 check하는 것과 매우 유사합니다.12345App.defaultProps = &#123; title: \"unknown\", author: \"unknown\", onSubmit: () =&gt; console.warn('onSubmit function is not defined!')&#125; 각 타입에 맞는 적절한 default value를 설정해줄 수 있습니다. propType을 통해 정의한 type은 defaultProps에도 적용됩니다. StateComponent 내부에서 관리해야하는 상태 값이 존재하는 경우 state를 통해 관리할 수 있습니다. 이 state는 constructor() 내부에서 정의할 수 있습니다.12345678class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isSelected: false &#125; &#125;&#125; 위의 예제 코드와 같이 Object로 state를 관리할 수 있습니다. state를 업데이트할 경우에는 Component의 .setState()라는 메소드를 사용할 수 있습니다.123456789101112class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isSelected: false &#125; this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(&#123;isSelected: true&#125;); &#125;&#125; Component의 .setState()메소드를 사용하는 메소드를 만들었습니다. Component의 메소드를 JSX 구문에서 사용하기 위해서는 constructor내부에서 this를 binding해줘야 합니다. 해당 메소드를 실행하는 시점에서 메소드 내부에 정의된 this가 달라지기 때문입니다. .setState()에 대해서 추가적으로 반드시 알아둬야 하는 부분이 있습니다. 바로 이 메소드는 비동기로 호출된다는 점입니다. 즉 일반 메소드처럼 콜스택에 추가되어 호출되는 것이 아니라 이벤트 큐로 들어가게 됩니다. 메소드를 호출할 때 이 부분을 유의하여 작성해야 합니다 :) 마무리외부, 즉 상위 컴포넌트에 의해 값이 변경될 수 있는 경우에 대해서는 props를 통해 해결하고 이 props는 해당 컴포넌트에서 변경해서는 안됩니다. 컴포넌트 내부에서 변경될 수 있는 값에 대해서는 state를 통해 해결합니다. React와 관련된 포스트는 Github Repository에서 실시간 피드를 받으실 수 있습니다. Reference&gt;https://facebook.github.io/react/docs/components-and-props.htmlhttps://facebook.github.io/react/docs/typechecking-with-proptypes.html","categories":[{"name":"React","slug":"React","permalink":"https://jaeyeophan.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://jaeyeophan.github.io/tags/React/"}]},{"title":"[ES6] 13. Map, WeakMap","slug":"ES6-13-Map-WeakMap","date":"2017-06-05T05:44:56.000Z","updated":"2017-06-07T04:35:48.000Z","comments":true,"path":"2017/06/05/ES6-13-Map-WeakMap/","link":"","permalink":"https://jaeyeophan.github.io/2017/06/05/ES6-13-Map-WeakMap/","excerpt":"","text":"[ES6] 13. Map, WeakMap APIMap Object아시다시피, Map오브젝트는 key-value의 자료구조입니다. 기존 자바스크립트의 Object도 마찬가지로 key-value형식으로 구성되는데요, Map오브젝트는 key로 사용될 수 있는 타입이 다양하다는 것이 다른 점이라고 할 수 있습니다. 또한 Map오브젝트는 Object 오브젝트와는 달리 이터러블 오브젝트입니다. 그렇기 때문에 for-of statement를 사용하여 순회할 수 있습니다. Map오브젝트는 새로 추가되는 값의 key와 기존에 저장되어 있던 데이터의 key의 값이 동일하면 추가되지 않습니다. Java에서의 Map은 key를 hash값으로 저장하기 때문에 동일한 hash 값에 대해서 추가하지 않는데요, JavaScript에서는 조금 다른 방식으로 이를 판단합니다. key와 value가 저장될 때, 엔진이 별도의 일련 번호를 부여하여 이를 판단하게 됩니다. 또한 이 일련번호로 추가된 순서를 보장해줍니다. 다음과 같이 정리할 수 있겠습니다. 다양한 타입으로 key를 정의할 수 있다. 이터러블 오브젝트(iterable object)이다. 중복된 key를 추가할 수 없다. 중복된 key를 통해 추가하는 경우 해당 key의 value를 덮어쓴다. 즉 기존 key의 순서를 유지한다. 순서를 보장하는 자료구조이다. Notice예제 코드의 길이을 줄이기 위해 Map의 key와 value를 확인하기 위한 함수를 정의해두고 사용하겠습니다 :)utils.js1234567function printMap(map) &#123; for (let [key, value] of map) &#123; console.log(`key: $&#123;key&#125;, value: $&#123;value&#125;`); &#125;&#125;// Expected console// key: something, value: something Map은 이터러블 오브젝트이기 때문에 [key, value]형식으로 값을 받아서 사용할 수 있습니다.물론 다음과 같이 함수를 정의할 수도 있습니다.12345678function print(map) &#123; for (let item of map) &#123; console.log(Array.isArray(item));//true console.log(item); &#125;&#125;//Expected console// [ 'something', 'something' ] for-of statement에서 추출된 item은 Array입니다. 따라서 console에도 Array 타입으로 찍힙니다. new Map()Map 오브젝트는 다음과 같이 생성가능합니다.1234567891011let newMap = new Map([ ['1', 'one'], ['2', 'two'], ['3', 'three']]);printMap(newMap);// console// key: 1, value: one// key: 2, value: two// key: 3, value: three Map.prototype.set(), get()key와 value를 설정합니다. set() 메소드의 반환 값은 set() 메소드를 호출한 Map입니다. 그래서 chaining처럼 연속적으로 key와 value를 설정해줄 수 있습니다. get()메소드는 인자로 넘겨간 key값과 일치하는 value를 반환합니다.12345678910111213let webs = new Map();webs.set('1', 'React') .set('2', 'Angular2') .set('3', 'Vue') .set('2', 'Redux');printMap(webs);console.log(`webs.get('1'): $&#123;webs.get('1')&#125;`);// console// key: 1, value: React// key: 2, value: Redux// key: 3, value: Vue// webs.get('1'): React Map.prototype.entries(), keys(), values()각각 해당하는 이터레이터 오브젝트를 반환하는 메소드입니다. Map.prototype.has().has()는 파라미터로 전달되는 key에 해당하는 값이 존재하는지에 대한 여부를 boolean으로 반환합니다.12console.log(webs.has('1'));//trueconsole.log(webs.has('4'));//false Map.prototype.delete(), clear().delete()메소드의 파라미터로 특정 key값을 넘겨주면 해당 key와 value가 map에서 삭제됩니다. .clear()는 모든 key와 value를 삭제합니다.12345678910111213console.log(webs.size);// 3webs.delete('1');console.log(webs.size);// 2printMap(webs);// console// key: 2, value: Redux// key: 3, value: Vuewebs.clear();console.log(webs.size);// 0printMap(webs);// console// undefined Map.prototype.forEachforEach의 파라미터로는 콜백 함수를 넘겨줍니다.12345678webs.forEach((value, key, obj) =&gt; &#123; console.log(`key: $&#123;key&#125;, value: $&#123;value&#125;`);&#125;);// console// key: 1, value: React// key: 2, value: Redux// key: 3, value: Vue 넘겨지는 콜백 함수에는 세 가지 인자가 전달될 수 있습니다. key, value의 순서가 조금 다르다는 것에 주의하면 되겠네요. 세 번째 인자로는 콜백 함수 내부에서 this로 참조할 오브젝트가 전달됩니다. WeakMap ObjectWeakMap 오브젝트의 key에는 Object만 지정될 수 있습니다. GC와의 연관성key로 사용하고 있던 Object 오브젝트가 메모리에서 사라질 경우, 즉 GC에 의해서 Garbage Colleting이 되면, 더이상 value의 key로서 역할을 수행하지 못합니다. 그렇기 때문에 이 key에 대한 내용을 삭제해줘야 한다. 메모리에서 사라진 key에 대해서 삭제하는 작업을 WeakMap을 사용하면 자동으로 해결됩니다. APIset(), get(), has(), delete() 이 네 가지 API만 제공할 뿐, 열거를 위한 API는 제공하지 않습니다. 또한 size 프로퍼티가 존재하지 않기 때문에, 특정 시점의 [key, value]의 수를 알 수 없습니다. 이는 WeakMap 자체적으로 key를 제거하므로 값이 비결정적이기 때문에 API를 통해 제공되지 않습니다. cf) Set 자료구조는 Map자료구조의 key에 value가 들어가게 되는 자료구조 입니다. 그러므로 Map과 거의 유사한 API를 제공하며 저장하는 방식의 차이만 존재합니다. 마찬가지로 Set과 WeakSet은 Map과 WeakMap의 관계와 동일합니다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 13. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[React] 2. Elements and Component","slug":"React-2-Elements-and-Component","date":"2017-05-19T05:02:02.000Z","updated":"2017-05-19T05:12:09.000Z","comments":true,"path":"2017/05/19/React-2-Elements-and-Component/","link":"","permalink":"https://jaeyeophan.github.io/2017/05/19/React-2-Elements-and-Component/","excerpt":"","text":"[React] 2. Elements and ComponentElementElement는 화면에 표시되는 내용이며, React를 구성하고 있는 가장 작은 블록이라고 할 수 있습니다. 브라우저 요소인 DOM과 달리 React Element는 보다 적은 비용으로 생성할 수 있으며 React DOM은 React Element와 일치하도록 DOM을 업데이트 합니다. Rendering Elements12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 위와 같은 html 코드가 존재합니다. 실제로 존재하는 코드는 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;뿐이라고 볼 수 있습니다. React에서는 이것을 루트 노드(Root DOM node)라고 부릅니다. 이 태그 내부의 모든 element들은 React DOM에 의해 관리됩니다. 이전 포스팅에서 다뤘던 예제 코드를 다시 한번 살펴볼 차례입니다.1234const element = ( &lt;h1&gt;Hi!&lt;/h1&gt;);ReactDOM.render(element, document.getElementById('root')); 루트 노드를 select하여 내부에 작성한 element를 render할 수 있습니다. Immutable ElementReact element는 immutable입니다. element 렌더링한 후에는, 해당 element의 자식이나 attribute를 변경할 수 없습니다. React에서는 새로운 element를 전달하여 UI를 업데이트할 수 있습니다. 뭔가 너무 비효율적으로 보이지 않나요? 만약에 렌더링 된 element가 위의 예제처럼 짧지 않고 엄청 긴 element인데, 모든 element를 새로 전달해야 한다니. 하지만 React는 필요한 부분만 업데이트 합니다! React DOM은 새로 전달받은 element와 그 자식들을 이전의 element들과 비교하여 업데이트가 필요한 부분만 업데이트 합니다. 다음은 공식 홈페이지에 올라온 예제 코드입니다. 1초마다 ReactDOM.render()를 호출하여 UI를 업데이트합니다.1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById('root') );&#125;setInterval(tick, 1000); 개발자 도구를 열어서 확인해보면 {new Date().toLocaleTimeString()}부분만 업데이트 되는 것을 확인하실 수 있습니다. ComponentsComponent는 Element로 구성될 수 있습니다. React에서는 Component를 설계하고 이를 사용하여 UI를 독립적이고 재사용 가능한 부분으로 분할할 수 있습니다. Component 정의Component는 ES6의 class문법을 사용하여 정의할 수 있고 React.createClass 문법을 통하여 정의할 수 있고, stateless한 Component에 대하여 functional Component 방식으로 정의할 수 있습니다. class문법을 사용하여 React.Component를 extends 하는 방식으로 컴포넌트를 정의.12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello React World!&lt;/h1&gt;; &#125;&#125; 일반 함수(or Arrow function)를 사용하여 컴포넌트를 정의React 공식 문서에서는 stateless functional component라는 용어로 해당 컴포넌트를 설명하고 있습니다. 개발자들 사이에서는 Pure Component, Dumb Component, Presential Component 라고 불리기도 합니다. UI를 구성하게 되는 Component 중 state가 없거나 LifeCycle API를 사용할 일이 없는 경우 함수를 사용하여 정의합니다. 즉, 렌더링의 역할만 수행하는 컴포넌트를 정의할 때 사용하는 방식이라고 할 수 있습니다. 12345import React from 'react';const dumb = () =&gt; ( &lt;div&gt;...&lt;/div&gt;);export default dumb; 위와 같이 Arrow function을 사용할 수도 있지만 일반 함수를 사용하는 경우에는 함수의 이름을 추론할 수 있기 때문에 airbnb convention에서는 다음과 같은 일반 함수 방식을 권장하고 있습니다.123function dumb() &#123; return &lt;div&gt;...&lt;/div&gt;;&#125; Functional Component에 대해 자세히 설명된 포스팅입니다.Velopert-함수형 컴포넌트 React.createElement()를 사용하여 컴포넌트를 정의사실 JSX로 작성된 element 또는 Component는 React.createElement()로 컴파일됩니다. React에서 일종의 sugar syntax를 제공하는 셈입니다. 즉 1번 case의 예제 코드는 다음과 같이 컴파일됩니다.12345class Hello extends React.Component &#123; render() &#123; return React.createElement('div', null, `Hello React World`); &#125;&#125; 물론 위 코드도 babel에 의해 ES5 문법으로 transpile되겠지만 그 결과는 생략했습니다. 저번 포스팅에서도 언급된 airbnb 에서 제공하는 React convention에서는 JSX를 사용하고 있는데, 특별한 사유가 없다면 위 구문을 사용하지 말라고 합니다. 정의된 컴포넌트는 ReactDOM에서 render하거나 Component를 정의할 때 사용(composition)할 수 있습니다.12345678class App extends Component &#123; render() &#123; return ( &lt;Hello/&gt; ); &#125;&#125;ReactDOM.render(&lt;App/&gt;, document.getElementById('root')); 혹시 위 예제와 이전 예제에서 차이점을 발견하셨나요? 일부러 다르게 작성해보았습니다. 달라진 점은 바로 extends하고 있는 클래스가 달라진 점인데요, 이 부분은 어떻게 React 라이브러리를 import하느냐에 따라 달라질 수 있습니다. 바로 위의 예제 같은 경우에는 다음과 같이 import하여 사용할 수 있습니다.1import React, &#123; Component &#125; from 'react'; Component만 import하지 않고 React까지 import하는 것은 바로 React.createElement()로 컴파일 되기 때문입니다. 마찬가지의 이유로 일반 함수로 Component를 정의할 때도 React를 import해줘야 합니다. React.Component보다는 Component만 extends하는 것이 타이핑도 줄고 더 깔끔하겠죠? 물론 snippet이 제공되서 직접 타이핑 할 필요는 없지만요 :) Element에 대해서 그리고 Component를 어떻게 정의하는가에 대한 포스팅이었습니다. 감사합니다 :D React와 관련된 포스트는 Github Repository에서 실시간 피드를 받으실 수 있습니다. Reference&gt;https://facebook.github.io/react/docs/react-without-jsx.html 2. end","categories":[{"name":"React","slug":"React","permalink":"https://jaeyeophan.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://jaeyeophan.github.io/tags/React/"}]},{"title":"[Tool] (번역)Babel에 대한 모든 것","slug":"Everything-about-babel","date":"2017-05-16T03:04:26.000Z","updated":"2017-05-16T03:06:37.000Z","comments":true,"path":"2017/05/16/Everything-about-babel/","link":"","permalink":"https://jaeyeophan.github.io/2017/05/16/Everything-about-babel/","excerpt":"","text":"[Tool] (번역) Everything you need to know about BabelJS원본 : http://kleopetrov.me/2016/03/18/everything-about-babel/이 글은 위 글을 기반으로 하여 나름 최신으로 업데이트하며 작성되었습니다 :) 물론, 본 저자의 동의하에 작성되었습니다. babelBabel은 아시다시피 ES6/ES7 코드를 ECMAScript5 코드로 transpiling 하기 위한 도구입니다. Babel은 다양한 작은 모듈들로 구성되어 있습니다. Babel 다양한 모듈을 담는 일종의 상자 역할을 하며 코드를 컴파일 하기 위해 작은 모듈들(ex. presets)을 사용합니다. Set upbabel 학습을 위한 디렉토리를 구축합니다.1234$ mkdir babel-tutorial &amp;&amp; cd babel-tutorial$ npm init$ mkdir src &amp;&amp; touch src/example.js# Write some code of ES6 syntax in example.js bael-clibael-cli는 command line을 통해 코드를 transpile 할 수 있는 도구입니다.123$ npm install --save-dev babel-cli# or$ yarn add -D babel-cli -g 옵션을 통해서 bael-cli를 전역에 설치할 수도 있지만 --save-dev 옵션으로 설치하는 이유는 하나의 컴퓨터에 존재하는 다른 프로젝트들이 각각 다른 버전의 babel에 의존성을 갖고 있을 수 있습니다. --save-dev 옵션을 통해서 이를 해결할 수 있습니다. 설치한 후 터미널에서 다음 명령을 실행할 수 있습니다.1$ babel example.js --out-file compiled.js 이 명령어는 다음과 같은 의미를 담고 있습니다. babel - babel을 호출합니다. example.js - transpile 하고자하는 ES6/ES7의 자바스크립트 파일입니다. --out-file - babel에게 전달할 옵션을 명시합니다. 파일로 output을 지정하는 옵션입니다.cf1&gt; shortcut으로 -o 옵션을 제공합니다.cf2&gt; 이 이외에도 --out-dir or -d 옵션을 전달할 수 있습니다. compiled.js - 출력 파일의 이름을 명시합니다. npm script를 사용하여 해당 프로세스를 자동화 할 수 있습니다.package.json1234567&#123; ... \"scripts\": &#123; \"build\": \"babel ./src -d ./lib -w\" &#125; ...&#125; and1$ npm run build src 디렉토리 밑에 있는 파일을 transpile하여 lib 디렉토리 밑으로 output을 출력합니다. 이 때는 동일한 파일명이 사용됩니다. -w 옵션을 통해서 src 디렉토리 밑의 파일들이 변경될 때마다 자동으로 transpile 하도록 할 수 있습니다. babel-registerbabel-register는 각각의 모듈을 결합할 때 사용되는 후크(Hook) 모듈입니다. require 메소드를 바인드하여 자바스크립트 코드를 transpile 시킵니다. babel-register 모듈은 production을 위한 모듈은 아닙니다. 예를 들어 mocha 기반의 ES6로 작성된 테스트 코드를 실행시키기 위해서는 다음과 같은 스크립트를 사용할 수 있습니다.package.json123\"script\": &#123; \"test\": \"mocha --require babel-register\"&#125; Configuring Babel처음에도 말했듯이, babel에게 어떠한 정보를 전달해주지 않는 한 babel은 아무 작업도 수행하지 않는 ‘상자’에 불과합니다. 방금 전에 살펴봤던 예제에서 아무 옵션없이 babel을 실행시키면 src 디렉토리에 있는 파일을 lib 디렉토리에 옮기는 작업만 수행하게 됩니다. 그렇기 때문에 babel에게 설정 정보를 전달해줘야 합니다. 이 정보는 .babelrc파일을 통해서 전달할 수 있습니다. .babelrc.babelrc파일은 babel을 설정하기 위한 파일입니다. 다음과 같이 구성되어 있습니다..babelrc1234&#123; \"presets\": [], \"plugins\": []&#125; presets를 추가하기 위해서는 npm 설치가 필요합니다.1$ npm install --save-dev babel-preset-es2015 만약 React code를 transpile해야 한다면 다음과 같이 설치해줍니다.1$ npm install --save-dev babel-preset-react 그리고 .babelrc파일을 수정해줍니다..babelrc1234&#123; \"presets\": [\"es2015\", \"react\"], \"plugins\": []&#125; 자바스크립트 스펙으로 아직 확정되지 않은 proposal 스펙들이 존재합니다. 이들은 5개의 stage로 구분됩니다. babel에서는 각각의 stage에 대해서 preset을 제공합니다. babel-preset-stage-0 babel-preset-stage-1 babel-preset-stage-2 babel-preset-stage-3 babel-preset-stage-4는 babel-preset-es2015를 의미합니다. 각각의 stage에 대해서도 위와 같은 방법으로 설치하고 .babelrc파일을 수정하여 사용할 수 있습니다. 하지만 babel에서 이들을 모두 한번에 사용할 수 있도록 해주는 preset을 하나 제공했는데요, 바로 babel-preset-env입니다. 이 preset으로 모든 stage를 대체할 수 있습니다. babel-polyfillbabel-polyfill은 ES6 환경을 제공해줍니다.polyfill이 없는 경우를 예제를 통해 살펴봅니다.ES612function allAdd() &#123; return Array.from(arguments).map(a =&gt; a + 2); 위 코드는 babel에 의해 다음과 같이 transpile됩니다.ES512345function allAdd() &#123; return Array.from(argument).map(function(a) &#123; return a + 2; &#125;);&#125; Array.from()은 ES6 syntax이므로 지원하지 않는 브라우저가 존재하기 때문에 위 코드는 transpile은 되었지만 모든 브라우저에서 작동하지 않습니다. 이 문제를 해결하기 위해서 polyfill을 사용해야 합니다. polyfill이란 code 조각으로 런타임에 존재하지 않는 native API의 복사본을 말합니다. babel-polyfill 사용을 위해서 다음과 같이 npm을 설치해줍니다.1$ npm install --save-dev babel-polyfill 그리고 해당 polyfill이 필요한 곳에서 import해줍니다.1import 'babel-polyfill'; 만약 webpack과 함께 사용한다면 entry point에 babel-polyfill을 추가해줍니다.webpack.config.js1234module.exports = &#123; entry: ['babel-polyfill', '...'] ...&#125;; babel-plugins아직 공식 스펙에서 지원하지 않은 기능들을 transform-plugin을 추가하여 사용할 수 있습니다. 여러 플러그인은 babel 공식 홈페이지에서 확인실 수 있습니다. 추가로 설치한 플러그인은 plugins 옵션으로 추가할 수 있습니다. .babelrc파일에서 설정해줄 수도 있고 Webpack이란 도구에서도 설정해줄 수 있습니다. 주로 Webpack이라는 도구와 함께 사용하는 babel에 대해서 알아봤는데요, webpack과 함께 사용하는 것에 대해서는 Webpack2 입문 가이드 포스팅에 자세히 나와있습니다 :) end Referencehttps://babeljs.io/docs/plugins/http://kleopetrov.me/2016/03/18/everything-about-babel/","categories":[{"name":"Tool","slug":"Tool","permalink":"https://jaeyeophan.github.io/categories/Tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://jaeyeophan.github.io/tags/tool/"}]},{"title":"[React] 1. Introducing JSX and DOM","slug":"React-1-Introducing-JSX-and-DOM","date":"2017-05-15T04:15:27.000Z","updated":"2017-05-15T04:17:05.000Z","comments":true,"path":"2017/05/15/React-1-Introducing-JSX-and-DOM/","link":"","permalink":"https://jaeyeophan.github.io/2017/05/15/React-1-Introducing-JSX-and-DOM/","excerpt":"","text":"[React] 1. Introducing JSX and DOMJSX란 무엇인가1const element = &lt;h1&gt; Hello, world!&lt;/h1&gt;; JSX라고 불리는 이 구문은 string도 아니고 HTML도 아닙니다. React 라이브러리에서 UI를 구성할 때 사용하는 구문으로 JavaScript의 extension이라고 할 수 있습니다.(물론, 사용하지 않을 수도 있습니다.) 타 프레임워크에서 사용했던 템플릿 엔진이라고 불리는 것들과 유사한 문법을 취하며(생김새만), JavaScript의 모든 기능을 제공합니다. JSX에 표현식 포함하기자바스크립트의 표현식을 {}으로 묶어 JSX에 삽입할 수 있습니다. 기존의 템플릿 엔진에서 사용했던 방법과 비슷합니다. ES6에서 도입된 Template literal과도 비슷한 모습을 보입니다. 코드를 살펴보겠습니다.12345const element = ( &lt;h1&gt;Hi!&lt;/h1&gt;);ReactDOM.render(element, document.getElementById('root'));//이 코드는 다음 포스팅에서 설명하며, 다음 예제 코드부터는 추가하지 않습니다. 위와 같이 element라는 객체를 만들어서 render()메소드에 전달하여 렌더링할 수 있습니다.123const element = ( &lt;h1&gt;1 + 1 = &#123;1 + 1&#125;&lt;/h1&gt;); {}내부에서 자바스크립트 문법을 그대로 사용할 수도 있습니다. JSX는 결국 표현식입니다.컴파일이 끝나면 JSX 표현식은 일반 자바스크립트 객체가 됩니다.1234let url = \"api/get/someting\";const element = ( &lt;img src=&#123;url&#125; /&gt;); JSX로 HTML 태그의 속성 값을 지정하고자 할 때는 &quot;&quot;(double quote)를 사용하지 않습니다. 사용하게 되면 JSX는 속성을 표현식이 아닌 문자열 리터럴로 인식하게 됩니다. 위 img태그의 경우처럼 태그가 비어있으면 /&gt;로 바로 닫아줘야 합니다. 자식 컴포넌트가 없거나 한 줄로 element 작성이 끝나는 경우에는 닫힘 태그로 self-close를 해줍니다.123456const element = ( &lt;div&gt; &lt;h1&gt;Hi&lt;/h1&gt; &lt;h2&gt;1 + 1 = &#123;1 + 1&#125;&lt;/h2&gt; &lt;/div&gt;); 위의 같은 경우처럼 HTML의 문법을 사용하여 태그들을 계층화하여 구성할 수 있습니다. 하지만 이 때 주의할 사항이 한 가지 있습니다. 반드시 루트 노드(Root Node)로 하나의 노드를 지정해야 한다는 것입니다. ReactDOM은 오직 하나의 루트 노드만 렌더링하기 때문에 다음의 경우는 렌더링하지 못합니다.12345//Error!const element = ( &lt;h1&gt;Hi&lt;/h1&gt; &lt;h2&gt;1 + 1 = &#123;1 + 1&#125;&lt;/h2&gt;); 동일 depth에 존재하는 element가 여러 개 존재하기 때문에 error가 발생하게 됩니다. 여러 개의 element들을 계층화하는 경우에는 이전의 예제 코드처럼 element들을 div태그로 감싸줘야 합니다. 기본적으로 React DOM은 렌더링하기 전에 JSX에 임베디드 된 모든 값을 이스케이프 처리합니다. 따라서 응용프로그램에 명시적으로 작성되지 않은 것을 삽입할 수 없고 XSS 공격을 방지할 수 있습니다. DOM ElementsReact는 성능과 크로스 브라우징 이슈를 해결하기 위해 브라우저로부터 독립적인 DOM 체계를 구축하고 있습니다. 그렇기 때문에 기존의 HTML 속성과 다른 점이 존재합니다. Camel-Case Attributes기본적으로 React에서는 모든 DOM 속성 또는 이벤트 핸들러를 Camel-case로 처리해야 합니다. 다른 Attributesstylestyle 속성은 camelCase를 기반으로 작성된 style JavaScript 객체로 설정합니다. 모든 DOM의 속성과 일치하여, 원래 CSS에서 사용하던 속성들을 camelCase로 변경해서 사용할 수 있습니다.12345678const headerStyle = &#123; backgroundColor: '#EEE'; borderRadius: '5px';&#125;;const element = ( &lt;div style=&#123;headerStyle&#125;&gt;Apply style as camelCase&lt;/div&gt;); className기본적으로 HTML에서는 태그에 class를 지정해줄 때, &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;와 같은 방식을 사용했습니다. 그러나 React에서는 className이라는 속성을 통해 접근합니다. 다음과 같이 나타낼 수 있습니다.1const container = (&lt;div className=\"container\"&gt;&lt;/div&gt;); cf&gt; JSX 속성값에는 항상 double quote를 사용합니다. JSX 속성값을 제외한 나머지 경우에 대해서는 single quote를 사용합니다. 강제적인 것이 아닌 airbnb 에서 제공하는 React convention 입니다. onChange이 속성을 가지고 있는 필드가 변경될 때마다 이벤트가 발생합니다. React에서는 실시간으로 사용자 입력을 처리하기 위한 방법으로 이벤트를 사용합니다.1&lt;input onChange=&#123;this.handleChange&#125;/&gt; 위 예제 코드에서는 input태그에 event가 발생할 때마다 handleChange라는 메소드가 호출됩니다. checkedinput태그 중 checkbox타입 또는 radio타입에서 지원되는 checked 속성입니다. 이 속성은 controlled components에 대해서 사용할 때 유용합니다. valuevalue 속성은 input과 textarea태그에 대해 지원되는 속성입니다. 이 속성을 통하여 요소의 값을 설정할 수 있습니다. 하지만 이 값은 DOM의 값보다 우선됩니다. 그렇기 때문에 이 속성은 controlled components에 대해서 사용할 때 유용합니다. 초기값만 지정하려는 경우에는. 즉 uncontrolled components에 대해서는 defaultValue 속성을 사용할 수 있습니다. defaultValue, defaultChecked&lt;textarea&gt;와 &lt;input type=&#39;text&#39;&gt;에 대해서 지원합니다. 또한 type=checkbox와 type=radio타입의 &lt;input&gt;태그에 대해서는 defaultChecked를 지원합니다.1234&lt;input type=\"text\" defaultValue=\"Jbee\" /&gt; htmlFor123456789const element = ( &lt;div&gt; &lt;label for='name'&gt;Name: &lt;/label&gt; &lt;input type='text'/&gt; &lt;/div&gt;);//\"Warning: Unknown DOM property for. Did you mean htmlFor?// in label// in div\" for를 대체하는 htmlFor입니다. for속성을 사용하려고 하면 warning이 발생합니다.123456const element = ( &lt;div&gt; &lt;label htmlFor='name'&gt;Name: &lt;/label&gt; &lt;input type='text'/&gt; &lt;/div&gt;); JavaScript 문법의 for 예약어와 겹치기 때문에 htmlFor가 생겨났습니다. dangerouslySetInnerHTML이 속성은 DOM에서 사용하던 innerHTML 속성을 대체하기 위해 만들어졌습니다. 코드에서 HTML을 설정하는 것은 XSS 공격에 노출되기 쉽기 때문에 위험합니다. 그렇기 때문에 React에서는 이 속성 사용을 최소화하기 위해 장치를 마련해놓은 것입니다.1234567function innerHTML() &#123; return &#123;__html: 'Dangerous inner html!'&#125;;&#125;function component() &#123; return &lt;div dangerouslySetInnerHTML=&#123;innerHTML()&#125; /&gt;;&#125; 그럼에도 불구하고 dangerouslySetInnerHTML 속성을 사용하려면 위의 예제 코드와 같이 __html이라는 키 값과 함께 객체를 전달하여 사용할 수 있습니다. React와 관련된 포스트는 Github Repository에서 실시간 피드를 받으실 수 있습니다. 1. end Reference&gt;React Documentation - Introducing JSXReact Documentation - DOM Elements","categories":[{"name":"React","slug":"React","permalink":"https://jaeyeophan.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://jaeyeophan.github.io/tags/React/"}]},{"title":"[ES6] 12. Array API","slug":"ES6-12-Array-API","date":"2017-05-11T05:22:30.000Z","updated":"2017-05-12T05:32:06.000Z","comments":true,"path":"2017/05/11/ES6-12-Array-API/","link":"","permalink":"https://jaeyeophan.github.io/2017/05/11/ES6-12-Array-API/","excerpt":"","text":"[ES6] 12. Array APIJavaScript의 Array가 제공하는 API들에 대해서 살펴봅니다. ! Array.[methodName] vs Array.prototype.[methodName]위 두 가지는 접근 방법이 다릅니다. 전자는 Array라는 오브젝트의 메소드이며 후자는 Array 타입의 모든 오브젝트에서 사용할 수 있는 메소드입니다. 간단한 예제를 통해 살펴보겠습니다.123456789const arr = [1, 2, 3];arr.from('jbee'); //Error: arr.from is not a functionfor (let item of arr.values()) &#123; console.log(item);&#125;//console//1//2//3 Array.from()과 Array.prototype.values() 둘 차이를 보여주는 예제였습니다 :D그럼 이제 Array API들에 대해 알아봅시다. Array.from() from()은 유사배열(Array-Like-Object)을 배열로 바꿔줍니다.1234const arrLikeObj = &#123;'0': 'zero', '1': 'one', '2': 'two', 'length': 3&#125;;const arrFrom = Array.from(arrLikeObj);console.log(arrFrom);//Array ['zero', 'one', 'two'] 이 방법을 통해 String을 Array로 변경할 수 있습니다.123const str = \"Jbee\";console.log(Array.from(str));//Array ['J', 'b', 'e', 'e']console.log(new Array(...str));//Array ['J', 'b', 'e', 'e'] ES6의 문법인 Spread 연산자를 사용해서도 가능합니다.from()을 다음과 같은 경우에 사용하면 유용할 것 같습니다.123456789const ul = document.getElementById('content');const ulClassList = ul.classList;console.log(ulClassList);//[\"content-list\", \"foo\", \"bar\", \"baz\", value: \"content-list foo bar baz\"]console.log(Array.isArray(ulClassList));//falseconst ulClassArr = Array.from(ulClassList);console.log(ulClassArr);//[\"content-list\", \"foo\", \"bar\", \"baz\"]console.log(Array.isArray(ulClassArr));//true DOM의 classList는 유사배열(Array-Like-Object)로 반환이 됩니다. 이것을 from()을 사용하여 배열로 변경하여 Array API를 사용할 수 있도록 바꿔줄 수 있습니다. from()의 두번째 인자로 콜백 함수를 넘겨줄 수 있습니다.12const arrLikeObj = &#123;'0': 100, '1': 101, '2': 102, 'length': 3&#125;;const arrFromWithCb = Array.from(arrLikeObj, elm =&gt; elm + 100); Array로 변경된 각각의 엘리먼트들을 elm으로 받아서 100을 더해줍니다.1console.log(arrFromWithCb);// [200, 201, 202] from()의 세번째 인자로는 두번째 인자로 넘겨준 콜백 함수에서 참조할 오브젝트를 넘겨줄 수 있습니다.1234const arrFromWithCb3 = Array.from(arrLikeObj, function(elm)&#123; return +elm + this.value&#125;, &#123;value: 200&#125;);console.log(arrFromWithCb3);//[300, 301, 302] this를 통해 참조하기 때문에 arrow function대신에 일반 함수를 사용하여 콜백 함수를 전달해줬습니다. Array.of()of()로 전달되는 파라미터 값을 배열로 반환합니다.123const arr = Array.of(1,2,3);console.log(Array.isArray(arr));//trueconsole.log(arr);//[1, 2, 3] 문자열도 Spread 연산자와 함께 사용하면 배열로 변환할 수 있습니다.1234const str = `Jbee`;const strArr = Array.of(...str);console.log(Array.isArray(strArr));//trueconsole.log(strArr);//['J', 'b', 'e', 'e'] Array.prototype.entries()Array 오브젝트의 iterator를 반환하는 메소드입니다.123456789const arr = [1, 2, 3];for (let item of arr) &#123; console.log(`$&#123;item&#125;`);//1 2 3&#125;for (let [ key, value ] of arr.entries()) &#123; console.log(`$&#123;key&#125; : $&#123;value&#125;`);//0:1 1:2 2:3&#125; key와 value는 각각 Array.prototype.keys(), Array.prototype.values()으로도 접근할 수 있습니다. Array.prototype.find()find() 파라미터로 콜백 함수를 넘겨서 처리한 내용을 반환합니다.123const arr = ['Jbee', 'babel', 'React']const result = arr.find(elm =&gt; elm.includes('e'));console.log(result);//'Jbee' e를 포함하고 있는 문자열은 &#39;Jbee&#39;, &#39;babel&#39;, &#39;React&#39; 모두 해당하는데 &#39;Jbee&#39;만 반환했습니다. find()는 콜백 함수로 넘겨진 조건이 true되는 순간 반환하기 때문에 그 다음은 확인하지 않습니다. Array.prototype.findIndex()을 통해서 value가 아닌 index를 반환하게 하는 API도 존재합니다. Array.prototype.filter()위 find()와는 다르게 다시 Array를 반환합니다.123const arr = ['Jbee', 'babel', 'React']const result = arr.filter(elm =&gt; elm.includes('e'));console.log(result);//'Jbee', 'babel', 'React' 전달받은 콜백 함수로 각 엘리먼트들의 조건을 판단하여 true인 엘리먼트들에 대해서만 Array를 반환합니다. Array.prototype.map()마찬가지로 다시 Array를 반환하는데, 배열의 엘리먼트에 접근하여 엘리먼트의 값을 reformat할 수 있습니다.123const arr = ['Jbee', 'babel', 'React']const result = arr.map((elm, i) =&gt; `$&#123;i&#125;: $&#123;elm&#125;`);console.log(result);// ['0: Jbee', '1: babel', '2: React'] 콜백 함수의 두번째 인자, i로 API를 호출한 배열의 인덱스에 접근할 수 있습니다. Array.prototype.reduce()배열의 각 값에 대해(0부터 arr.length 순서로) 넘겨받은 콜백 함수의 결과를 하나의 값으로 반환합니다.콜백 함수의 인자로는 총 네 가지를 받을 수 있습니다.previousValue, currentValue, currentIndex, array1234const result = [0, 1, 2, 3].reduce(function(previousValue, currentValue, currentIndex, array) &#123; return previousValue + currentValue;&#125;);console.log(result);// 6 arrow function을 사용하면 다음과 같습니다.12const result = [0, 1, 2, 3].reduce((pre, cur) =&gt; pre + cur);console.log(result); Array.prototype에서 제공하는 pop, push, splice, sort 등은 배열 자체를 변화시킵니다.concat, slice, join, indexOf 함수들은 새로운 배열을 반환합니다. Array.prototype.splice(), Array.prototype.slice()splice에 전달되는 인자는 startIndex, deleteCount, newItem 총 세 개입니다.Array.prototype.splice()1234const arr = [&#123;0: 'zero'&#125;, &#123;1: 'one'&#125;, &#123;2: 'two'&#125;];const result = arr.splice(0, 1, &#123;4: 'foour'&#125;);console.log(arr);// [&#123;4: 'foour'&#125;, &#123;1: 'one'&#125;, &#123;2: 'two'&#125;]console.log(result);// [&#123;0: 'zero'&#125;] slice에 전달되는 인자는 startIndex, deleteCount 총 두 개입니다.Array.prototype.slice()1234const arr = [&#123;0: 'zero'&#125;, &#123;1: 'one'&#125;, &#123;2: 'two'&#125;];const newArr = arr.slice(0, arr.length);console.log(arr);// [&#123;0: 'zero'&#125;, &#123;1: 'one'&#125;, &#123;2: 'two'&#125;]console.log(newArr);// [&#123;1: 'one'&#125;, &#123;1: 'one'&#125;, &#123;2: 'two'&#125;] is new Array 기존의 arr에는 변경사항이 존재하지 않고 새로운 Array 오브젝트가 반환된 것을 확인하실 수 있습니다. 마무리Array에서 제공하는 기본적인 메소드들에 대해서 알아봤습니다. 포스트에서 소개한 메소드 이외에도 여러 메소드들이 존재하는데요, 잘 사용하면 보다 깔끔한 코드를 작성할 수 있겠습니다 :) 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. Referencehttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splicehttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slicehttp://programmingsummaries.tistory.com/357 12. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"Webpack2, 입문 가이드 3편, Option","slug":"webpack-tutorial-3","date":"2017-05-08T08:06:52.000Z","updated":"2017-05-08T08:10:21.000Z","comments":true,"path":"2017/05/08/webpack-tutorial-3/","link":"","permalink":"https://jaeyeophan.github.io/2017/05/08/webpack-tutorial-3/","excerpt":"","text":"[Tool] Webpack2, 입문 가이드 3편, Option&gt; Webpack2, 입문 가이드 1편 &gt;&gt; Webpack2, 입문 가이드 2편 &gt; Config’s other options기본적인 네 가지 옵션, entry, output, module, plugin에 대해 알아봤습니다. 이번 포스팅에서는 좀 더 나아가 추가적인 옵션들도 살펴봅니다. devServer2편에서 HMR(HotModuleReplacement) 플러그인을 사용할 때 추가해줬던 webpack-dev-server와 관련된 옵션입니다. 여러 가지 추가 설정이 존재합니다.12345678devServer: &#123; hot: true, inline: true, port: 4000, compress: true, publicPath: '/dist/', contentBase: path.join(__dirname, '/dist/'),&#125; pulicPath: ‘/[dirname]/‘pulicPath를 지정해주지 않았다면 default path는 ‘/‘로 설정되어 있습니다. 그렇기 때문에 $ webpack-dev-server 명령어를 통해 실행하면 다음과 같은 메세지가 나타납니다.1$ webpack output is served from / 이것은 bundle된 결과 파일들이 http://localhost:[portNumber]에 served되었다는 것을 의미합니다. publicPath 설정으로 이를 지정할 수 있으며 그 값은 예제처럼 /로 둘러쌓여 있어야 합니다. 이 값을 따로 설정해주면 live reloading 기능이 기존의 url로는 안되겠죠? http://localhost:[portNumber]/[publicpath]/로 접근해야 예전처럼 live reloading 기능을 사용하실 수 있습니다. 이외에도 port, host, proxy 등 다양한 옵션들이 존재합니다. devServer와 관련된 다양한 옵션은 다음 링크에서 볼 수 있습니다. contextentry point에서 사용할 절대 경로(absolute path)를 지정할 때 사용합니다.1234const config = &#123; context: path.join(__dirname), [...]&#125; resolvereslove.aliaspath에 alias를 설정하여 모듈을 import할 때, 보다 간편히가 코드를 작성할 수 있습니다. 다음과 같은 import 구문이 있다고 가정해봅니다.app.js1import &#123; Utility &#125; from '../../../../utilities/utility'; 상대경로로 타고 타고 올라가서 해당 경로를 찾아야 하는 불편함이 존재합니다. 이를 해결하기 위해 alias를 사용하면 다음과 같은 코드로 재탄생합니다.webpack.config.js1234alias: &#123; Utilities: path.join(__dirname, 'src/utilities'); post$: path.join(__dirname, 'src/service/post.js')&#125; path를 마치 상수처럼 선언하여 프로젝트에서 사용할 수 있도록 해줍니다.app.js12import &#123; Utility &#125; from 'Utilities/utility';import post from 'post'; 디렉토리에 대해서 그리고 파일에 대해서 path를 지정했습니다. 위의 예제처럼 특정 파일에 대해서 alias를 생성할 때, 생성하고자 하는 alias 뒤에 $를 붙여주면 해당 path뒤로 추가적인 path를 설정할 수 없습니다. resolve와 관련된 다양한 옵션은 다음 링크에서 볼 수 있습니다. devtoolwebpack에서 제공하는 기술 중, SourceMaps이라는 기술이 있습니다. SourceMaps은 하나의 파일로 병합되거나 압축된 자바스크립트, CSS 파일을 원형으로 분리(path 구조까지)하여, 복원해주는 기술입니다.devtool 옵션은 SourceMaps을 생성할지 말지를 결정하는 옵션입니다. 에러가 발생할 때, 어느 부분에서 에러가 발생했는지 알아야 디버깅이 수월할텐데요, source map은 bundle된 코드에서 발생한 에러를 기존의 코드와 연결시켜주는 역할을 합니다. devtool에서 설정할 수 있는 옵션들에는 여러 가지가 존재하며 각각의 장단점이 존재합니다. devtool build rebuild production eval +++ +++ no cheap-eval-source-map + ++ no cheap-source-map + 0 yes cheap-module-eval-source-map 0 ++ no cheap-module-source-map 0 - yes eval-source-map - - + no source-map - - - - yes nosources-source-map - - - - yes https://webpack.js.org/configuration/devtool/ Webpack2 공식 홈페이지에서 소개하고 있는 devtool 옵션들입니다. +는 작업 속도가 빠르다는 것을 의마하며 -는 그 반대로 느린 것을 의미합니다. 이 많은 옵션 중에서 개발할 때 적합한 옵션은 무엇이고, 배포할 때 적합한 옵션은 무엇일까요? 개발 시에는 얼머나 용량을 줄이느냐보다 어디에서 에러가 발생했는지 알 수 있어야 하므로 로그가 상세히 나타나는 옵션을 선택해야하며 생산성을 높이기 위해 빌드 시간이 짧아야 합니다. 배포용은 용량이 우선적으로 작아야 겠죠? 저는 다음과 같이 정리해보았습니다. Option for development) cheap-module-eval-source-map inline-source-map eval-source-map Option for production) cheap-module-source-map 각 옵션들에 대한 상세한 내용은 링크를 첨부합니다.&gt; Webpack devtool source map&gt;&gt; (webpack) devtool 옵션 퍼포먼스&gt; env, EnvironmentPlugin환경에 따라 webpack이 수행해줘야 할 작업이 달라질 수 있습니다. 여기서 말하는 환경이란, 개발을 진행하는 과정에서 webpack 작업인지, 배포하는 과정에서의 작업인지로 구분할 수 있습니다. webpack이 작동하는 환경은 기본적으로 development라는 string value로 설정되어 있습니다.webpack.config.js1234new webpack.EnvironmentPlugin(&#123; NODE_ENV: 'development', DEBUG: false&#125;) bundle된 파일 전체에서 사용할 수 있는 상수를 만들어서 환경 변수로 사용할 수 있습니다. 이 때 DefinePlugin을 사용할 수 있습니다.1234new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV' : JSON.stringify(process.env.NODE_ENV), 'process.env.DEBUG' : JSON.stringify(process.env.DEBUG)&#125;) 특정한 환경을 위한 코드를 작성하는 경우, process.env.NODE_ENV를 통해 NODE_ENV의 값을 확인할 수 있습니다. 환경 변수의 값을 확인하는 작업은 성능 저하를 유발하므로 이러한 작업은 낮은 빈도로 실행해야 한다는 점에 주의하세오. 마무리이외에도 많은 옵션들이 존재합니다. Webpack 공식 홈페이지에서 확인하실 수 있습니다 :) 포스팅에서 사용된 예제 코드와 webpack tutorial 시리즈 전체는 Github repository에서 확인하실 수 있습니다 :D 3편 end ReferenceWebpack configurationWebpack devtool 옵션 퍼포먼스","categories":[{"name":"Tool","slug":"Tool","permalink":"https://jaeyeophan.github.io/categories/Tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://jaeyeophan.github.io/tags/tool/"}]},{"title":"Webpack2, 입문 가이드 2편: Plugins","slug":"webpack-tutorial-2","date":"2017-05-06T03:15:26.000Z","updated":"2017-05-08T08:11:43.000Z","comments":true,"path":"2017/05/06/webpack-tutorial-2/","link":"","permalink":"https://jaeyeophan.github.io/2017/05/06/webpack-tutorial-2/","excerpt":"","text":"[Tool] Webpack2, 입문 가이드 2편&gt; Webpack2, 입문 가이드 1편 &gt; Plugins플러그인을 통해 코드를 난독화(Uglify)하여 압축할 수 있고, 공통된 코드(Common chunk)를 분리할 수 있고, 코드의 변경사항을 파악하게 하여 자동으로 재실행시킬 수 있습니다. 이외에도 여러 가지 훌륭한 기능들이 존재하는데요, Webpack이 제공하는 플러그인과 외부 플러그인들 중에서 일부에 대해 알아봅니다. Webpack에 내장된 플러그인에는 webpack.[plugin-name]을 통해 접근할 수 있습니다. webpack.config.js12345678const webpack = require('webpack');const config = &#123; entry: [...], output: [...], module: [...], plugins: [...]&#125;module.exports = config; plugins에는 배열을 통하여 여러 플러그인을 설정할 수 있습니다. 1편에서와는 다르게 기본 구조에서 코드 한 줄이 추가되었는데요, webpack이 제공하는 플러그인을 사용하기 위해서 webpack이란 모듈을 불러와야 합니다. UglifyJsPluginwebpack을 통해 작업을 수행할 때, 코드를 압축하여 난독화시켜주는 플러그인입니다.1234567891011const config = &#123; [...] plugins: [ //new webpack.optimize.UglifyJsPlugin() new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;) ]&#125; UglifyJsPlugin은 optimize로 접근할 수 있습니다. config파일 설정을 마쳤으면 $ webpack 명령어를 수행해줍니다. 그리고 나서 dist/bundle.js 파일을 확인해봅니다. 코드가 한 줄로 알아볼 수 없게 압축되어 있는 것을 확인하실 수 있습니다 :) 해당 플러그인을 생성할 때, 파라미터로 옵션을 전달할 수 있습니다. 이 예제에서는 압축 시 발생할 수 있는 경고를 무시하는 옵션을 추가했습니다. CommonChunkPluginentry point가 여러 개 설정되어있는 경우, 공통된 모듈 또는 라이브러리를 별도의 chunk로 분리하여 bundle 작업을 수행할 때 사용할 수 있는 plugin입니다.12345678910const config = &#123; [...] plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: \"commons\", filename: \"commons.js\", minChunks: Infinity &#125;) ]&#125; name, filename, minChunks 세 가지 옵션만 설정해봤습니다. name은 생성될 chunk의 이름을 지정합니다. 생성될 파일의 이름인 filename을 설정하고 minChunks라는 옵션을 통해서 commons로 묶일 최소한의 module 개수를 설정할 수 있습니다. Infinity라는 설정값을 주면 공통으로 묶을 수 있는 모듈들을 모두 commons로 묶습니다. number or function을 지정하여 customize할 수 있습니다. 위 설정을 마치고 $webpack 명령어를 실행하게 되면 commons.js파일과 bundle.js파일 두 파일이 생성됩니다. 이를 index.html에서 로드를 할 때, 다음과 같이 commons.js파일을 먼저 로드해야 한다는 점 주의하시면 되겠습니다.12&lt;script src=\"./dist/commons.js\"&gt;&lt;/script&gt;&lt;script src=\"./dist/bundle.js\"&gt;&lt;/script&gt; 추가적인 다른 옵션은 다음 링크를 참고하시면 됩니다 :) ExtractTextPlugin이 플러그인은 따로 설치가 필요합니다.123$ npm install --save-dev extract-text-webpack-plugin# or$ yarn add -D extract-text-webpack-plugin webpack을 통해서 css를 로드하는 경우 발생하는 문제점은 js와 함께 로드된다는 것입니다. 기존에는 js와 따로 css만 로드되었습니다. 이 플러그인이 bundle되는 과정에서 js파일과 css파일을 분리해줍니다. 분리된 css bundle 파일은 병렬로 로드가 되어 사용자 입장에서는 더 빠르게 완성된 웹 페이지 화면을 볼 수 있게 됩니다.123456789101112131415161718const ExtractTextPlugin = require('extract-text-webpack-plugin');const config = &#123; [...] module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(\"styles.css\"), ]&#125; module 옵션에서 style-loader를 사용하는 설정 코드가 변경되었습니다. plugins 옵션에 해당 플러그인을 추가해주고 파라미터로 bundle된 output의 filename을 설정해줍니다. $ webpack 명령어를 실행해주면 dist 폴더에 styles.css파일이 생성된 것을 확인할 수 있습니다. 추가적인 다른 옵션은 다음 링크를 참고하시면 됩니다 :) HtmlWebpackPlugin따로 분리하여 bundle한 css파일과 js파일을 각각 html 파일에 link 태그와 script태그로 추가해줘야 합니다. 이 플러그인은 이것을 자동화해줍니다. 이 플러그인도 마찬가지로 따로 설치가 필요합니다.123$ npm install --save-dev html-webpack-plugin# or$ yarn add -D html-webpack-plugin 그리고 plugin에 추가해줍니다.12345678const HtmlWebpackPlugin = require('html-webpack-plugin');const config = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: './index.html' &#125;) ]&#125; template 옵션에는 해당하는 html파일의 패스를 입력해주시면 됩니다. $ webpack 명령어를 실행해주면 dist 폴더에 index.html파일이 생성되고 자동으로 bundle된 css파일과 js파일이 link태그와 script태그로 추가된 것을 확인하실 수 있습니다. !webpack에 의해서 자동으로 추가되므로 우리가 작성하는 html 파일에는 script태그와 link태그를 작성할 필요가 없습니다. 오히려 작성하면 두 번 load를 하게 되므로 성능상 좋지 않습니다. 사실 이 플러그인은 우리의 귀차니즘을 해결해주는 것보다 더 훌륭한 존재의 이유가 있습니다. 그것을 바로 caching할 때, bundle 작업의 결과물로 hash 값을 파일 명이 쓰게 되는데, 이 hash 값을 개발자가 예측할 수 없다는 것입니다. 그렇기 때문에 개발자가 추가하지 못하는 것을 webpack이 대신 해줍니다 :) (webpack에서의 caching에 대해서는 추후 포스팅에서 다룹니다.) 추가적인 다른 옵션은 다음 링크를 참고하시면 됩니다 :) HotModuleReplacementPluginHMR이라는 약자로도 많이 불리는 플러그인 입니다. 개발 생산성을 극대화(?)시켜주는 플러그인이라고 할 수 있습니다. 이 플러그인 없이 $ webpack-dev-server --watch 명령어를 실행하여 작업을 하고 저장을 해도 자동 reload가 안됩니다. 다음과 같이 추가해줍니다.123456const config = &#123; [...] plugins: [ new webpack.HotModuleReplacementPlugin(), ]&#125; 사실 이 플러그인을 추가해도 reload는 되지 않고 webpack 작업만 자동으로 실행됩니다. 웹 브라우저에 자동으로 reload를 시켜주려면 한 가지 설정이 추가적으로 필요합니다.1234567const config = &#123; [...] devServer: &#123; contentBase: './dist', hot: true &#125;&#125; $ webpack-dev-server --watch를 실행하고 js파일을 수정하고 저장을 해주면 자동으로 웹브라우저에 reload가 되는 것을 확인하실 수 있습니다! (devServer는 config에서 설정할 수 있는 또다른 옵션입니다.) NoEmitOnErrorsPlugin컴파일 도중 오류가 발생한 리소스들은 제외하고 작업을 진행하여 bundling하도록 합니다. 참고로 NoErrosPlugin은 deprecated되었습니다.1new webpack.NoEmitOnErrorsPlugin() 마무리이외에도 많은 플러그인들이 존재합니다. awsome-webpack에서 확인하실 수 있습니다 :)다음 포스팅에서는 config파일의 기본적인 옵션을 제외한 다른 옵션들에 대해 알아보겠습니다. :) 포스팅에서 사용된 예제 코드는 Github repository에서 확인하실 수 있습니다 :D 2편 end ReferenceWebpack PluginsWebpck official DOCSWebpck official CONCEPT","categories":[{"name":"Tool","slug":"Tool","permalink":"https://jaeyeophan.github.io/categories/Tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://jaeyeophan.github.io/tags/tool/"}]},{"title":"Webpack2, 입문 가이드 1편","slug":"webpack-tutorial-1","date":"2017-05-05T08:58:38.000Z","updated":"2017-05-05T09:38:28.000Z","comments":true,"path":"2017/05/05/webpack-tutorial-1/","link":"","permalink":"https://jaeyeophan.github.io/2017/05/05/webpack-tutorial-1/","excerpt":"","text":"[Tool] Webpack2, 입문 가이드 1편Webpack이란 무엇인가너무 유명해져서 더이상의 말은 필요없을 것 같습니다:) 이에 대해 잘 정리해놓은 문서도 정말 많구요! 이 포스팅에서는 webpack.config.js 파일의 구조에 집중할 예정입니다. 아래 Reference의 링크를 참고해주세요! Installation12345$ npm install -g webpack webpack-dev-server$ npm install --save-dev webpack webpack-dev-server# or$ yarn global add webpack webpack-dev-server$ yarn add -D webpack webpack-dev-server Webpack이 제공하는 기능 중 로컬에서도 사용해야 하는 플러그인이 존재하므로 로컬에도 설치해줍니다. 그리고 webpack의 결과물을 확인하기 위해 서버를 띄워야하므로 webpack-dev-server도 함께 설치해줍니다. webpack 실행은 $ webpack이란 명령어로, webpack-dev-server 실행은 $ webpack-dev-server라는 명령어로 가능합니다 :)이제 config 파일을 파헤쳐봅니다… webpack.config.jswebpack.config.js1234567const config = &#123; entry: [...], output: [...], module: [...], plugins: [...]&#125;module.exports = config; webpack.config.js 파일은 복잡해보이지만, config 객체를 정의하고 module.exports 구문을 통해 노출시킵니다. 모든 config 파일은 이런 구조로 entry, output, module, plugins 네 가지 설정을 기본적인 옵션을 제공합니다. entry, output option만 있을 때는 bundling 작업만 진행합니다.(이 두 option은 반드시 필요합니다.) 그럼, 각각에 대해서 알아봅니다. entrywebpack은 라이브러리 간의 의존성을 그래프(dependency tree)로 표현을 합니다. 이 그래프를 만들 때의 시작점을 entry라는 옵션을 통해 설정할 수 있습니다. 즉, webpack을 이용하여 bundle하고 build할 애플리케이션의 시작점을 설정하는 옵션이라고 할 수 있습니다. Usage1: entry: string|Array&lt;string&gt;entry 값으로는 string 또는 배열이 올 수 있습니다.123const config = &#123; entry: './path/to/my/entry/file.js'&#125;; 배열을 사용하는 경우의 대표적인 경우로는 react-hot-loader를 사용하는 경우가 있습니다. Usage2: entry: {[entryChunkName: string]: string|Array&lt;string&gt;}entry point를 여러 개 설정해야 하는 경우에는 Object를 사용하여 지정할 수 있습니다.123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 다른 entry point에서 시작하므로 각각의 entry point에서 생성된 그래프는 완전히 독립적인 그래프가 됩니다. (이러는 경우 각각의 dependency tree에서 중복되는 코드들이 발생할 수 있는데 이 부분은 commons-chunk-plugin을 통해서 해결할 수 있습니다.) Outputentry로 지정된 파일로부터 bundling을 진행하고, 그 결과를 어떻게 할지를 설정합니다.1234567const config = &#123; entry: [...] output: &#123; path: '/home/proj/dist', filename: 'bundle.js' &#125;&#125;; bundling된 결과 파일의 이름을 filename으로 어디에 생성할지에 대한 정보를 path에 설정해줍니다. path에는 절대 경로를 통해 설정해줘야합니다. 그렇기 때문에 __dirname을 사용할 수 있습니다.12345678const path = require('path');const config = &#123; entry: [...] output: &#123; path: __dirname + '/dist', filename: 'bundle.js' &#125;&#125;; path라는 모듈을 사용해서 path를 지정해줄 수 있습니다. .join(), .resolve() 두 가지의 메소드는 약간의 차이는 있지만 __dirname을 사용하는 경우 두 메소드 둘 다 동일한 의도하는 값을 반환하기 때문에 둘 다 사용 가능합니다. 두 메소드에 차이는 링크를 참고하시면 됩니다.1234567const config = &#123; entry: [...] output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;; path 모듈을 통해 path를 정리한 후의 상태입니다. modulemodule 옵션은 webpack을 통해 bundling을 진행할 때 처리해야 하는 task들을 실행할 때 사용합니다. ES5 문법을 사용하기 위해 먼저 babel을 통해 transpile을 해야 하는데 이 작업을 babel-loader를 통해 설정해줄 수 있습니다. 또 javascript 파일 뿐만 아니라 css 파일을 load해야하는 경우에는 css-loader를 사용할 수 있습니다. module.rulesrules에 각종 loader들을 등록할 수 있습니다. 배열의 형태로 여러 loader들을 등록합니다.1234567const config = &#123; module: &#123; rules: [&#123; //... &#125;] &#125;&#125; 여기에서 babel-loader, css-loader 등이 설정됩니다. 하나의 loader당 하나의 Object로 추가할 수 있습니다.1234567891011121314151617const config = &#123; module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, include: path.join(__dirname, 'src'), use: [&#123; loader: 'babel-loader', options: &#123; presets: [ ['env', &#123; module: false &#125;] ] &#125; &#125;] &#125;] &#125;&#125; babel-loader 하나만 추가했습니다. (babel-loader를 사용하기 위해서는 babel-core, babel-loader, babel-preset-env 세 개의 모듈이 필요합니다. babel-preset-env의 env가 es2015, es2016, es2017, latest를 대체합니다.) test를 통해 load할 파일을 지정하고, exclude와 include를 통해 path를 지정해줄 수 있습니다. 그리고 나서 사용할 module을 use를 통해 작성해 줍니다. use 안에는 loader와 options를 명시하여 loader에 대한 명세를 합니다. 이 options의 경우는 babel의 .babelrc파일로 따로 추출할 수 있습니다. config.js 파일이 과도하게 복잡해지는 것을 방지하기 위해서 loader에 대한 옵션은 따로 추출하는 것도 좋은 방법입니다. presets에서 { module: false }는 tree shaking을 사용하는 옵션으로 bundling 결과로부터 사용되지 않은 코드를 삭제하어 파일 크기를 줄여줍니다. 123456&#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ]&#125; rules에 위와 같은 객체를 추가해주면 css 파일을 load할 수 있습니다. (마찬가지로 style-loader, css-loader 두 가지를 install 해야합니다.) 다음 포스팅에서는 보다 효율적으로 개발을 도와주고 애플리케이션의 성능 향상에 도움을 주는 Plugins에 대해 알아보겠습니다 :) 포스팅에서 사용된 예제 코드는 Github repository에서 확인하실 수 있습니다 :D 1편 end Reference&gt;Webpack TutorialWebpack2와 모듈 번들링을 위한 초보자 가이드Javascript 모듈화 도구, webpack","categories":[{"name":"Tool","slug":"Tool","permalink":"https://jaeyeophan.github.io/categories/Tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://jaeyeophan.github.io/tags/tool/"}]},{"title":"[ES6] 11. Modulization","slug":"ES6-11-Modulization","date":"2017-05-04T06:22:01.000Z","updated":"2017-05-04T08:07:08.000Z","comments":true,"path":"2017/05/04/ES6-11-Modulization/","link":"","permalink":"https://jaeyeophan.github.io/2017/05/04/ES6-11-Modulization/","excerpt":"","text":"[ES6] 11. ModulizationES6에서 추가된 import/export 구문을 9가지 Case로 나누어 정리해봤습니다. Module in JavascriptModule pattern이라고 들어보셨나요? ES5에서는 기본적으로 global에 변수가 할당되기 때문에, Namespace pattern, module pattern 등등의 기법들이 필요했습니다. 또한 CommonJS, AMD처럼 같은 언어에서 환경에 따라 다른 방식으로 소스코드를 가져와 사용해야 했습니다. 이에 대한 부분은 JavaScript 표준을 위한 움직임: CommonJS와 AMD를 참고하시면 될 것 같습니다. ES6에서는 이러한 문제점을 인식하고 import라는 구문을 통해 Modulization을 제공합니다. 하지만 아쉽게도 Safari를 제외한 다른 브라우저에서는 아직 지원을 하지 않습니다. 그렇기 때문에 Webpack과 babel의 도움을 받아 테스트해볼 수 있습니다. import &amp; exportCase 1함수를 다른 자바스크립트 파일에서 불러와 실행해야 하는 경우에 대한 예제 코드입니다.module1.js123export function hello() &#123; console.log(`module1`);&#125; index.js12import &#123; hello &#125; from './module1';hello(); //module1 외부의 자바스크립트 파일에서 다른 자바스크립트 파일에 존재하는 함수를 문제없이 사용할 수 있게 되었습니다:){ ... }는 ES6의 destructuring 문법을 사용한 것입니다. module1.js파일에서 export가 붙은 함수를 import하는데 그 중 hello라는 함수를 import하겠다는 의미입니다. 이와 같은 방법으로 여러 함수 또는 변수를 export하고 import할 수 있습니다. 다른 방법도 살펴보겠습니다. Case 2module1.js123export default function hello() &#123; console.log(`module1`);&#125; index.js12import module1 from './module1';module1();// module1 default라는 키워드가 보이시나요? export 키워드를 사용하여 함수를 외부로 노출시킬 때, default라는 키워드를 붙여주면 해당 파일이 import되는 경우 기본적으로 지정된 함수 또는 변수를 노출시키겠다라는 의미입니다. 주로 파일에서 하나의 함수 또는 변수를 노출시킬 경우에 사용합니다. default 키워드를 사용하게 되면 특정 함수나 변수를 import하는 것이 아니므로 import하는 곳에서 변수명 또는 함수명을 임의로 지정할 수 있습니다. 이번 예제에서는 hello라는 함수 이름을 그대로 사용하지 않고 module1이라는 이름을 지정하여 함수를 호출했습니다. Case 3export default로 이미 export를 한 후에 다른 함수나 변수를 export하기 위해서는 import할 때 다음과 같은 방법을 사용해야 합니다.module1.js1234export default function hello() &#123; console.log(`module1`);&#125;export let name = \"jbee\"; index.js123import module1, &#123; name &#125; from './module1';module1();// module1console.log(name);// jbee name이라는 변수를 import하는 경우에는 반드시 name이라는 변수명으로 import해야겠죠? 다음의 경우에는 어떻게 될까요? Case 3-1index.js1234import module1, &#123; name &#125; from './module1';module1();// module1console.log(name);// jbeename = \"newName\"; //SyntaxError! import한 name을 다시 정의하려고 하면 SyntaxError가 발생합니다. import된 name이란 변수는 read-only 속성이 적용되기 때문입니다. 만약에 다음과 같은 경우는 어떻게 해야할까요? Case 3-2module1.js1export const name = \"jbee\"; module2.js1export const name = \"newName\"; 다른 자바스크립트 파일에서 같은 변수명을 사용한 경우입니다. 기존의 방식대로 import를 해볼까요?12import &#123; name &#125; from './module1';import &#123; name &#125; from './module2'; default로 export되지 않은 함수 또는 변수에 대해서는 반드시 그 이름을 지정해야 했습니다. 이럴 경우에는 Duplicate declaration에러가 발생합니다. Case 4위에서 발생한 문제를 해결하기 위한 첫번째 방법입니다.index.js12345import &#123; name as module1Name&#125; from './module1';import &#123; name as module2Name&#125; from './module2';console.log(module1Name);console.log(module2Name); as라는 키워드가 등장했습니다. alias의 줄임으로 import한 변수 또는 함수에 대해 별명을 지정할 수 있습니다. 이렇게 import를 하면 변수명끼리 충돌이 일어나지 않습니다:) 그러나 변수명이 점점 많아지게 되면 계속해서 새로운 변수명을 지정해줘야 하는 문제점이 발생하게 됩니다. Case 5위의 문제를 조금 더 개선해보겠습니다:)index.js12345import * as Module1 from './module1';import * as Module2 from './module2';console.log(Module1.name);console.log(Module2.name); as키워드를 사용함과 동시에 *이 등장했습니다. *은 import하고자 하는 자바스크립트 파일에서 export키워드가 붙어있는 모든 함수, 변수를 import할 때 사용합니다. 그리고 as 키워드를 통해서 namespace를 지정해줘야 합니다. 이렇게 import가 되면 Module1이라는 객체의 프로퍼티로 import한 변수 또는 함수에 접근할 수 있습니다. Case 6module1.js1234export const obj = &#123; name: \"Jbee\", age: 25&#125;; index.js12345import &#123; obj &#125; from './module1';console.log(obj.name);// Jbeeobj.name = \"newName\";console.log(obj.name);// newName 위 예제로부터 Object를 import하는 경우에, Object의 프로퍼티까지 보호할 수 없다는 것을 알 수 있습니다. Case 7여태까지 정의함과 동시에 export를 할지 말지 결정했는데요, 자바스크립트 코드의 마지막에서 이를 정의해줄 수 있습니다.module1.js123456const obj = &#123; name: \"Jbee\", age: 25&#125;;export &#123; obj &#125;; index.js123import &#123; obj &#125; from './module1';console.log(obj.name);// Jbee Case 8Object 또는 변수를 export하는 경우 default키워드를 붙일 수 없습니다. 대신 다른 방법이 존재합니다.module1.js123456const obj = &#123; name: \"Jbee\", age: 25&#125;;export &#123; obj as default &#125;; index.js123import obj from './module1';console.log(obj.name);// Jbee as default라는 키워드를 붙여 export할 수 있습니다. 이는 함수 또는 변수에도 적용 가능합니다. Case 9import 구문을 class에도 물론 적용할 수 있습니다.module1.js12345export default class Component &#123; constructor() &#123; console.log(`create component!`); &#125;&#125; index.js123import Component from './module1';new Component();//create component! import/export 5 convention from Airbnb ES6 Convention1) Wildcard(*) 사용을 자제하세요!12345// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide'; 2) import함과 동시에 export를 하지 말고 코드의 마지막에서 따로 export하세요!12345678// bad// filename es6.jsexport &#123; es6 as default &#125; from './airbnbStyleGuide';// good// filename es6.jsimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; 3) 동일한 path를 import하는 경우에는 한 줄에서 모두 import하세요!1234567// badimport foo from 'foo';// … some other imports … //import &#123; named1, named2 &#125; from 'foo';// goodimport foo, &#123; named1, named2 &#125; from 'foo'; 4) import 구문은 호이스팅 됩니다. 그러므로 import문은 모두 상단에 위치시키세요!1234567891011// badimport foo from 'foo';foo.init();import bar from 'bar';// goodimport foo from 'foo';import bar from 'bar';foo.init(); 5) 하나만 export하는 경우에는 default 키워드를 붙여주세요! 12345// badexport function foo() &#123;&#125;// goodexport default function foo() &#123;&#125; 마무리이상 9가지의 case로 ES6의 import와 export를 정리해봤습니다 :D ES6 모든 포스팅은 Github Respository에서 확인하실 수 있습니다. 11. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[Tool] Issue Management Tool, Zenhub","slug":"issue-management-tool","date":"2017-04-29T15:30:28.000Z","updated":"2017-05-02T12:46:11.000Z","comments":true,"path":"2017/04/30/issue-management-tool/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/30/issue-management-tool/","excerpt":"","text":"Issue Management Tool개발자들에게 정말 많은 사랑을 받고 있는 Github. 이제는 더 이상 없어서는 안 될 존재가 되었는데요:) 이 Github도 약간 아쉬운 부분이 존재합니다. 그래서 이번 포스팅에서는 Github과 함께 사용할 수 있는 Issue Management Tool 몇 가지를 소개해드리려고 합니다. (Github도 이에 대한 필요성을 느끼고 Project라는 이름의 기능을 추가하였는데요, 이것과 비교도 해보겠습니다.)Github Help에서 제공하는 Issue 관리에 대한 자료입니다. 이 포스팅을 읽기 전에 참고해봐도 좋을 것 같습니다. Agile이라는 녀석, reference&gt;http://www.onedesk.com/scrum-methodology-vs-agile-methodology/Agile 방법론이 대두되면서, 프로젝트의 진행 상황을 공유하고 관리하는 것이 전보다 복잡하고 중요해졌습니다.(Agile이란 무엇인가) 개발자들간의 의사소통은 물론이고 프로젝트를 관리하는 매니저, 팀장 등과의 의사소통이 매우 중요해졌는데요, 이러한 상황 속에서 매번 회의를 하거나 서로에게 물어보면 그만큼 생산성이 감소하게 됩니다. 보다 효율적으로, Agile하게 프로젝트가 진행될 수 있도록 각종 도구들을 제대로 알고 팀에 적합한 도구를 고르는 것이 중요해졌습니다. Github이 제공하는 기능들프로젝트 Repository안에는 viewer인 Code 탭, task 관리를 위한 Issue탭, 그리고 이 이슈들을 관리하기 위한 Label과 Milestone이 존재합니다. 프로젝트에서 진행되고 있는 Issue의 상태(Status) 또는 성격을 Label이라는 Metadata로 관리할 수 있고, Milestone이란 기능으로 단기적인 목표의 기간을 관리할 수 있습니다. 또 Project라는 탭을 통해 kanban 형식으로 Issue들을 관리할 수 있습니다. Trello라는 서비스를 아시나요? Tello가 대표적인 kanban 형식의 dashboard 입니다. cf&gt; 포스팅에서 언급되는 기존 형식의 dashboard란 Agile workflow를 중심으로 드래그 앤 드롭을 통한 우선순위 선정 기능, Label 기능, Real-time dashboard 기능 등을 포함한 kanban 형식의 dashboard을 말합니다. ToolsGithub에서 제공하는 다양한 Plugin 형태의 Tool들은 Integration Tab에서 볼 수 있습니다. 이미 널리 알려진 JIRA를 제외하고 몇 가지 Tool들을 알아보겠습니다:) 제 나름대로의 판단 기준을 갖고 검색해보았습니다. 기존의 Github Repository와 연동이 잘 되는가? 어떤 형식으로 dashboard를 제공하는가? (kanban 형식인가?) UI/UX적으로 어떤가? 부가적인 기능에는 무엇이 있는가? ZenhubZenhub은 기존 형식의 dashboard를 제공합니다. Repository 기준으로 dashboard가 생성되고 기존에 등록되어 있던 Issue들은 물론이고 추후 생성하는 Issue들은 New Issues라는 column으로 들어갑니다. 가장 기본적이고 중요한 Github과의 연동은 문제가 없습니다. 장점기존의 Github에서 Tab만 추가되는 형식기존의 Github에서 제공하는 탭에서 Board라는 탭과 Report라는 탭이 추가되었습니다. Zenhub을 추가하게 되면 자동으로 Repository마다 저런 형식으로 탭이 추가됩니다. 기존 Github에서 제공되는 기능에서 Board라는 탭이 추가되는 형식이기 때문에 기존의 Github을 그대로 이용할 수 있다는 장점이 있습니다. Chrome Extension원한다면 Chrome extension을 추가하여 브라우저 어디에서든 변동사항을 파악할 수 있다는 장점도 존재합니다. 접근성면에서 아주 좋습니다. Metadata를 통한 Issue 구체화Zenhub은 Github에서 제공하는 Issue Metadata들에서 추가적으로 몇 가지 기능을 더 제공합니다. 1. Pipeline제공되는 dashboard를 기준으로 제공되는 Pipleline이라는 기능으로 Issue의 Status를 설정할 수 있습니다. 2. EpicGithub에서는 Issue들을 명시적으로 그룹화할 방법이 없었습니다. Label을 통해서 어떻게든 그룹화하려면 할 수는 있었지만, 아쉬운 점이 많았습니다. Zenhub에서는 epic이라는 기능을 제공하여 Issue들을 그룹화할 수 있습니다. 3. EstimateIssue에 Estimate라는 Metadata를 이용하여 해당 Issue의 복잡도(complexity)를 설정할 수 있습니다. 1, 2, 3, 5, 8, 13, 21, 40이라는 총 8단계의 레벨을 제공하고 있습니다. 팀 내부에서의 회의를 통해 일정을 산정하고 그에 맞는 레벨을 설정할 수 있습니다. 플래닝 포커라는 방법으로 일정을 산출할 수 있습니다. &gt; 참고자료:플래닝 포커를 이용한 프로젝트 일정 산정 Merge repositoryRespository를 merge하여 하나의 dashboard에서 복수 개의 Respository를 관리할 수 있습니다. 여러 프로젝트를 통합하여 관리해야 한다면 Zenhub의 merge 기능을 이용할 수 있습니다. 개인 Issue 관리 Repository를 따로 만들어서 자신만의 Issue를 관리할 수 있겠네요:) Report 기능Burndown, Velocity tracking, Release Report 세 가지의 옵션으로 그래프 형식의 보고서를 보여줍니다. 지정한 Milestone의 진행 상황을 한 눈에 살펴볼 수 있는 좋은 기능입니다 :) Label에 따라서 또는 Issue의 상태에 따라서 다양한 보고서를 볼 수 있습니다. To do listZenhub플러그인을 설치하게 되면 위과 같이 상단 bar에 Todo라는 탭이 하나 더 추가됩니다.TODO를 관리할 수 있도록 플러그인을 제공해주고 있습니다. 물론 다른 Todo 전용 애플리케이션보다는 기능이 미약합니다. 기타 부가적인 기능그리고 Zenhub에서는 Repository에서 다른 Respository로 손쉽게 이동할 수 있는 통로(?)를 제공해줍니다. Repository 이름 옆에 햄버거 버튼이 생성되는데요, 그 버튼을 통해서 계정에 존재하는 다른 Repository로 이동할 수 있습니다.한 가지 또 부가적인 기능은 키보드 자판에서의 b버튼을 shotcut으로 제공해서 repository 화면에서 바로 Board탭으로 이동이 가능하네요:) 가격공식 웹 사이트에는 5명 이하의 작은 팀에 대해서는 무료로 제공한다고 합니다. 물론 이것은 private repository에 대해서 적용되는 사항이구요, public repository에 대해서는 사용자 수에 상관없이 무료로 제공하고 있습니다. Github에서 제공하는 Project 기능과비교Zenhub에서는 dashboard에서 Issue를 클릭하면 modal형태로 해당 Issue의 내용이 보이면서 바로 comment를 달거나 Label을 변경하는 등의 작업을 수행할 수 있는 기능을 제공합니다. 그러나 Github에서 제공하는 Project dashboard는 Issue를 클릭하면 해당 Issue 페이지로 redirect되어 (개인적으로는 매우)불편합니다. 또한 Zenhub을 사용하면 Issue의 특성에 따라서 필터를 적용할 수 있습니다. dashboard에 흩어져 있는 Issue들을 Milestone에 따라서 또는 Label에 따라서 등등의 특성으로 분류가 가능합니다. 아직 Github에서 default로 제공하는 Project 기능은 부족한 점이 많아 보입니다 :( Zenhub 공식 사이트에서 보다 자세한 내용을 확인하실 수 있습니다. 그 외 Management ToolsHueboardHueboard 예시Zenhub과 마찬가지로 하나의 Repository마다, 하나의 dashboard를 제공해주며 기존의 dashboard 형식을 취합니다. UI적으로는 Zenhub보다 조금 나아보입니다. Zenhub과는 달리 별도의 웹 사이트로 redirect되면서 프로젝트 관리에 대한 총체적인 dashboard를 제공합니다. Filter 기능이 유독 눈에 들어오네요. Zenhub에서도 가능했던 기능이지만 UI적으로 깔끔해서 dashboard에 집중할 수가 있을 것 같습니다.Hueboard 공식 사이트에서 보다 자세한 내용을 확인하실 수 있습니다. Zube기존의 dashboard 외에 몇 가지 추가적인 기능을 제공합니다. Sprint board, Sprint, Tickets 눈에 들어오는 것은 Analytics 기능입니다.Zenhub에서 제공하는 보고서 유형보다 2종류가 더 많네요. 프로젝트를 처음 시작할 때부터 도입하지 않으면 사용하기에 부담이 생기는 Tool일 것 같다는 생각이 들었습니다. 또한 너무 많은 기능을 제공하면 오히려 생산성을 저해하는 요소가 될 수 있지 않을까 생각이 드는 Tool이었습니다. Zube 공식 사이트에서 보다 자세한 내용을 확인하실 수 있습니다. 마무리이 외에도 Waffle, CodeTree, Asana 등등 정말 많은 Tool들이 존재합니다. 제공하는 기능은 조금씩만 다르고 다 거기서 거기인 것 같습니다. 기존에 사용했던 다른 도구들(예를 들면 Slack, Trello, hipchat 등)과 얼마나 통합이 잘 되는지 또한 중요한 쟁점이 될 것 같습니다. 또 프로젝트에서 사용하는 Tool이 많아질수록 본래 프로젝트를 관리하기 위해 도입했던 관리 Tool을 관리해야 하는 주객전도 현상이 발생할 수 있습니다. 이 부분 또한 인지하여 프로젝트 관리 도구를 도입해야할 것입니다. 저는 개인적으로 새로운 Tool이 도입되는 부담감이 가장 적고 기존의 Github에 가장 잘 녹아드는 Zenhub이 가장 잘 맞는 것 같습니다:) 여러분 팀에 맞는 프로젝트 관리 도구는 무엇인가요?감사합니다 :)","categories":[{"name":"Tool","slug":"Tool","permalink":"https://jaeyeophan.github.io/categories/Tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://jaeyeophan.github.io/tags/tool/"}]},{"title":"[TS] 1. Basic Types","slug":"TS-1-Basic-Types","date":"2017-04-23T07:12:08.000Z","updated":"2017-04-23T07:13:58.000Z","comments":true,"path":"2017/04/23/TS-1-Basic-Types/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/23/TS-1-Basic-Types/","excerpt":"","text":"[TS] 1. Basic TypesTypeScript에서는 JavaScript에서 사용했었던 number, string, boolean과 같은 데이터 타입을 기반으로 정적 타이핑을 지원합니다. 본격적인 TypeScript Tutorial 진행을 위해 에디터에 TSLint를 설치하겠습니다. (TypeScript에서 제공하는 Playground에서 해보실 수도 있습니다.) Install TSLint12yarn global add tslint typescriptyarn global tslint typescript typescript패키지는 TSLint와 동일한 version을 사용해야 하기 때문에 peerDependencies로 설치해줍니다.작업할 디렉토리로 이동하여 tslint를 설정해줍니다.1tslint --init 위 명령어를 실행하게 되면 tslint.json이라는 파일이 생성됩니다.1234&#123; \"defaultSeverity\": \"error\", \"extends\": \"tslint:recommended\"&#125; 기본적으로 tslint에서 제공하는 recommended rule을 적용했습니다. 저는 WebStorm이라는 에디터를 사용하고 있습니다. 각자 사용하는 에디터에서 환경설정을 통해 TSLint를 able로 설정해주시면 됩니다. TSLint에서 제공하고 있는 rule은 공식 사이트에서 제공하고 있습니다. 입맛에 맞게 해당 rule들을 오버라이딩하여 사용하실 수 있습니다. (WebStorm에서는 console찍는 것 가지고 뭐라 안하는데, 다른 editor에서는 console마저 지우라고 하는 것 같습니다. no-console rule을 설정하시는게 정신 건강에 좋을 것 같습니다.) 보다 자세한 tslint.json 설정은 다음 링크를 참고하시면 좋을 것 같습니다. MicroSoft가 만든 VSCode 에디터가 요즘 뜨고 있는데요, VSCode 에디터에 TypeScript 개발 환경 설정하는 내용을 포함하고 있습니다. Visual Studio Code에서의 TypeScript 개발 환경 구축 Basic Types변수에 타입을 지정해주기 위해서 TypeScript에서는 :을 통해 지원합니다. 기존의 JavaScript에서 변수를 선언하면서 :으로 해당 변수의 타입을 지정해줍니다. Boolean1let isExist: boolean = false; boolean 타입을 지정합니다. Number, 숫자1234let decimal: number = 6;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744; number 타입을 지정합니다. String, 문자열12let name: string = \"jbee\";let greeting: string = `Hi, I'm $&#123;name&#125;!`; string 타입을 지정합니다. Array, 배열1let arr: number[] = [1, 2, 3]; or1let arr: Array&lt;number&gt; = [1, 2, 3]; 기존에 배열 리터럴을 사용하여 배열을 정의하면서 정의하는 배열에 어떠한 데이터 타입의 원소가 들어갈 것인지를 Type을 통해 제공할 수 있습니다. Tuple, 튜플12345let tuple: [string, number];tuple = [\"age\", 25];tuple = [\"name\", \"jbee];// Error&gt; message: 'Type '[string, string]' is not assignable to type '[string, number]'. Type 'string' is not assignable to type 'number'.' at: '5,1' key-value의 형태를 저장할 때는, 위와 같이 타입을 지정해줄 수 있습니다. TSLint가 잘못된 타입의 값이 들어왔다는 것을 error message로 알려줍니다. Enum12enum Color &#123;Red, Green, Blue&#125;;let c: Color = Color.Green; 마찬가지로 Java의 enum과 같은 구조를 갖습니다. 시작하는 멤버에 0부터 번호를 매기고, 만약 1부터 시작해야 한다면 임의적으로 시작하는 숫자를 지정할 수 있습니다. 또는 각각에게 번호를 지정할 수도 있습니다.12enum Subject &#123;Math = 1, Science = 3, History = 7&#125;console.log(Subject[3]);//Science 지정한 번호로 호출도 가능합니다. tsc 명령어를 통해서 저희가 작성한 TypeScript 코드를 변환된 Javascript 코드로 볼 수 있습니다. TypeScript의 Enum은 다음과 같이 변환되는 것을 확인하실 수 있습니다.123456var Subject;(function (Subject) &#123; Subject[Subject[\"Math\"] = 1] = \"Math\"; Subject[Subject[\"Science\"] = 3] = \"Science\"; Subject[Subject[\"History\"] = 7] = \"History\";&#125;)(Subject || (Subject = &#123;&#125;)); 자바스크립트의 다섯 줄이 타입스크립트 한 줄로 작성되었습니다 :) Any코드를 작성하면서 사용되는 변수에 알맞은 데이터 타입을 설정하는 것은 중요하지만 데이터 타입이 동적으로 결정되는 변수도 존재하게 됩니다. 이럴 때 사용할 수 있는 타입이 any입니다.1234let notSureVar: any;notSureVar = 3;notSureVar = `hi`;notSureVar = [1,2,3]; any로 타입을 지정하면 Compile Time에서 Type checking을 하지 않습니다.1let notSureVar; // == let notSureVar: any; any로 타입을 지정하는 것과 위의 자바스크립트는 동치라고 볼 수 있습니다.1let arr: any[] = [1, `jbee`, true]; 여러 가지 타입의 요소가 포함되는 배열을 정의할 때도 any를 사용할 수 있습니다.any의 역할이 다른 언어에서의 Object와 같은 역할을 하는 느낌이 드는데요, 실제로 2.2version에서 Object타입이 추가되었습니다. 일단 코드를 통해 확인해보겠습니다.12345678910111213141516let user = &#123; getName() &#123; console.log(`hi`); &#125;, name : \"jbee\"&#125;let notSureObj: Object;notSureObj = user;notSureObj.getName(); // errornotSureObj.name; // error//Property 'getName' does not exist on type 'Ojbect'let notSureVar: any;notSureVar = user;notSureVar.getName(); // successnotSureVar.name; // \"jbee\" 변수의 type을 Object로 지정하고, 실제 Object를 정의하여 변수에 할당했습니다. 그리고 할당한 Ojbect에 존재하는 메소드를 호출했더니 에러가 발생합니다. getName()이라는 프로퍼티가 없다고 하네요. 분명 getName()메소드가 존재하는 Ojbect를 할당했는데 말이죠. name 프로퍼티도 마찬가지입니다. 하지만 any 타입으로 지정했을 때는 메소드를 호출할 수 있고, 프로퍼티를 찾을 수 있습니다. 이 Object 타입은 할당만 가능할 뿐, 메소드나 프로퍼티에 접근할 수 없습니다.About Object Type Void값을 반환하지 않는 함수의 return type을 지정할 때 사용할 수 있습니다.123function greeting(): void &#123; console.log(`hi`);&#125; 물론 변수의 타입에도 사용할 수 있습니다.12345let foo: void;foo = undefined;foo = null;foo = `foo`; //error&gt; Type 'string' is not assignable to type 'void' 하지만 void로 선언된 변수에는 undefined와 null 값만 할당할 수 있습니다. Null, Undefined기본적으로 null과 undefined는 모든 타입들의 서브타입이라고 할 수 있습니다. 즉 다른 타입으로 지정된 변수에도 null과 undefined를 할당할 수 있습니다. --strictNullChecks flag를 사용하게 되면 null과 undefined는 void타입의 변수에만 할당할 수 있습니다. TypeScript에서는 해당 flag사용을 권장하고 있습니다. Nevernever 타입은 발생하지 않는 경우에 대한 타입을 대표하는 타입입니다. 코드를 통해 살펴보겠습니다.123456789101112131415// Function returning never must have unreachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;// Function returning never must have unreachable end pointfunction infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 위의 예제와 같이 throw를 하거나 error를 발생시키는 function의 return type으로 설정합니다.About Never Type Type Assertions타입 어설션이란 개발자가 타입스크립트에게 “내가 무슨 짓을 하고 있는지 아니까, 나를 믿어줘!”하고 메세지를 보내는 것입니다. 주로 엔티티의 타입을 보다 구체적으로 설정할 때 사용합니다.12345let greet: any = `Hello!`;let lengthOfGreet: number;lengthOfGreet = greet.length;lengthOfGreet = (&lt;string&gt; greet).length;lengthOfGreet = (greet as string).length; any타입에 대해서 형변환(type casting)하는 것처럼 보이지만 실제로는 특별한 검사나 데이터 재구성을 하지 않습니다. 이 타입 어설션은 컴파일 타임에만 영향을 미칠뿐 런타임시에는 아무런 영향을 주지 않습니다. 보다 데이터 타입을 구체화 시킬 때 사용합니다.&lt;&gt;를 사용하는 방법과 as를 사용하는 두 가지 방법이 존재합니다. 선호도에 따라 어떻게 사용할지 결정할 수 있지만 JSX와 함께 사용하는 경우에는 as를 사용하는 방법만 허용됩니다. 감사합니다 :) 1. Basic Type end ReferenceTypeScript Official Document - Basic Types","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://jaeyeophan.github.io/categories/TypeScript/"}],"tags":[{"name":"ts","slug":"ts","permalink":"https://jaeyeophan.github.io/tags/ts/"}]},{"title":"[TDD] 3. Chai-http 사용하여 REST API Test하기","slug":"BDD-3-chai-http","date":"2017-04-23T07:07:57.000Z","updated":"2017-05-21T04:42:41.000Z","comments":true,"path":"2017/04/23/BDD-3-chai-http/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/23/BDD-3-chai-http/","excerpt":"","text":"[TDD] 3. Chai-http 사용하여 REST API Test하기&gt;Mocha - Getting started&gt;&gt;Chai - Getting started&gt; 이번 포스팅에서는 chai-http라는 module을 사용해서 REST API를 테스트하는 코드를 작성해보겠습니다. 테스트에 집중하기 위해 요청을 받을 서버는 json-server라는 모듈을 사용하여 구축하겠습니다. json형태로 데이터를 생성하고 요청을 받을 수 있는 임시 서버입니다. 데이터베이스를 따로 구축하지 않아도 CRUD와 같은 기본적인 API를 제공해주는 모듈입니다. 포스팅에서 다루는 내용보다 더 자세한 내용은 해당 링크를 참조하시면 되겠습니다. 테스트 환경 구축하기우선 chai-http를 설치합니다.1$ yarn add chai-http 그리고 서버로 사용할 json-server를 설치합니다.1$ yarn global add json-server 그런 다음 src 디렉토리(작업하고자 하는 디렉토리)로 이동하여 다음 명령어를 실행해줍니다.1$ json-server --watch db.json 위 명령어를 실행하게 되면 db.json 파일을 생성하게 되고 해당 .json파일에 기본적인 데이터가 들어가있습니다. json-server는 기본적으로 3000번 포트를 사용합니다. localhost:3000에 접속해보면 어떠한 데이터가 들어가있는지를 간단한 웹 페이지를 통해서도 확인하실 수 있습니다.1234\\&#123;^_^&#125;/ hi!Loading db.jsonDone console에는 귀여운 이모티콘이 환영을 해주네요 :) 보다 customized한 서버를 사용하시고 싶은 경우에는 다음과 같은 .js파일을 만들어 사용하실 수 있습니다.server.js12345678910const jsonServer = require('json-server');const server = jsonServer.create();const router = jsonServer.router('db.json');const middlewares = jsonServer.defaults();server.use(middlewares);server.use(router);server.listen(3000, () =&gt; &#123; console.log('JSON Server is running')&#125;); 위 파일은 node server.js 명령어로 실행하실 수 있습니다 :) 이번 포스팅에서는 default로 생성되는 임시 서버를 사용하겠습니다. .test 파일 작성이제 테스트 코드를 작성할 .test파일을 만들어 보겠습니다.rest.test.js123456const chai = require('chai');const chaiHttp = require('chai-http');const expect = chai.expect;chai.use(chaiHttp);const url = 'http://localhost:3000'; 이전에 설치한 chai와 테스트 환경을 구축할 때 설치한 chai-http를 불러옵니다. 그리고 chai가 chai-http를 use합니다. 이전 포스팅에서 소개해드렸던 expect를 사용하기 위해 준비합니다. 마지막으로 요청을 보낼 서버의 api에서 반복될 url을 상수로 할당해줬습니다. Request TEST본격적인 테스트 코드를 작성할 시간입니다. 우선 server에 요청이 제대로 가는지 확인해보겠습니다.rest.test.js1234567891011describe('Request test', () =&gt; &#123; it('request to server', done =&gt; &#123; chai.request(url) .get('/') .end((err, res) =&gt; &#123; expect(err).to.be.null; expect(res).to.have.status(200); done(); &#125;); &#125;);&#125;); 위 코드는 http://localhost:3000/에 대한 GET 요청이 제대로 동작하는지 테스트하는 코드입니다.해당 url로 request를 보내고 get 방식으로 그 요청을 보냅니다. 요청에 대한 응답을 .end()메소드로 받을 수 있습니다. 이 end() 메소드에는 요청에 대한 응답으로 err와 res를 파라미터로 받는 콜백 함수를 넘겨줍니다.콜백 함수에서는 에러(err)는 null값이어야 하고, http status code는 200이어야 한다는 내용을 담고 있습니다. 모든 조건이 만족되면 done() 함수가 호출되면서 test가 pass하게 됩니다.1$ npm test 위 명령어로 test를 실행해보겠습니다. 방금 전 json-server를 running한 터미널 창이 아닌 다른 터미널 창에서 실행하셔야 합니다. 요청을 받으러면 서버가 running 중이어야 하니까요 :)test terminal1234REST test ✓ request to server1 passing (13ms) 해당 테스트가 잘 pass한 것을 확인하실 수 있습니다.json-server terminal1GET / 200 2.318 ms - - 그리고 아까 json-server --watch db.json 명령어를 실행한 console에서는 GET요청에 대한 로그를 남깁니다. CRUD TESTData Modeling테스트를 위해 db.json에 간단한 데이터를 넣어보겠습니다. 다음과 비슷한 형식으로 바꿔줍니다.db.json12345678910111213141516171819&#123; \"users\": [ &#123; \"id\": 1, \"name\": \"Jbee\", \"age\": 25 &#125;, &#123; \"id\": 2, \"name\": \"foo\", \"age\": 20 &#125;, &#123; \"id\": 3, \"name\": \"bar\", \"age\": 30 &#125; ]&#125; users라는 배열을 지정해줬습니다. 배열의 요소에는 name과 age를 갖고 있는 json형식의 데이터를 넣어줬습니다. 저장을 하면 --watch옵션을 붙여 실행했기 때문에 변경된 데이터 사항이 자동으로 반영됩니다. localhost:3000의 웹 페이지도 새로고침을 해보면 새로운 데이터가 들어가있는 것을 확인하실 수 있습니다. 이 데이터에는 /users라는 api로 접근이 가능합니다. GETdb.json파일에 추가한 users데이터를 가져와 봅시다.rest.test.js123456789101112describe('GET', () =&gt; &#123; it('fetch all users', done =&gt; &#123; chai.request(url) .get('/users') .end((err, res) =&gt; &#123; expect(err).to.be.not.ok; expect(res).to.have.status(200); expect(res.body).to.be.an('array'); done(); &#125;); &#125;);&#125;); 이전의 코드와 매우 유사합니다. res.body에 대한 값을 확인하는 코드가 추가되었습니다. array 형식의 데이터라면 test를 pass시키도록 테스트 코드를 작성했습니다. test가 잘 통과하네요 :)특정 user에 대한 값만 가져오려면 어떻게 해야 할까요?rest.test.js1234567891011121314151617it('fetch one user', done =&gt; &#123; chai.request(url) .get('/users') .query(&#123;id: 1&#125;) .end((err, res) =&gt; &#123; expect(err).to.be.null; expect(res).to.have.status(200); expect(res.body[0]).to.deep.equal( &#123; id: 1, name: \"Jbee\", age: 25 &#125; ); done(); &#125;);&#125;); 위 예제 코드를 describe 콜백 함수 안에 추가해줍니다. 와 같이 .query()에 해당하는 조건을 넘겨줄 수 있습니다. 응답으로 오는 데이터가 명시한 값과 일치하는지를 테스트 코드로 작성해줬습니다. POSTrest.test.js12345678910111213describe('POST', () =&gt; &#123; it('add user', done =&gt; &#123; chai.request(url) .post('/users') .send(&#123;id: 4, name: 'react', age: 3&#125;) .end((err, res) =&gt; &#123; expect(err).to.be.not.ok; expect(res).to.have.status(201); user = res.body; done(); &#125;); &#125;);&#125;); post()메소드와 send() 메소드를 통해 테스트를 진행할 수 있습니다. PUTrest.test.js123456789101112describe('PATCH', () =&gt; &#123; it('update user', done =&gt; &#123; chai.request(url) .patch('/users/2') .send(&#123;name: 'angular', age: 1&#125;) .end((err, res) =&gt; &#123; expect(err).to.be.not.ok; expect(res).to.have.status(200); done(); &#125;); &#125;);&#125;); patch()메소드와 send() 메소드를 통해 테스트를 진행할 수 있습니다. DELETErest.test.js1234567891011describe('DELETE', () =&gt; &#123; it('delete user', done =&gt; &#123; chai.request(url) .delete('/users/4') .end((err, res) =&gt; &#123; expect(err).to.be.not.ok; expect(res).to.have.status(200); done(); &#125;); &#125;);&#125;); delete()메소드를 통해 테스트를 진행할 수 있습니다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. [TDD] 3. end","categories":[{"name":"Tool","slug":"Tool","permalink":"https://jaeyeophan.github.io/categories/Tool/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"https://jaeyeophan.github.io/tags/TDD/"}]},{"title":"[TDD] 2. Chai - Getting started","slug":"BDD-2-chai","date":"2017-04-23T07:07:45.000Z","updated":"2017-05-21T04:42:42.000Z","comments":true,"path":"2017/04/23/BDD-2-chai/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/23/BDD-2-chai/","excerpt":"","text":"[TDD] 2. Chai - Getting started&gt;Mocha - Getting started&gt; 이전 포스팅에서 Mocha를 사용한 테스트를 진행해봤습니다. 이전 포스팅의 예제 코드에 Assertion Library인 Chai를 추가해보겠습니다. Chai는 세 가지 style의 Assertion을 제공합니다. assert기본적으로 node에서 제공하는 Assert라이브러리와 유사합니다. expectBDD 스타일로 제공되는 인터페이스 중 하나로 공식 문서에서는 natural longuage처럼 chaining을 제공하여 코드를 작성할 수 있게 해준다고 합니다. 잠시 후 예제 코드로 살펴보겠습니다. shouldBDD 스타일로 제공되는 인터페이스 중 나머지 하나로 expect 인터페이스와 마찬가지로 chainging을 통한 API를 제공합니다. 라이브러리에 대한 보다 구체적인 내용은 공식 문서를 참조하시면 되겠습니다. &gt;Chai Documents&gt; Getting Started우선, Chai를 설치해줍니다. 1$ yarn global add chai 이전에 작성했던 /test/operator.test.js 코드에서 Chai를 불러옵니다. 123const chai = require('chai');const expect = chai.expect;const should = chai.should(); expect와 should가 불러오는 방식이 약간 다릅니다. expect 인터페이스는 assertion을 제공하는 시작점으로 함수를 제공합니다. should 인터페이스는 Object.prototype을 확장하여 단일 Getter를 제공하고 그것을 시작점으로 제공합니다. expect 인터페이스를 통해 지저분했던 if 구문을 제거해봅시다! 1234567describe('sum 함수 테스트', () =&gt; &#123; it ('10과 20를 넘기면 30이 나와야 한다', done =&gt; &#123; let result = sum(10, 20); expect(result).to.equal(30); done(); &#125;);&#125;); 첫번째로 등장한 api, equal입니다! equal()메소드에는 파라미터르 기대값이 들어가게 됩니다. 테스트 하고자 하는 함수의 반환 값이 기대값과 다르게 되면 그에 해당하는 error message가 나타납니다. 30을 40으로 바꾸고 실행해보겠습니다. 123456789101112131415sum 함수 테스트 1) 10과 20를 넘기면 30이 나와야 한다 0 passing (6ms) 1 failing 1) sum 함수 테스트 10과 20를 넘기면 30이 나와야 한다: AssertionError: expected 30 to equal 40 + expected - actual -30 +40 at Context.done (test/operator.test.js:37:27) 정말 친절한 log가 출력되는 것을 확인할 수 있습니다. describe에 기술했던 section 이름이 제일 먼저 출력되고, 테스트를 실행한 단위 테스트의 이름이 출력됩니다. 그리고 통과한 단위 테스트와 실패한 단위 테스트에 대한 정보가 나타납니다. 기대값과 실제 반환값과의 차이를 보여주며 어느 부분에서 에러가 발생했는지까지 출력됩니다 :) Expect APIBDD style, Expect API .ok123expect(false).to.not.be.ok;expect(undefined).to.not.be.ok;expect(null).to.not.be.ok; 넘겨받는 값이 false인지 undefined인지 null인지 한 번에 판단할 수 있는 API입니다. 위 예제 코드에서는 일단 테스트가 통과하는 상황을 만들기 위해 not을 붙였는데요, 실제 테스트 코드에서는 not을 제거하여 사용하면 값을 한 번에 판단할 수 있는 API가 됩니다. boolean에 대해서는 .true, .falase가 별도로 존재합니다. 그리고 배열이 empty인지를 판단하는 .empty도 별도로 존재합니다. .deep123expect(foo).to.deep.equal(&#123; bar: 'baz' &#125;);expect(&#123; foo: &#123; bar: &#123; baz: 'quux' &#125; &#125; &#125;) .to.have.deep.property('foo.bar.baz', 'quux'); 객체를 equal로 비교를 하기 위해서는 추가적으로 deep flag가 필요합니다. .include vs .have1234567891011//.include vs .haveexpect([1,2,3]).to.include(2);// expect([1,2,3]).to.have(2); // error!expect([1,2,3]).to.have.property(2);var obj = &#123; foo: 'bar' &#125;;expect(obj).to.include.property('foo');expect(obj).to.have.property('foo');expect('foobar').to.include.string('bar');expect('foobar').to.have.string('bar'); (사실 두 API의 차이점을 잘 모르겠다.) 사용하기12var deepCss = &#123; '.link': &#123; '[target]': 42 &#125;&#125;;expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42); .이나 [,]을 사용하기 위해서는 \\\\를 사용하여 표시할 수 있습니다. 제공되는 API 종류가 정말 많아서, 왠지 있을 것 같은 API는 공식 문서에서 찾아보면서 테스트 코드를 작성하면 되겠습니다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. &gt;Chai-http를 사용하여 REST API test하기&gt; [TDD] 2. end","categories":[{"name":"Tool","slug":"Tool","permalink":"https://jaeyeophan.github.io/categories/Tool/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"https://jaeyeophan.github.io/tags/TDD/"}]},{"title":"[TDD] 1. Mocha - Getting started","slug":"BDD-1-mocha","date":"2017-04-23T07:07:34.000Z","updated":"2017-05-21T04:42:39.000Z","comments":true,"path":"2017/04/23/BDD-1-mocha/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/23/BDD-1-mocha/","excerpt":"","text":"[TDD] 1. Mocha - Getting startedMocha란 러너를 포함하고 있는 테스트 프레임워크로 사용자 수가 가장 많은 테스크 프레임워크입니다. Mocha는 자체적으로 assertion을 지원하지 않기 때문에 다른 Assertion라이브러리와 함께 사용해야 합니다. 기본적으로 node에서 제공하는 assert라이브러리가 존재하며 요즘에는 주로 chai라는 라이브러리와 함께 사용한다고 합니다. 라이브러리에 대한 내용은 공식 문서를 참조하시면 되겠습니다.&gt;Mocha Documents Mocha는 기본적으로 BDD 기반의 프레임워크입니다. 하지만 BDD와 TDD 두 종류의 인터페이스를 모두 제공하고 있습니다. 이번 포스팅에서는 BDD 기반의 예제를 살펴봅니다.TDD vs BDD Getting Started mocha를 global로 설치해줍니다. (cf YARN, 새로운 Package Manager)12345$ yarn global add mocha#success Installed \"mocha@3.2.0\" with binaries:# - mocha# - _mocha#✨ Done in 4.23s. 저는 3.2.0 version의 mocha를 설치했습니다. 보다 간편한 테스트 run을 위해 package.json에 scripts 추가합니다.12345[...]\"scripts\": &#123; \"test\": \"mocha $(find ./ -name '*./test/**/*.test.js') --recursive -w\"&#125;,[...] test라는 명령어로 mocha를 실행하며 test디렉토리에 있고 .test.js파일을 찾아 mocha를 실행시킵니다. 그리고 추가적으로 -w옵션을 통해 파일이 변경될 때마다 자동으로 테스트를 수행할 수 있게 합니다. /src/operator.js 파일을 생성하고 다음 코드를 작성합니다.123exports.sum = (a, b) =&gt; &#123; return a + b;&#125;; 정말 간단하게, 두 수를 파라미터로 받아 합을 반환하는 sum 함수를 테스트해보겠습니다. /test/operator.test.js 파일을 생성하고 다음 코드를 작성합니다.12const operator = require('../src/operator');const sum = operator.sum; 우선 /src/operator.js 파일을 import합니다.123456789101112describe('operator.js Test', () =&gt; &#123; describe('sum 함수 테스트', () =&gt; &#123; it ('10과 20를 넘기면 30이 나와야 한다.', done =&gt; &#123; let result = sum(10, 20); if (result === 30) &#123; done(); &#125; else &#123; throw Error('결과 값이 30이 아니다.'); &#125; &#125;); &#125;);&#125;); 드디어 테스트 코드를 작성했습니다. describe에서는 테스트의 이름을 지정합니다. 위 예제 코드처럼 중첩하여 사용할 수 있으며 테스트를 구분하는 section이라고 표현할 수 있겠습니다. 그리고 실행해야하는 부분(단위 테스트 단위)을 콜백으로 넘겨줍니다. it 구문에는 단위 테스트 이름을 작성하고 실제 실행되는 코드를 콜백(done)으로 넘겨줍니다. 그런 다음, package.json에 작성했던 npm test 명령어를 통해 test를 실행해줍니다.12345$ npm test sum 함수 테스트 ✓ 10과 20를 넘기면 30이 나와야 한다. 1 passing (2ms) 이렇게 나왔으면 테스트가 통과한 것입니다. done() 메소드가 실행되면 테스트가 통과하도록 테스트 코드를 작성할 수 있습니다. result === 40처럼 옳지 않은 값을 넣어주면, throw Error()가 실행되면서 테스트가 실패했다는 메세지가 나타납니다. Mocha의 hookMocha에서는 추가적으로 네 가지의 함수를 제공합니다. 각각은 테스트 코드가 실행되기 전과 후에 실행되는 함수입니다. before: 테스트 코드가 실행되기 전에 한 번 실행된다. beforeEach: (테스트가 여러 개일 경우) 각각의 테스트 코드가 실행되기 전마다 실행된다. afterEach: (테스트가 여러 개일 경우) 각각의 테스트 코드가 실행된 후마다 실행된다. after: 모든 테스트 코드가 실행된 후 한 번 실행된다. 123456789101112131415161718192021222324describe('operator.js Test', () =&gt; &#123; describe('sum 함수 테스트', () =&gt; &#123; before(() =&gt; &#123; console.log(\"before\"); &#125;); beforeEach(() =&gt; &#123; console.log(\"beforeEach\"); &#125;); it ('10과 20를 넘기면 30이 나와야 한다.', (done) =&gt; &#123; let result = sum(10, 20); if (result === 30) &#123; done(); &#125; else &#123; throw Error('결과 값이 30이 아니다.'); &#125; &#125;); after(() =&gt; &#123; console.log(\"after\"); &#125;); afterEach(() =&gt; &#123; console.log(\"afterEach\"); &#125;); &#125;);&#125;); 각각 상황에 맞는 console.log()를 찍어줬습니다. npm test 명령어를 실행해보겠습니다.12345678910$ npm test operator.js Test sum 함수 테스트beforebeforeEach ✓ 10과 20를 넘기면 30이 나와야 한다.afterEachafter 1 passing (3ms) 각각의 함수들이 위치하는 라인은 상관이 없습니다. 가독성이 좋기 위해 의미상으로 적절한 위치에 코드를 작성했습니다. 정말 간단하게 Mocha를 사용해봤습니다. if문을 통한 테스트 코드 작성이 너무 지저분했는데요, 이제 Mocha와 함께 Chai를 사용해보겠습니다! &gt;&gt;Chai 테스트 프레임워크 &gt;&gt; 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. [TDD] 1. end","categories":[{"name":"Tool","slug":"Tool","permalink":"https://jaeyeophan.github.io/categories/Tool/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"https://jaeyeophan.github.io/tags/TDD/"}]},{"title":"[ES6] 10. Generator","slug":"ES6-10-Generator","date":"2017-04-22T08:49:54.000Z","updated":"2017-04-24T08:58:05.000Z","comments":true,"path":"2017/04/22/ES6-10-Generator/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/22/ES6-10-Generator/","excerpt":"","text":"[ES6] 10. GeneratorGenerator는 무엇인가?Generator function으로 반환된 값을 Generator Object라고 하고 이 Generator Obejct는 iterator 프로토콜을 따르고 있다. 즉 [Symbol.iterator]가 프로퍼티에 추가되어 있다는 것이다. Generator function안에서는 yield라는 키워드를 사용해서 함수에 내부에 작성된 코드를 전부 실행하지 않는다. 제너레이터 함수는 yield를 기준으로 실행을 나누어서 진행한다. iterator프로토콜을 따르고 있기 때문에 순차적으로 실행할 수 있는 것이다.cf&gt;Generator function를 제너레이터 함수로, Generator Object를 제너레이터 오브젝트로 표기. Generator Functionfunction*로 표현할 수 있으며, 작성할 때는 일반 function처럼 선언문과 표현식으로 작성할 수 있다.1234function* calc(prev, post) &#123; console.log(\"generator start\"); yield prev + post;&#125; or1234let calc = function*(prev, post) &#123; console.log(\"generator start\"); yield prev + post;&#125; 제너리에터 함수에 의해 반환되는 값은 제너레이터 오브젝트이다.12let generator = calc(1, 2);console.log(typeof generator); // object 제너레이터 오브젝트를 반환하는 순간에는 오브젝트를 반환하기만 할 뿐, 내부 코드는 실행되지 않는다. Generator Objectnew 키워드를 사용하여 인스턴스를 생성할 수 없다.12let cal = new calc();// Error//TypeError: calc is not a constructor next() 메소드를 통해 제너레이터 함수를 실행시킬 수 있다.12345console.log(generator.next());//generator start//&#123; value: 3, done: false &#125;console.log(generator.next());//&#123; value: undefined, done: true &#125; iterator의 next()메소드를 실행시킨 것처럼 value와 done이라는 프로퍼티를 갖고 있는 객체로 반환된다. 그런데 첫번째 next()메소드 실행 시에는 generator start가 출력되었는데, 두번째 실행 시에는 출력되지 않았다. yield라는 키워드를 중심으로 함수가 나눠 실행되는 것이다. yield 키워드, 함수를 실행하고 멈출 수 있다.1[returnValue] = yield[expression] 위와 같은 구문으로 yield를 작성할 수 있다. 위의 예제 코드에서 살펴봤듯이, next() 메소드의 반환 값은 value와 done으로 구성되어 있는 오브젝트이다. 제너레이터의 메소드 next()에서 이 두 가지의 값은 yield에 의해 결정된다. value가 결정되는 규칙이 조금 복잡하다. value 결정 규칙 expression으로 반환되는 값이 할당.이 때, expression에 있는 값이 returnValue에 할당되지 않는다. expression에 아무것도 없으면 undefined가 할당.이 때, next()의 파라미터로 넘겨지는 값이 returnValue에 할당된다. done 결정 규칙 계속 수행할 yield가 남아있으면 false. 더 이상 실행할 yield가 없으면 true. 예제 코드를 살펴보자.123456789101112function* calc(prev, post) &#123; let result = 0; console.log(`Initial result: $&#123;result&#125;`); result = yield prev + post; console.log(`Middle result: $&#123;result&#125;`); result = yield; console.log(`Last result: $&#123;result&#125;`);&#125;let generator = calc(10, 20); 위에서 언급한 규칙에 대한 내용을 모두 담고 있는 예제코드이다. console.log()에는 어떠한 값이 찍히게 될까? 코드를 통해 하나씩 살펴보자.123console.log(generator.next());// Initial result: 0// &#123; value: 30, done: false &#125; next() 메소드를 실행시키면 첫번째 yield까지 실행한다.초기 result 변수에 대한 값이 출력되고,expression으로 계산된 값인 30이 value이 출력된다.아직 yield가 남았으니 done은 false가 되겠다. 123console.log(generator.next());// Middle result: undefined// &#123; value: undefined, done: false &#125; 두번째 yield까지 실행한다.expression 값이 result에 할당되지 않은 것을 확인할 수 있다.아직 yield가 남았으니 done은 false가 되겠다. 123console.log(generator.next(20));// Last result: 20// &#123; value: undefined, done: true &#125; yield가 없으므로 brace까지 실행한다.next()메소드의 파라미터로 넘겨진 20이 result 변수에 할당된 것을 확인할 수 있다.더이상 yield 키워드가 없으므로 done은 true가 된다. yield 대신 return1234567function* calc(prev, post) &#123; return prev + post;&#125;let generator = calc(10, 20);console.log(generator.next());// &#123; value: 30, done: true &#125; return 키워드 뒤에 오는 값이 value에 할당되고 yield 키워드의 유무와 상관없이 done에는 true가 할당된다. return은 수행되고 있는 이터레이터를 종료시키는 역할을 수행한다. 이터레이터 종료하기yield 키워드의 유무와 상관없이 이터레이터를 종료하고자 할 때는 제너레이터 오브젝트의 throw()메소드와 return()메소드를 사용할 수 있다. 123456789101112function* idMaker(prev, post) &#123; let value = 0; while(true) &#123; yield ++value; &#125;&#125;let g = idMaker();console.log(g.next());// &#123; value: 1, done: false &#125;console.log(g.next());// &#123; value: 2, done: false &#125;console.log(g.next());// &#123; value: 3, done: false &#125;console.log(g.return(100));// &#123; value: 100, done: true &#125; return()메소드의 파라미터로 넘어가는 값이 value에 할당된다.위의 예제 코드에 return() 대신 throw()를 호출하게 되면 파라미터로 넘겨준 Error Message를 출력하고 이터레이터가 바로 종료된다.123456789101112131415161718function* idMaker(prev, post) &#123; let value = 0; try &#123; while(true) &#123; yield ++value; &#125; &#125; catch(e) &#123; console.log(`Error message: $&#123;e&#125;`); &#125;&#125;let g = idMaker();console.log(g.next());// &#123; value: 1, done: false &#125;console.log(g.next());// &#123; value: 2, done: false &#125;console.log(g.next());// &#123; value: 3, done: false &#125;console.log(g.throw(\"Throw Exception\"));//Error message: Throw Exception//&#123; value: undefined, done: true &#125; 여기서 try-catch 구문에 yield를 추가하면 어떻게 될까?123456789101112131415161718function* idMaker(prev, post) &#123; let value = 0; try &#123; while(true) &#123; yield ++value; &#125; &#125; catch(e) &#123; yield e; &#125;&#125;let g = idMaker();console.log(g.next());// &#123; value: 1, done: false &#125;console.log(g.next());// &#123; value: 2, done: false &#125;console.log(g.next());// &#123; value: 3, done: false &#125;console.log(g.throw(\"Throw Exception\"));//&#123; value: 'Throw Exception', done: false &#125;console.log(g.next());// &#123; value: undefined, done: true &#125; 바로 이터레이터가 종료되지 않고 yield 다음의 구문이 실행된다. yield* 키워드yield에 *를 붙인 다음 [expression]에 이터러블 오브젝트를 작성할 수 있다. 이렇게 되면 해당 yield가 수행될 때 이터러블 오브젝트를 순회하게 된다. 코드를 통해 살펴보자.123456789101112function* gen() &#123; yield 1; yield* [10, 20, 30]; yield 2;&#125;let g = gen();console.log(g.next());// &#123; value: 1, done: false &#125;console.log(g.next());// &#123; value: 10, done: false &#125;console.log(g.next());// &#123; value: 20, done: false &#125;console.log(g.next());// &#123; value: 30, done: false &#125;console.log(g.next());// &#123; value: 2, done: false &#125;console.log(g.next());// &#123; value: undefined, done: true &#125; 우선적으로 배열을 순회한 후에, 다음에 해당하는 yield를 수행하게 된다. 마무리문법을 아는 것과 실제 프로그래밍에서 적용하는 것은 확실히 다른 문제이다. 지금 yield의 향연을 보고 이걸 어디에다가 쓰나 하는 생각이 들 것이다. 다음 링크들을 참고하면 좀 나아질 것 같아서, 몇 가지 링크를 첨부한다. ES6의 제너레이터를 사용한 비동기 프로그래밍Javascript의 Generator와 Koa.js자바스크립트와 비동기 오류 처리 ReferenceMDN function* 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 10. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"YARN, 새로운 Package Manger","slug":"YARN-New-Package-Manger","date":"2017-04-21T10:18:49.000Z","updated":"2017-04-21T13:13:49.000Z","comments":true,"path":"2017/04/21/YARN-New-Package-Manger/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/21/YARN-New-Package-Manger/","excerpt":"","text":"YARNYARN이란 Facebook에서 만든 새로운 자바스크립트 패키지 매니저입니다. 기존에 존재하는 npm과 동일한 기능을 수행합니다. 그렇다면 Facebook은 YARN을 왜 만들었을까요? 이 부분에 대해서는 정리가 잘 되어 있는 링크를 첨부할게요!&gt;새로운 NPM Client YARN&gt; YARN 설치하기1$ brew install yarn Homebrew를 통하여 설치할 수 있습니다.1$ yarn --version 어느 모듈이나 마찬가지로 설치된 version을 확인할 수 있습니다. YARN 사용하기새 프로젝트 시작하기1$ yarn init npm과 마찬가지로 init이라는 명령어를 통해 시작할 수 있으며, package.json파일이 없는 경우에는 대화형 인터페이스가 출력되면서 프로젝트를 설정할 수 있습니다. 이미 package.json이 존재하는 경우에는 해당 파일을 재사용하게 됩니다. 패키지 설치하기123$ yarn add [package_name]$ yarn add [package_name]@[version]$ yarn add [package_name]@[tag] add라는 command로 패키지를 설치(add)할 수 있습니다. @로 설치할 version과 tag를 명시할 수 있습니다. add option1$ yarn add [package_name] --dev / -D 해당 패키지가 devDependencies에 추가됩니다.1$ yarn add [package_name] --peer / -P 해당 패키지가 peerDependencies에 추가됩니다.1$ yarn add [package_name] --optional / -O 해당 패키지가 optionalDependencies에 추가됩니다.1$ yarn add [package_name] --exact / -E @로 version을 명시할 수 있지만, 보다 strict하게 version을 명시하여 설치하는 경우에 사용합니다.1$ yarn add [package_name] --tilde / -T 기본적으로 가장 최근 release version의 패키지를 설치하지만, 좀 더 최신의 version을 설치하는 경우에 사용합니다. 패키지 업그레이드123$ yarn upgrade [package_name]$ yarn upgrade [package_name]@[version]$ yarn upgrade [package_name]@[tag] upgrade라는 명령어를 통해 설치한 패키지를 업그레이드 할 수 있습니다. 모듈 제거1$ yarn remove [package] remove라는 명령어를 통해 설치한 패키지를 제거할 수 있습니다. 다른 Command1$ yarn global [add/ls/remove/upgrade] npm에서의 --global 와 비슷한 기능을 수행하는 global 이 추가된 명령어입니다.1$ yarn clean clean 명령어는 현재 설치된 패키지들의 의존성을 분석하여 사용하지 않는, 불필요한 파일들을 제거해줍니다. 이 명령어를 한 번 실행하면 .yarnclean 파일이 생성되며 version control에 추가해야 합니다. 한 번 실행된 후, 불필요한 파일들을 제거해주는 작업은 yarn 커맨드를 통해 어떠한 패키지를 설치하는 경우(add or run command)에 자동적으로 수행됩니다.1$ yarn info [package_name] [option] info 명령어를 통해 해당 패키지의 정보를 볼 수 있습니다. option으로 readme를 입력하게 되면 해당 패키지에 작성된 README.md파일을 볼 수 있습니다.(다양한 option command가 존재합니다!)1$ yarn list [--depth] list 명령어를 통해 현재 작업 중인 디렉토리의 모든 패키지들의 의존성 관계를 리스트로 확인할 수 있습니다. depth 옵션을 통해서 level을 지정할 수도 있습니다.1$ yarn outdated [package] outdated 명령어를 통해 패키지들의 현재 설치된 version(Current)과 권장하는 version(Wanted), 최신 version(Latest)을 보여줍니다. 특정 [package]를 입력하여 원하는 패키지에 대해서만 볼 수 있습니다.1$ yarn pack pack 명령어를 통해 패키지의 의존성들을 gzip으로 압축시킬 수 있습니다.1$ yarn run [script] [--&lt;args&gt;] run 명령어를 통해 npm에서 처럼 package.json에서 정의한 scripts를 실행할 수 있습니다. 거의 모든 명령어가 기존에 사용하던 npm과 동일한 것을 확인하실 수 있었습니다 :) yarn.lockyarn으로 모듈을 설치하다보면 yarn.lock이라는 파일이 생성된 것을 확인할 수 있다. 이것은 설치한 모듈들의 각각 의존성 관리를 해줍니다.이미 package.json이 하고 있는거 아닌가? 라는 생각이 드는데요, 하지만 페이스북이 yarn을 만든 이유 중 하나는 보다 정확하게 패키지들의 의존성을 관리하기 위함이었습니다. yarn.lock 파일에는 package.json에 있는 것보다 더 많은 정보를 갖고 있습니다. 그렇기 때문에 좀 더 엄격한 의존성 관리가 가능하다고 합니다. (위에서 언급한 .yarnclean파일과 함께 version control system에 추가해줘야 합니다.) 마무리기존의 NPM과 많이 다를 줄 알고 열심히 정리했는데 거의 정말 비슷하네요! 같은 값이면 다홍치마라고, 좀 더 빠르고 의존성 관리를 정확하게 해주는 YARN으로 옮겨갈 때인가요? 이상 YARN에 대한 포스팅이었습니다 :) 참고할 만한 링크 YARN vs NPM YARN Cheet Sheet","categories":[{"name":"Tool","slug":"Tool","permalink":"https://jaeyeophan.github.io/categories/Tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://jaeyeophan.github.io/tags/tool/"}]},{"title":"[ES6] 9. Iterator","slug":"ES6-9-Iterator","date":"2017-04-21T08:15:09.000Z","updated":"2017-04-21T08:18:11.000Z","comments":true,"path":"2017/04/21/ES6-9-Iterator/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/21/ES6-9-Iterator/","excerpt":"","text":"[ES6] 9. Iterator&gt;&gt;3. Iterable and for-of statement&gt;&gt;&gt;&gt;8. Symbol 이 포스팅은 이전에 작성된 두 포스팅을 기반으로 작성되었습니다. iterator는 순회 가능한 값들의 시퀀스를 만드는 방법을 정의한다.대표적인 순회 가능한 것은 Array다. Array 오브젝트는 Symbol.iterator를 가지고 있다.12let arr = [1, 2, 3];console.log(typeof arr[Symbol.iterator]);// function 위 예제 코드에서 정의한 arr의 iterator를 추출하여 arr를 순회할 수 있다.12345let iterator = arr[Symbol.iterator]();console.log(iterator.next());// &#123;value: 1, done: false&#125;console.log(iterator.next());// &#123;value: 2, done: false&#125;console.log(iterator.next());// &#123;value: 3, done: false&#125;console.log(iterator.next());// &#123;value: undefined, done: true&#125; iterator를 추출하자마자 head(공식 용어는 아니고 설명을 위한 용어)는 배열의 시작점을 가리키게 된다.(첫 원소를 가리키는 것이 아니다.) 그 상태에서 next()메소드를 호출하게 되면, 첫번재 원소가 출력된다. 출력 값은 원소의 값인 value와 done이라는 boolean 값을 가지고 있는 Object이다. 마지막 원소까지 출력된 상태에서 next() 메소드를 호출하게 되면 value는 undefined가 되고 done 값은 true가 된다. 문자열에도 적용할 수 있다. String 오브젝트도 iterable프로토콜을 구현한 오브젝트이기 때문에 iterator를 사용할 수 있는 것이다.1234567let name = \"jbee\";let iterator = name[Symbol.iterator]();console.log(iterator.next());// &#123;value: j, done: false&#125;console.log(iterator.next());// &#123;value: b, done: false&#125;console.log(iterator.next());// &#123;value: e, done: false&#125;console.log(iterator.next());// &#123;value: e, done: false&#125;console.log(iterator.next());// &#123;value: undefined, done: true&#125; Object에는 기본적으로 iterator가 존재하지 않는다. 때문에 for-of로 순회할 수 없다. 하지만 iterator를 오브젝트에 추가하여 iterable하게 만들 수 있다. 또한 배열을 상속받은 객체는 iterable 객체이므로 iterator를 사용할 수 있다. iterator를 사용하다 보면 뭔가 Java의 interface 또는 @FunctionalInterface 같은 느낌도 든다. java에서 해당 interface를 implements하게 되면 해당 기능을 사용할 수 있는 것처럼 구현하고자 하는 Symbol, 즉 iterator를 프로퍼티에 추가해서 사용하면 iterator 기능을 사용할 수 있는 것이다. 어떻게 하면 iterator를 그럴싸하게 사용해볼 수 있을까?다음 예제는 이렇게 사용하면 어떨까? 정도의 예제 코드이다. 가볍게 보고 넘어가자.12345678910111213141516171819202122232425// Object to create idlet autoIncrement = &#123; [Symbol.iterator]() &#123; let id = 0; return &#123; next() &#123; return &#123; value: ++id, done: false &#125; &#125; &#125; &#125;&#125;// Define User classclass User &#123; constructor(id, name) &#123; this.id = id; this.name = name; &#125;&#125;const idCreator = autoIncrement[Symbol.iterator]();console.log(new User(idCreator.next().value, \"jbee\"));// &#123; id: 1, name: 'jbee' &#125;console.log(new User(idCreator.next().value, \"foo\"));// &#123; id: 2, name: 'foo' &#125;console.log(new User(idCreator.next().value, \"bar\"));// &#123; id: 3, name: 'bar' &#125; autoIncraement 객체에 iterator 프로퍼티를 추가하여, id를 순차적으로 생성하게 만들었다. id에 대해서는 외부에서 접근할 수 없으므로 안정적인 id가 생성될 수 있지 않을까? 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 9.end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 8. Symbol","slug":"ES6-8-Symbol","date":"2017-04-20T02:53:45.000Z","updated":"2017-05-02T06:54:15.000Z","comments":true,"path":"2017/04/20/ES6-8-Symbol/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/20/ES6-8-Symbol/","excerpt":"","text":"[ES6] 8. SymbolSymbol이란 무엇인가? 고유하고 수정 불가능한 데이터 타입(?) 자바스크립트에는 Primitive type이라는 개념이 있다. ES5에는 string, number, boolean, null, undefined로 총 5가지의 원시 자료형이 존재한다. 여기에 ES6부터 symbol이라는 타입이 추가되었다. Primitive type들에게는 각각 Wrapper Object가 존재한다.(undefined와 null은 wrapper object가 존재하지 않는다.) String 오브젝트, Boolean오브젝트가 그 예이다. symbol도 마찬가지로 Symbol 오브젝트라는 wrapper Object가 존재한다. 각각의 wrapper obect에는 값을 처리하기 위한 메서드와 프로퍼티가 존재한다. valueOf()메소드를 통해 primitive value를 구할 수 있는 것이다. 하지만, symbol은 값을 반환하지 않는다! Symbol 도입 배경 왜 Symbol이 도입되었을까? 처음 Symbol을 봤을 때는 고유한 값이라는 말에 const를 떠올렸다. 하지만 Symbol은 프로그램 전체를 통틀어 유일한 값을 의미한다. Symbol()이 실행될 때마다 유일한 값을 생성하는 것이다. 약속된 Symbol 값을 가지고 객체에 어떠한 특성을 부여할 수 있지 않을까? Symbol이란 무엇인가 먼저 알아보자.(사실 라이브러리를 만들거나 프레임워크를 만들지 않는 이상, 실무에서 사용할 일이 거의 없을 것 같다.) Symbol에 대해서Symbol은 두 가지 스코프(scope)에 생성하여 저장할 수 있다. Symbol 생성하기 112let s = new Symbol(\"symbol description\");//Error: Symbol is not a constructor Symbol은 객체가 아니다. 객체가 아닌 Primitive type이기 때문에 new키워드를 통해서 생성할 수 없다.Symbol을 생성할 때에는 다음과 같이 생성한다. 1let s = Symbol(\"symbol description\"); console.log()를 통해 Symbol의 특징을 살펴보자.1234console.log(typeof s);//symbolconsole.log(s.toString());//Symbol(symbol description)console.log(s.valueOf());//&#123;&#125;console.log(s);//&#123;&#125; 1) Symbol의 타입은 symbol이다.2) 모든 built-in 오브젝트의 프로토타입에 연결되어 있는 toString 메소드를 통해서 Symbol의 형태(description)를 확인할 수 있다. 여기서 형태란 Symbol을 생성할 때 넘겨지는 parameter를 말한다. 주로 생성하는 Symbol을 설명하기 위한 문자열을 넘겨준다. 왠지 이 값을 통해 Symbol에 접근할 수 있을 것 같지만 그럴 수 없다.3) 뒤에서 확인할 테지만 Symbol은 값을 외부로 노출시키지 않는다. 이러한 특성 때문에 Symbol을 출력하려고 하거나 valueOf() 메소드를 통해 값을 출력하려고 하면 empty object가 반환이 된다. 12345let s1 = Symbol(\"foo\");let s2 = Symbol(\"foo\");console.log(\"s1: \", s1.toString());//Symbol(foo)console.log(\"s2: \", s2.toString());//Symbol(foo)console.log(s1 == s2);//false 두 Symbol은 같은 description을 갖고 있는 Symbol일 뿐, 다른 Symbol이다. Symbol()이 호출될 때마다 새로운 Symbol을 생성하기 때문이다. 이 때 Symbol은 생성한 scope에 Symbol값이 설정된다. Symbol 생성하기 2, key아까 생성한 Symbol을 다시 사용할 니즈가 있을 것 같다. 그래서 고유한 값을 갖는 Symbol을 만들 때, key를 등록하고, key를 통해 접근한다. for 메소드for 메소드를 사용하여 생성 또는 호출할 수 있다. key 값이 파라미터로 넘어가고 등록되어 있는 Symbol을 반환한다. 이 때 key 값에 해당하는 Symbol이 없다면 해당 Symbol을 Symbol registry에 등록한다. 즉 없으면 생성하는 것이다. keyFor 메소드keyFor 메소드는 Symbol을 받아서 해당 Symbol의 description 값을 반환한다. 12345678let sFor1 = Symbol.for(\"foo\");let sFor2 = Symbol.for(\"foo\");console.log(sFor1.toString());//Symbol(foo)console.log(sFor2.toString());//Symbol(foo)console.log(Symbol.keyFor(sFor1));//fooconsole.log(Symbol.keyFor(sFor2));//fooconsole.log(sFor1 == sFor2);//trueconsole.log(sFor1 === sFor2);//true 같은 key값으로 Symbol을 호출하게 되면 두 Symbol은 같은 Symbol이다. 위에서 그냥 Symbol()을 통해 생성한 것과의 차이점은 key값과 함께 Symbol을 만들게 되면 Global Symbol registry에 해당 Symbol이 등록되어 Symbol()이 호출될 때마다 새로운 Symbol이 생성되지 않는다.cf&gt; Global Symbol registry란 Symbol값을 공유하기 위한 영역으로 다른 자바스크립트 프레임워크에서도 공유할 수 있다. Symbol 특징 1위의 예제에서도 살펴봤듯이, Symbol은 값을 외부에 노출시키지 않는다.123let sym = Symbol(\"symbol description\");console.log (`symbol: $&#123;sym&#125;`);//TypeError: Cannot convert a Symbol value to string 그렇기 때문에 Template literal에서 사용할 수 없다. 또한 JSON.stringify()메소드를 통해서 특정 오브젝트를 stringify하려고 해도 빈 객체가 리턴된다.123456let sym = Symbol(\"symbol description\");let obj = &#123; [sym]: \"value\"&#125;let str = JSON.stringify(obj);console.log(str);//&#123;&#125; 값을 외부에 노출시키지 않기 때문이다. Symbol 특징 2객체에 Symbol로 등록된 프로퍼티를 symbol-keyed property라고 하는데 이 symbol-keyed property는 Object의 getOwnPropertyNames 반환 값에서 제외된다.user.js123456let user = &#123; [Symbol.for(\"name\")] : \"jbee\", age : 25, major: \"Computer Science\"&#125;console.log(Object.getOwnPropertyNames(user));//['age', 'major'] 그렇기 때문에 for-in statement에서 열거되지 않는다. user.js123456for (let item in user) &#123; console.log(item);&#125;console&gt;agemajor Object의 symbol-keyed property는 getOwnPropertySymbols() 메소드를 통해 확인할 수 있다.user.js1console.log(Object.getOwnPropertySymbols(user)[0].toString());//Symbol(name) symbol-keyed property로 value에 접근할 때는 []를 통해 접근해야 한다. .을 통해 접근하면 undefined가 반환된다.123456const sym = Symbol.for(\"name\");let user = &#123; [sym] : \"jbee\",&#125;console.log(user.sym);//undefinedconsole.log(user[sym]);//jbee .(dot)을 통해서 getOwnPropertyNames에서 반환되는 일반적인 프로퍼티에 접근했다면 symbol-keyed property에는[]을 통해 접근하는 것이라고 생각해볼 수 있겠다. Well-known Symbolsbuilt-in Symbol property로 Override하여 기능을 추가 및 변경할 수 있다. 대표적인 세 가지에 대해 알아보자.(iterator는 다음 포스팅에서 따로 다룬다.) Symbol.toStringTag객체의 기본 설명(description)에 사용되는 문자열 값을 지정할 수 있으며 Object.prototype.toString() 메소드가 호출될 때 사용된다.123456789101112131415161718class User &#123; constructor(name) &#123; this.name = name &#125;&#125;let user = new User(\"jbee\");console.log(user.toString());//[object Object]let obj = &#123; name: \"jbee\"&#125;console.log(obj.toString());//[object Object]User.prototype[Symbol.toStringTag] = \"User\";Object.prototype[Symbol.toStringTag] = \"Obj\";console.log(user.toString());//[object User]console.log(obj.toString());//[object Obj] new 키워드를 통해 생성한 인스턴스와 객체 리터럴로 생성한 객체 둘 다 [object Object]라는 값으로 출력되기 때문에 구분하는 것이 어렵다. toStringTag 프로퍼티를 오버라이드하여 customize할 수 있다. Symbol.toPrimitive1234let values = [1, 2, 3];let sum = values + 100;console.log(sum);//1,2,3100console.log(typeof sum);//string 배열이 string으로 casting이 되고 그 뒤에 연산되는 100 마저 string으로 casting이 된다. 그래서 결과값이 string타입의 1,2,3100이 되는 것이다.12345678910111213//overridingvalues[Symbol.toPrimitive] = function(hint) &#123; console.log(hint); let result = 0; for (let item of values) &#123; result += item; &#125; return result;&#125;let sum2 = values + 100;console.log(\"sum2: \", sum2);//106console.log(typeof sum2);//number 위 예제 코드에서는 toPrimitive라는 값을 통해서 배열의 값이 어떻게 반환될 지를 결정한다. 이 예제 코드에서는 배열의 모든 element 값을 더한 값으로 설정했다.hint라는 값을 console로 찍어보기만 하고 아직 사용하지 않았는데, 이 hint 값을 통해서 어떠한 형태로 반환할 지 분기를 나눌 수 있다. 다음 코드를 살펴보자.12345678910111213141516let obj = &#123; [Symbol.toPrimitive](hint) &#123; if (hint === \"number\") &#123; return 1; &#125; if (hint === \"string\") &#123; return \"문자열\"; &#125; return \"default\"; &#125;&#125;console.log (\"default: \", 100 + obj);//100defaultconsole.log (\"number: \", 1 * obj);//number: 1console.log (`string: $&#123;obj&#125;`);//string: 문자열console.log(+obj +1);//2 [Symbol.toPrimitive]()가 호출되면 자바스크립트 엔진은 parameter인 hint에 number, string, default 셋 중 하나를 설정하게 된다. 엔진은 어떻게 hint값을 설정할까? 네 개의 console을 찍어봤다. 100 + obj에서는 obj가 피연산자(연산 대상)이므로 default가 설정된다. 1 * obj에서는 *연산 때문에 number가 설정된다. (곱셈 말고도 뺄셈, 나눗셈도 number가 설정된다.) ${obj}에서는 Template literal로 사용되었으므로 string이 설정된다. +obj +1에서는 +라는 단항 연산자가 obj앞에 붙어서 number가 설정된다. Symbol.isConcatSpreadableArray 오브젝트의 concat()이라는 함수를 호출할 때의 상황을 지정하는 프로퍼티다. 두 배열을 결합할 때, 배열의 펼침 여부를 지정할 수 있다. default value는 true이다. 다음 예제 코드를 살펴보자.12345678let prev = [1, 2];let post = [3, 4];console.log(prev.concat(post));//[1, 2, 3, 4]prev[Symbol.isConcatSpreadable] = false;console.log(prev.concat(post));//[[1, 2], 3, 4]post[Symbol.isConcatSpreadable] = false;console.log(prev.concat(post));//[[1, 2], [3, 4]] 배열을 결합할 때, 펼치지 않고(프로퍼티 값을 false로 지정하고) 결합을 하게 되면, 배열의 구조를 그대로 유지하면서 합쳐진다. Array-like 오브젝트에서도 concat() 함수의 결과 형태를 지정할 수 있다. 정리이 이외에도 @@iterator, @@hasInstance, @@replace, @@species 등 다양한 Well-known Symbol들이 존재한다. 이 Well-known Symbol들은 이미 ES5 스펙에서부터 존재했었고 자연스럽게 그것들을 사용해왔던 것이고 ES6에서 각 프로퍼티들을 오버라이드하여 좀 더 유연한 코드를 작성할 수 있게 끔 공개된 것이다.cf&gt; @@은 Symbol 대신 사용할 수 있는 약자이다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. Symbol과 관련된 다른 글들 (ES6) Symbol - 양권성님 블로그 글 8. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 7. Template literal","slug":"ES6-7-Template-literal","date":"2017-04-19T07:26:04.000Z","updated":"2017-04-19T07:30:41.000Z","comments":true,"path":"2017/04/19/ES6-7-Template-literal/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/19/ES6-7-Template-literal/","excerpt":"","text":"[ES6] 7. Template literal1console.log(`template literal`); ES6에서 문자열 처리를 보다 간편하게 할 수 있는 템플릿을 제공한다. 문자열 처리를 위해 single quote나 double quote가 아닌 Backtick을 사용한다. 변수를 ${ }로 감싸서 inline으로 표현할 수 있으며 \\n을 작성할 필요없이 Backtick 안에서 개행을 해주면 된다. 기존의 템플릿 엔진들에서 제공하고 있었던 기능인 ${ } 안에는 변수 또는 연산식 등의 표현식이 들어갈 수 있다.Example code&gt;12345678910111213141516let name = \"jbee\";//ES5console.log(\"Hi, \" + name + \"!\\nHave a nice day!\");// console&gt;// Hi, jbee!// Have a nice day!//ES6let grettingTemplate = `Hi, $&#123;name&#125;!Have a nice day!`;console.log(grettingTemplate);//console&gt;// Hi, jbee!// Have a nice day! Template literal을 사용하여 거추장스러운 &#39;+&#39;이나 &#39;\\n&#39;을 더이상 사용하지 않아도 된다. tagged template1234let name = \"jbee\"let num = 27;console.log(`hi, $&#123;name&#125;! Have a nice day! $&#123;num&#125; is your number`);//console&gt; hi, jbee! Have a nice day! 27 is your number 위 템플릿 리터럴을 tagged template을 사용하여 text와 value로 분리할 수 있다. text는 공백 문자를 기준으로 배열의 형태로 파라미터가 들어오며, ${ } 안의 표현식은 value라는 파라미터로 String type으로 들어온다.123456789function greet(text, value) &#123; console.log(text); console.log(value); console.log(typeof value);&#125;greet `hi, $&#123;name&#125;! Have a nice day! $&#123;num&#125; is your number`;//console&gt; [ 'hi, ', '! Have a nice day! ', ' is your number' ]//console&gt; jbee//console&gt; string parameter로 넘겨지는 value는 하나인데, 템플릿 리터럴에는 표현식이 두개가 존재한다. 그렇기 때문에 number에 해당하는 값이 함수로 넘겨지지 못했다.123456789function greet(text, value, value2) &#123; console.log(text); console.log(value); console.log(value2);&#125;greet `hi, $&#123;name&#125;! Have a nice day! $&#123;num&#125; is your number`;//console&gt; [ 'hi, ', '! Have a nice day! ', ' is your number' ]//console&gt; jbee//console&gt; 27 이렇게 해결할 수 있지만, 지난 chapter에서 다룬 Rest parameter를 사용할 수 있다.1234567function greet(text, ...value) &#123; console.log(text); console.log(value);&#125;greet `hi, $&#123;name&#125;! Have a nice day! $&#123;num&#125; is your number`;//console&gt; [ 'hi, ', '! Have a nice day! ', ' is your number' ]//console&gt; [ 'jbee', 27 ] 템플릿 리터컬의 표현식 값 결정템플릿 리터럴을 사용하여 문자열을 함수의 파라미터를 넘길 수 있을 것이다. 그렇다면 템플릿 러터럴 내부의 표현식의 값은 언제 결정될까?123456789//Assign expression statementfunction greeting(message) &#123; let name = `ecmascript`; console.log(message);&#125;let name = `jbee`;greeting(`Hi, $&#123;name&#125;`);//console&gt; Hi, jbee 함수의 파라미터로 넘겨질 때부터 결정되어 넘어가기 때문에 greeting이라는 함수 내부에 있는 local variable인 ecmascript라는 단어가 name으로 들어가지 않고 jbee라는 문자열이 name의 값으로 결정되었다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 7. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[TS] 0. Quick Start","slug":"TS-0-Quick-Start","date":"2017-04-19T04:49:15.000Z","updated":"2017-04-19T07:30:58.000Z","comments":true,"path":"2017/04/19/TS-0-Quick-Start/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/19/TS-0-Quick-Start/","excerpt":"","text":"[TS] 0. Quick Start이 포스팅은 TypeScript Official Document를 번역 및 의역한 자료입니다. 직접 타이핑 해본 결과 5분정도 소요되는 짧은 Quick start 입니다:) 가볍게 봐주세요. Install TypeScriptnpm을 통해서 간단하게 TypeScript를 설치할 수 있습니다. VSCode 등 타입스크립트를 지원하는 에디터에서는 플러그인을 통해서 설치가 가능합니다. via npm1$ npm install -g typescript command를 이용하여 또는 Editor를 열어 greeter.ts라는 파일을 만듭니다.1$ touch greeter.ts greeter.ts코드는 다음과 같습니다.1234567function greeter(person) &#123; return \"Hello, \" + person;&#125;var user = \"Jane User\";document.body.innerHTML = greeter(user); TypeScript는 .ts라는 확장자를 사용합니다. 이 파일은 컴파일되어 greeter.js파일이 됩니다.1tsc greeter.ts tsc라는 명령어를 통해서 TypeScript로 작성된 파일을 컴파일할 수 있습니다.현재 greeter.ts에 작성되어있는 코드는 기존의 JavaScript와 다를 바가 없습니다. 이 JavaScript code인 greeter.ts에 TypeScript 문법을 하나씩 추가해보겠습니다. TypeScript가 제공하는 대표적인 기능Type annotations동적으로 변수의 타입을 결정했던 JavaScript에게 타입이 생겼습니다.123function greeter(person: string) &#123; //...&#125; TypeScript는 Type을 제공합니다. Type annotations는 함수가 받는 parameter에 타입을 지정해주어, 함수 내부에서 별도의 타입 체크 없이 parameter를 사용할 수 있게 해줍니다. 즉, person에 다른 타입의 parameter가 주어지면 error가 발생하게 됩니다.1234567function greeter(person: string) &#123; return \"Hello, \" + person;&#125;var user = [0, 1, 2];document.body.innerHTML = greeter(user); error:1greeter.ts(7,26): Supplied parameters do not match any signature of call target 타입스크립트는 코드의 구조와 작성된 type annotation으로 정적 분석을 제공합니다. 위와 같이 error가 발생하더라도 타입스크립트 파일은 컴파일되어 .js파일을 만들게 됩니다. TypeScript의 역할은 제대로 동작하지 않을 것 같은 코드에 대해 개발자에게 warning해주는 역할이라고 생각해도 될 것 같습니다 :) InterfaceJava개발자라면 익숙한 interface 문법입니다. 위에서 사용했던 예제를 interface를 사용하여 확장해보겠습니다.123456789101112interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person: Person) &#123; return \"Hello, \" + person.firstName + \" \" + person.lastName;&#125;var user = &#123; firstName: \"Jane\", lastName: \"User\" &#125;;document.body.innerHTML = greeter(user); 함수의 parameter에 String이라는 타입 대신 인터페이스(interface)를 적용했습니다. Java의 Generic과 비슷하게 보이는데요, interface를 사용하여 함수가 넘겨받는 parameter의 타입을 보다 구체적으로 정의할 수 있게 되었습니다. 위의 예제 코드와 마찬가지로 정의된 type과 맞지 않은 type의 parameter가 전달되면 error를 출력합니다. ClassES6(ECMAScript2015)에서부터 추가된 Class 문법입니다.1234567class Student &#123; fullName: string; constructor(public firstName, public middleInitial, public lastName) &#123; this.fullName = firstName + \" \" + middleInitial + \" \" + lastName; &#125;&#125;var user = new Student(\"Jane\", \"M.\", \"User\"); ES6의 Class와는 약간 다른 모습을 보입니다. 바로 Class 내부에서 field member를 갖게 된 것입니다. 하지만 그 근본은 ES6의 Class와 같습니다. JavaScript에서 프로토타입을 통해 구현했던 OOP를 보다 간결한 방법으로 문법을 제공하는 것입니다. 공식 문서에서 제공하는 Quick Start를 통해서 TypeScript 맛보기를 해봤습니다. 감사합니다. 0. Quick start end","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://jaeyeophan.github.io/categories/TypeScript/"}],"tags":[{"name":"ts","slug":"ts","permalink":"https://jaeyeophan.github.io/tags/ts/"}]},{"title":"TypeScript 근황","slug":"TypeScript-Recent","date":"2017-04-19T04:39:38.000Z","updated":"2017-04-28T06:16:46.000Z","comments":true,"path":"2017/04/19/TypeScript-Recent/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/19/TypeScript-Recent/","excerpt":"","text":"TypeScript 근황얼마 전, 구글의 발표에 타입스크립트에 관심을 갖게 되었습니다. 기술적인 내용보다는 여러 기술 소식이 담긴 포스팅입니다.이 포스팅은 17년 4월 중순 경에 작성되었으며 작성되는 시점의 TypeScript version은 2.2 version입니다.(4월 28일, 2.3 version이 release되었습니다.) JavaScript의 미래올해가 벌써 2017년이니, 재작년인 2015년에 ECMAScript2015(aka ECMAScript6 or ES6)가 JavaScript 표준으로 정의되었고, 작년에는 ECMAScript2016(aka ECMAScript7 or ES7)이 발표되었습니다. 머지않아 ECMAScript2017도 발표될 예정(6월 예정)이라고 합니다. Node.js의 등장으로 JavaScript가 소프트웨어 개발 환경에서 막대한 비중을 차지하자 현재 tc39라는 커뮤니티에서 끊임없이 JavaScript라는 언어의 표준을 명세하고 있습니다. 이것은 무엇을 의미할까요? TypeScript에 대한 이야기를 하기 위해 JavaScript에 관한 내용은 다음 글을 참조하시면 좋을 것 같아 링크를 첨부합니다. 2017년과 이후 JavaScript의 동향 - JavaScript(ECMAScript) TypeScript의 정체 TypeScript란 JavaScript의 super set이다. 어디선가 이런 말을 많이 들어봤을것 같은데요.사실, TypeScript는 JavaScript입니다. 기존의 JavaScript와는 다르게 .ts라는 확장자를 갖고 있지만 결국 JavaScript로 compile되는 언어입니다. JavaScript의 성장과 동시에 언어 자체의 한계점을 인지한 MicroSoft는 JavaScript에 타입(Type)을 추가해서 TypeScript를 만듭니다.(TypeScript의 Type system을 Structural Type System이라고 합니다.) 그리고 2016년 9월에 TypeScript 2.0 버전이 공개되었습니다.(현재는 2.2 version 이네요!) 이와 같은 움직임은 Google에서 개발한 Dart에서도 찾아볼 수 있습니다. 하지만 얼마 전, 프론트엔드 개발자들의 눈길을 끌만한 소식이 들려왔습니다. MS 타입스크립트, 구글 사내 표준 언어되다. Google이 만든 프론트엔드 프레임워크 Angular2(얼마 전, Angular4.0이 release되었습니다.)도 Dart, JavaScript를 지원하지만 TypeScript를 공식 언어로 지정할만큼 TypeScript의 위상이 높아졌다는 것을 확인하실 수 있습니다. 이에 더해, 다들 아실만한 협업 툴인 Slack이 TypeScript로 전환했습니다. 다음 링크는 Slack이 코드베이스를 TypeScript로 전환하는 과정에 대한 글로, 정적 분석의 필요성에 대해 인지했다는 내용입니다. TypeScript at Slack Facebook에서 개발한 정적 타입 분석기(static typechecker of javascript) Flow도 마찬가지 행보가 아닐까 생각합니다. 애플리케이션의 규모가 커질 수록 안정성에 대한 수요는 높아지기 마련입니다. 동적 타입이라는 JavaScript가 갖고 있는 장점이자 한계점인 이 부분을 해결하기 위해 정적 분석의 중요도가 높아지고 있습니다. TypeScript의 현주소이젠 개발자들에게 없어서는 안 될 존재인 Github의 star를 보니 21,076개입니다! (star개수가 64,556개인 React에 비하면 한참 멀었네요!) 올라온 Issue는 2,351개고 진행중인 Pull Request는 82개가 되네요.다음 자료는 Github과 마찬가지로 개발자들에게 없어선 안 되는 Stackoverflow의 조사 자료입니다. 개발자들이 가장 사랑하는 언어로 Rust, Smalltalk에 이어 TypeScript가 3위를 당당히 차지했습니다.(오, 이 정도인가요?) 추가된 Type System을 바탕으로 여러 가지 Tool과 구문 완성(content assist) 등의 도움을 받을 수 있는 TypeScript 소개였습니다. 얼마 전 공개된 ReactXP를 만든 Microsoft의 지지로 React에서도 TypeScript 방향으로 가지 않을까 생각해봅니다.(Flow 의문의 1패?) 무엇을 공부해야 하나 걱정할 필요없는 프론트엔드 개발자분들을 응원합니다. 감사합니다 :) cf. 짤막하게 정리해본 TypeScript Quick Start입니다. TypeScript와 관련된 글과 그룹 Microsoft/TypeScript-Handbook TypeScript Korea 페이스북 그룹 TypeScript를 무서워하지 않아도 되는 이유(번역) TypeScript 소개(hyunseob님 블로그)","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://jaeyeophan.github.io/categories/TypeScript/"}],"tags":[{"name":"ts","slug":"ts","permalink":"https://jaeyeophan.github.io/tags/ts/"}]},{"title":"[ES6] 6. Class sugar syntax","slug":"ES6-6-Class-sugar-syntax","date":"2017-04-18T12:11:41.000Z","updated":"2017-04-19T07:30:46.000Z","comments":true,"path":"2017/04/18/ES6-6-Class-sugar-syntax/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/ES6-6-Class-sugar-syntax/","excerpt":"","text":"[ES6] 6. Class sugar syntaxES6에서 자바스크립트에는 존재하지 않았던 클래스(Class)가 도입되었다. 자바스크립트에 대해 잘 모르는 사람들이 Java에서의 클래스와 똑같은 기능을 하는 녀석인 줄 알고 많이 혼동한다. 자바스크립트는 기본적으로 프로토타입 기반의 언어이기 때문에 새로 도입된 이 클래스도 프로토타입 기반이다. 객체 지향을 흉내내고 있지만, 그 내부는 여전히 프로토타입으로 구성되어 있는 것이다. 프로토타입 기반으로 객체 지향적으로 설계하는 것이 복잡하여 클래스라는 sugar syntax 문법이 도입된 것이다. 그렇기 때문에 이에 따른 제약사항이 많다. 편한 만큼 고려해야할 사항도 많은 것이다. 하나씩 살펴보자. 클래스는 선언문 또는 표현식으로 선언할 수 있다.1234567891011121314//클래스 선언문으로 클래스 선언class name &#123; //...&#125;//클래스 표현식으로 클래스 선언let name = class &#123; //...&#125;let name = class inner_name &#123; //...&#125;console.log(typeof name); //function 자바스크립트 엔진은 class 키워드를 만나면 Class 오브젝트를 생성한다. Class 오브젝트도 마찬가지로 String, Function과 같은 하나의 오브젝트 타입이다.cf&gt; 표현식으로 선언했을 때의 inner-name은 클래스 내부에서 자신을 호출할 때 사용한다. Class keyword 특징 클래스의 선언부는 let과 const와 마찬가지로 호이스팅은 되지만 temporary dead zone이 형성된다.1234567//Not hoistinglet foo = new Foo();class Foo &#123;&#125;//Error:Use before declaration 클래스를 선언한 다음, new 키워드를 통해 인스턴스를 생성할 수 있다. 클래스의 코드는 ‘use strict’를 선언하지 않아도 strict 모드에서 실행된다. 메서드를 작성할 때, function 키워드와 콜론( : )을 작성하지 않는다. 메서드 사이에 콤마(,)를 작성하지 않는다.12345678910111213//class methodclass Student &#123; getName() &#123; console.log(\"name\"); &#125; getScore() &#123; console.log(\"score\"); &#125;&#125;let student = new Student();student.getName(); //namestudent.getScore(); //score 바로 함수를 정의하고, 콤마(,)가 없다. 생성자 함수를 통해 인스턴스를 생성하면 window에 설정되지만 class 키워드를 통해 생성하면 window에 설정되지 않는다.123456//window object?function Foo() &#123;&#125;console.log(window.Foo); // function Foo() &#123;...&#125;console.log(window.Student); //undefined Sugar SyntaxClass keyword는 sugar syntax라고 했다. 자바스크립트는 기본적으로 prototype 기반의 언어이기 때문에 엔진이 prototype에 메서드들을 연결한다. 즉, 클래스에서 메서드를 추가하면 자동으로 prototype에 추가되는 것이다. 자바스크립트에서는 프로토타입을 사용해서 클래스 밖에서도 메서드를 추가할 수 있다. 이미 생성된 인스턴스에 메서드를 추가하게 되면, 이전에 생성되었던 인스턴스들이 새로 추가된 메서드들을 공유해야하기 때문에 부하가 걸리지만 코드가 유연해진다는 장점도 존재한다. 위 예제코드에서 생성한 Student 클래스의 프로토타입에 새로운 메서드를 추가하고 이전에 생성되었던 인스턴스에서 새롭게 추가한 메서드를 호출할 수 있는 것이다.123456//add method to prototypeStudent.prototype.newMethod = function() &#123; console.log(\"Add new Method\");&#125;student.newMethod(); //Add new Method new 연산자는 constructor를 호출하면서 받은 인자들을 constructor의 파라미터로 전달한다.123456789101112131415//new keywordclass Student &#123; constructor(name, score) &#123; this.name = name; this.score = score; &#125; getName() &#123; return this.name; &#125;&#125;let s = new Student(\"Jbee\", 100);console.log(s.name); //Jbeeconsole.log(s.score); //100console.log(s.getName()); //Jbee 위 예제 코드에서 볼 수 있듯이 class 키워드로 선언한 클래스에 대해서 new keyword를 통해 인스턴스를 생성할 수 있다. 이 때 클래스 내부에 별도의 constructor가 설정되어 있지 않으면 기존의 protytype의 constructor가 호출되고 이를 default constructor라고 부른다. 별도로 작성된 constructor는 Student.prototype.constructor로 호출된다. new 키워드가 실행되는 메커니즘은 다음과 같다. 1. constructor는 우선적으로 빈(empty) 오브젝트(인스턴스)를 생성한다. 2. 넘겨받은 파라미터를 생성한 빈 오브젝트의 프로퍼티에 설정한다. 3. 인스턴스를 먼저 생성하므로, constructor 내부에서는 this keyword를 통해 인스턴스 자신을 가리킬 수 있다. 4. constructor에 별도의 return이 설정되어 있지 않으면 new를 실행한 곳으로 해당 클래스의 인스턴스를 반환한다. cf) constructor는 별도의 return을 설정할 수 있다. 하지만 Number, String 값이 return value로 지정되어 있으면 이를 무시하고 인스턴스 자신을 return 한다. extends keyword자바스크립트에서도 extends라는 키워드를 통해 클래스 간의 상속이 가능해졌다. 상속받은 클래스(이하 슈퍼클래스)의 메소드를 사용할 수 있다.1234567891011class Foo &#123; getName() &#123; console.log(\"Foo\"); &#125;&#125;class Bar extends Foo &#123;&#125;let bar = new Bar();bar.getName(); //Foo 슈퍼 클래스의 메소드를 오버라이딩(Overriding)할 수 있다.1234567891011121314class Foo &#123; getName() &#123; console.log(\"Foo\"); &#125;&#125;class Bar extends Foo &#123; getName() &#123; console.log(\"Bar\"); &#125;&#125;let bar = new Bar();bar.getName(); //Bar super 키워드를 통해 슈퍼 클래스의 메소드에 접근할 수 있다.1234567891011121314class Foo &#123; getName() &#123; return \"Foo\"; &#125;&#125;class Bar extends Foo &#123; getName() &#123; return super.getName() + \" Bar\"; &#125;&#125;let bar = new Bar();bar.getName(); //Foo Bar constructor keyword서브 클래스에서 정의된 constructor가 없다면 슈퍼 클래스의 constructor가 호출된다.1234567891011class Foo &#123; constructor() &#123; console.log(\"Foo constructor\"); &#125;&#125;class Bar extends Foo &#123;&#125;let bar = new Bar();//console&gt; Foo constructor 서브 클래스에서 constructor를 정의하려면 반드시 constructor 내부에서 super()를 호출해야 한다.1234567891011121314class Foo &#123; constructor() &#123; console.log(\"Foo\"); &#125;&#125;class Bar extends Foo &#123; constructor() &#123; console.log(\"Bar\"); &#125;&#125;let bar = new Bar();//ReferenceError: this is not defined constructor()메소드 안에서 super()를 호출해주면, 슈퍼 클래스가 생성되고 서브 클래스가 생성된다.12345678910111213141516class Foo &#123; constructor() &#123; console.log(\"Foo constructor\"); &#125;&#125;class Bar extends Foo &#123; constructor() &#123; super(); console.log(\"Bar constructor\"); &#125;&#125;let bar = new Bar();//console&gt; Foo constructor//console&gt; Bar constructor static keyword자바스크립트 클래스에서 static 키워드를 사용하면 정적 메소드를 정의할 수 있다. 정적 메소드라 함은 인스턴스를 생성하지 않고 사용할 수 있는 메소드를 말한다. 정적 메소드는 인스턴스를 생성하지 않고도 호출할 수 있지만 인스턴스에서는 호출할 수 없다.12345678910class Foo &#123; static getName() &#123; console.log(\"Foo\"); &#125;&#125;Foo.getName(); //Foolet foo = new Foo();foo.getName();//not a function 정적 메소드는 prototype에 추가되지 않는다.123456789101112class Foo &#123; static getName() &#123; console.log(\"Foo\"); &#125; getAlias() &#123; console.log(\"foo\"); &#125;&#125;console.log(Foo.prototype.getName === Foo.getName);//falseconsole.log(Foo.prototype.getAlias === new Foo().getAlias);//true 클래스 내부에서 정적 변수(static variable)를 지정할 수는 없지만 클래스 밖에서 지정할 수 있다.1234class Foo &#123; //...&#125;Foo.name = \"foo\"; new.targetnew.target을 이용하면 슈퍼 클래스에서 서브 클래스의 static method에 접근할 수 있다.12345678910111213141516171819class Foo &#123; constructor() &#123; console.log(new.target);//[Function: Bar] console.log(typeof new.target);//function console.log(\"Foo: \", new.target.getName());//Foo: bar &#125;&#125;class Bar extends Foo &#123; constructor() &#123; super(); &#125; static getName() &#123; return \"bar\"; &#125;&#125;let bar = new Bar(); ES6에서 추가된 sugar syntax class에 대해 정리해봤다. TypeScript에서는 보다 더 객체지향적인 클래스로서 사용할 수 있다. 아직 불완전한 ES6의 클래스는 신경써야할 부분도 많지만 제대로 이해하면 prototype을 사용하는 것보다 효율적으로 자바스크립트 코드를 작성할 수 있을 것이다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 6. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 5. Destructuring and Default Parameter","slug":"ES6-5-Destructuring-and-Default-Parameter","date":"2017-04-18T11:59:34.000Z","updated":"2017-04-18T12:01:31.000Z","comments":true,"path":"2017/04/18/ES6-5-Destructuring-and-Default-Parameter/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/ES6-5-Destructuring-and-Default-Parameter/","excerpt":"","text":"[ES6] 5. Destructuring and Default ParameterDestructuringshorthand 방식을 이용하여 함수의 반환값을 바로 객체에 할당할 수 있다. 이 때 함수에서 반환되는 프로퍼티 값과 지역 변수의 이름이 같아야 가능하다. 이렇게 하면 함수의 반환 값을 임시 객체에 저장하고 그 객체의 프로퍼티를 통해 접근하여 지역 변수에 할당하는 과정을 축소할 수 있다. 굳이 전체를 객체에 할당하지 않고 부분적으로만 할당도 가능하다. 즉, 리턴되는 값이 객체일 경우, 그 객체를 분해하여 바로 지역변수로 접근이 가능하다는 것이다. (iterable protocol을 구현해야만 destructuring이 가능하다.)123456789function buildUser(first, last)&#123; let fullName = first + \" \" + last; return &#123;first, last, fullName&#125;;&#125;let &#123; first, last, fullName &#125; = buildUser(\"Sam\", \"Williams\");console.log(first); // Samconsole.log(last); // Williamsconsole.log(fullName); // Sam Williams 굳이 전체를 객체에 할당하지 않고 부분적으로만 할당도 가능하다.12let &#123; fullName &#125; = buildUser(\"Sam\", \"Williams\");console.log( fullName ); // Sam Williams Method Initializer Shorthand객체에 함수를 추가할 때, 객체의 프로퍼티에 익명 함수를 추가하는 방식을 사용했다. ES6에서는 메소드를 활용한다. 비교를 위해 ES5도 함께 제시한다.ES6code&gt;&gt;123456789function buildUser(first, last, postCount)&#123; return &#123; first, last, isActive : function( ) &#123; //... &#125; &#125;&#125; ES6code&gt;&gt;123456789function buildUser(first, last, postCount)&#123; return &#123; first, last, isActive( ) &#123; //... &#125; &#125;&#125; Destructuring Assignment오른쪽의 배열을 분할하여 왼쪽 변수에 값을 할당한다. 인덱스 번째의 엘리먼트 값을 인덱스 번째의 변수에 할당하는 것이다. 엘리먼트가 아직 남았는데 할당할 변수가 없다면 그대로 할당되지 않고, 엘리먼트가 남지 않았는데 할당한 변수가 있다면 그 변수는 undefined로 할당된다.1234567891011121314let one, two, three, four;//case1[one, two] = [1, 2];console.log(one); //1console.log(two); //2//case2[one, two, three] = [1, 2];console.log(one); //1console.log(two); //2console.log(three);//undefined//case3[one, two] = [1, 2, 3];console.log(one); two//1console.log(two); //2 이전 Chapter에서 다뤘던 Spread 연산자를 사용할 수 있으며, 공백으로 두어 해당 값을 건너 뛰고 할당할 수 있다.1234567[one, ...other] = [1, 23, 24, 25];console.log(one); //1console.log(other); //[23, 24, 25][one, , , four] = [1, 2, 3, 4];console.log(one); //1console.log(four); //4 Default Valuedestructuring을 통해 값을 할당할 때, 해당하는 값이 없을 때, undefined 대신 할당할 default value를 지정해줄 수 있다.123456789let [first, second, third = 3] = [1, 2];console.log(first); //1 by destructuringconsole.log(second); //2 by destructuringconsole.log(third); //3 by default valuelet [fourth, fifth, sixth = 6] = [4, 5, 66];console.log(first); //4 by destructuringconsole.log(second); //5 by destructuringconsole.log(third); //66 by destructuring Default Parameterparameter에 값이 넘어가지 않아도, default value로 설정된 값이 해당 파라미터 대신 값이 할당된다. parameter에서도 마찬가지로 기존의 default value는 undefined 값이었지만, 그 값을 코드 상에서 설정할 수 있게 된 것이다.12345let somethingFunction = (prev, post = 20) =&gt; prev + post;console.log(somethingFunction(1)); //21 by default parameterconsole.log(somethingFunction(1, 2)); //3console.log(somethingFunction(1, undefined)); //21 by default parameterconsole.log(somethingFunction(1, null)); //1 함수에도 length라는 property가 따로 존재한다. 그런데 이 때, default parameter는 length에서 무시된다.123getTotal(100); //1getTotal(100, 0.05); //2console.log(getTotal.length); //1 한 가지 주의할 점이 있다. let으로 선언했을 때의 값은 Default parameter와는 다르기 때문에, Destructuring으로 값을 덮어쓸 수 있다. let으로 선언했을 때 할당하는 것과는 다르다.default parameter code&gt;&gt;123let salary = [100, 200, 300];let [low, avg, high = 500] = salary;console.log(high); //500 let assignment code123let low, avg, high = 500;let [low, avg, high] = salary;console.log(high); //300 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 5. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 4. Spread, Rest parameter","slug":"ES6-4-Spread-Rest-parameter","date":"2017-04-18T11:59:13.000Z","updated":"2017-04-18T12:01:30.000Z","comments":true,"path":"2017/04/18/ES6-4-Spread-Rest-parameter/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/ES6-4-Spread-Rest-parameter/","excerpt":"","text":"[ES6] 4. Spread, Rest parameterSpread이터러블 오브젝트(Iterable object)의 엘리먼트를 하나씩 분리하여 전개한다. 전개한 결과를 변수에 할당하거나 호출하는 함수의 파라미터 값으로 사용할 수 있다.1234let prev = [3,4];let post = [7,8];let spreadObj = [1, 2, ...prev, 5, 6, ...post, 9];console.log(spreadObj); // [1,2,3,4,5,6,7,8,9] 문자열도 가능하다.12let sObj = [...\"javascript\"];console.log(sObj); // [\"j\", \"a\", \"v\", \"a\", \"s\", \"c\", \"r\", \"i\", \"p\", \"t\"] Rest Parameter함수를 호출할 때 spread 연산자로 파라미터를 작성한 형태를 Rest parameter라고 한다. 함수안의 코드를 확인하지 않고도 호출문의 형태만 보더라도 Rest parameter 의 범위를 확인할 수 있어 가독성이 높아진다. 또한 Rest parameter는 Array, 즉 배열이므로 Array 오브젝트의 메서드를 사용할 수 있다. 그리고 arrow funtion에서도 사용 가능하다.12let price = [12, 20, 18];Math.max(12, 20, 18); built in Object인 Math의 메소드 max()를 사용하기 위해서는 위 코드처럼 하나씩 넘겨줘야 한다.또는 다음과 같은 방식을 사용했다.1Math.max.call(Math, price); 하지만 Rest parameter를 사용하면 보다 깔끔하게 작성할 수 있다.1let maxPrice = Max.max(...price); Rest parameter는 동적(dynamic)으로 생성된 파라미터라고 할 수 있기 때문에 함수의 length에서 포함되지 않는다. 기본적으로 함수의 length 프로퍼티는 파라미터의 개수를 의미한다.12345let getElementByRestWithParam = (param, ...rest) =&gt; &#123; console.log(param); console.log(rest);&#125;console.log(getElementByRestWithParam.length); // 1 위 getElementByRestWithParam메소드에 spread operator를 사용하여 인자를 넘겨보자.12const values = [10, 20, 30];getElementByRestWithParam(...values); //10 \\n [20, 30] param에 해당하는 인자가 따로받아지고 나머지 인자들은 ...rest로 넘겨지면서 다시 배열로 넘겨지게 된다! Rest parameter를 사용했을 때와 기존의 자바스크립트에서 arguments를 사용했을 때의 차이점을 살펴보기 위해 arguments에 대해서 잠깐 살펴보자. arguments는 Array-Like Object라는 공식 명칭을 하고 있는 유사 배열이다. Array-like Object(유사배열)배열의 특징 중 하나는 index를 갖고 있어서 임의 접근(random access)가 가능하고, 그 index가 순차적으로 증가한다는 것이다. 만약 Object가 key값이 순차적으로 증가하는 값이고, 그에 따른 value가 존재한다고 했을 때, Array-like Object라고 한다.배열의 인덱스 값을 프로퍼티 key 값으로 사용하는 것이다. 그리고 length라는 프로퍼티 값을 갖고 있어서 전개를 할 때는 다음과 같이 한다.1234567891011// Array-like objectlet arrLikeObj = &#123; 0 : \"zero\", 1 : \"one\", 2 : \"two\", length : 3&#125;;for (let i = 0; i &lt; arrLikeObj.length; i++) &#123; console.log(arrLikeObj[i]);&#125; Array-like Object는 다음 두 가지 규칙을 모두 만족시켜야 한다.1) 프로퍼티 값을 0부터 1씩 증가하면서 순차적으로 작성해야 한다.2) length를 프로퍼티 키로 하여 전체 프로퍼티 수를 작성해야 한다. Rest parameter와 arguments의 차이arguments도 Array-like object이기 때문에 for statement로 전개할 수 있다. 하지만 Array 오브젝트의 메서드를 사용할 수 없다. 이것이 치명적인 단점인 것이다. 또 arrow function에서는 arguments를 사용할 수 없다. 이것으로 미루어보아, ES6에서는 arguments를 사용하는 것을 최대한 자제하라는 느낌이다. 사실 Rest parameter에 익숙해지기만 하면 arguments를 통해 인자를 받는 것보다 유연한 코드를 작성할 수 있다. 한 가지 더 한계점을 지적하자면 arguments는 함수 내부를 봐야 어느 부분에서 arguments 객체를 사용하는지 알 수 있어 코드의 가독성이 떨어지게 된다. 그렇기 때문에 arguments 대신 Rest parameter를 도입한 것이다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 4. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 3. Iteration and for-of statement","slug":"ES6-3-Iteration-and-for-of-statement","date":"2017-04-18T04:52:45.000Z","updated":"2017-04-19T07:31:26.000Z","comments":true,"path":"2017/04/18/ES6-3-Iteration-and-for-of-statement/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/ES6-3-Iteration-and-for-of-statement/","excerpt":"","text":"[ES6] 3. Iteration and for-of statementIterationES6에서 이터레이션 프로토콜은 Iterable 프로토콜과 Iterator 프로토콜로 구성된다. 결론부터 말하자면 Iterable 프로토콜은 반복 가능한 오브젝트를 나타내는 프로토콜이며 Iterator 프로토콜은 이터러블 오브젝트(Iterable 프로토콜을 따르는 오브젝트)의 값을 작성한 순서대로 처리하는 프로토콜이다. Iterable 프로토콜오브젝트의 반복 처리 규약을 정의한다.Iterable Object String, Array, Map, Set, TypedArray, Argument 오브젝트그리고 DOM의 NodeList 위 built in 오브젝트들은 디폴트로 이터러블 프로토콜을 갖고 있다. 오브젝트에 Symbol.iterator가 있어야 한다. Symbol.iterator가 있는 오브젝트는 이터러블 오브젝트이다. 또한 상속받은 prototype chain에 있어도 이터러블 오브젝트이다. (Symbol에 대해서는 다음 포스팅에서 다룰 예정이다.) 오브젝트에 프로퍼티 존재 여부를 체크할 때, Symbol의 경우에는 arrayObj[Symbol.iterator]와 같이 대괄호 []안에 작성해야 한다.1234let arr = [];console.log(arr[Symbol.iterator]); //function values() &#123; [native code] &#125;let obj = &#123;a:1&#125;;console.log(obj[Symbol.iterator]); //undefined Array 오브젝트는 기본적으로 iterable 프로토콜을 구현한다. 하지만 Object 오브젝트는 iterable 프로토콜을 구현하지 않는다.1let iteratorObj = arr[Symbol.iterator](); //iterator object 위와 같은 방식으로 Array 오브젝트는 iterator를 받을 수 있다. JavaScript’s for statementforEachforEach 문은 arrow function과 조합해서 사용하면 추가적인 변수 사용 없이 코드가 깔끔해질 수 있다.12345678let categories = [\"Korean\", \"English\", \"Science\"];categories.forEach(subject =&gt; &#123; console.log(subject);&#125;);console&gt;KoreanEnglishScience 그러나 for문 중간에 continue or break or return 선언문을 사용할 수 없다. 기존의 for-statement를 사용하는 경우를 보자.1234567for (let i = 0; i &lt; subject.length; i++) &#123; console.log(categoried[i]);&#125;console&gt;KoreanEnglishScience i의 역할이 index를 잡아주는 것 외에 별 다른 기능이 없다. 그래서 기존에는 for-in statement를 사용했다. 하지만 for-in statement 은 문자열 키를 가진 일반 Object 객체들을 위해 만들어졌다.1234567for (let item in categories) &#123; console.log(item);&#125;console&gt;012 그래서 ES6에서 for-of statement가 등장했다.for-in loop statement는 객체의 프로퍼티들을 루프시키지만 for-of loop statement는 데이터, 즉 배열 내의 value들을 루프시킨다. 또한 for-of는 배열 뿐만 아니라 다양한 Collection에도 동작한다. DOM의 NodeList 같은 유사배열 객체들에도 동작하고 문자열에도 동작한다. 문자열을 유니코드 문자의 배열로 취급하는 것이다. Set, Map에 대해서도 물론 동작한다. key-value 형식의 Map에 대해서는 for (let [key, value] of …) 형식의 destructuring을 사용한다.1234567for (let item of categories) &#123; console.log(item);&#125;console&gt;KoreanEnglishScience 단 for-of 가 만능은 아니다. Object의 프로퍼티를 루프시키려면 for-in statement를 사용해야 한다. 사실 for-in statement의 원래 목적이 Object 프로퍼티 순회이다. Object를 순회하는 경우를 살펴보자.12345let obj = &#123; one : 1, two : 2, three : 3&#125;; 위와 같은 obj라는 오브젝트를 정의한다.12345678for (let key in obj) &#123; console.log(key);&#125;// console&gt;// one// two// three for-in statement를 통해서 정의한 오브젝트(obj)의 key를 순회했다.1234567for (let key in obj) &#123; console.log(obj[key]);&#125;// console&gt;// 1// 2// 3 오브젝트를 for-of statment로 순회하면 어떻게 될까?12345for (let item of obj) &#123; console.log(item);&#125;// console&gt;// Uncaught TypeError: obj[Symbol.iterator] is not a function JavaScript의 Object는 iterable 프로토콜을 구현하고 있지 않기 때문에, Symbol.iterator가 존재하지 않는다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 3. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 2. Arrow function","slug":"ES6-2-Arrow-function","date":"2017-04-18T04:51:49.000Z","updated":"2017-04-18T04:54:06.000Z","comments":true,"path":"2017/04/18/ES6-2-Arrow-function/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/ES6-2-Arrow-function/","excerpt":"","text":"[ES6] 2. Arrow Function Always apply to ‘Anonymous function’ 자바스크립트의 Scope자바스크립트에서 생성자 함수를 통해 객체를 생성하면 변수 scope가 변경된다. 즉, 생성자 함수 내부에서의 this는 자신을 호출한 대상이 아닌 생성자 함수를 가리키게 된다. 생성자 함수를 통해 생성되는 객체의 과정 때문이다. 그래서 우리는 여태껏 별의 별짓을 다해왔다. self며 bind며 jQuery에서는 proxy라는 녀석도 사용했다. 새로운 function의 등장하지만 이제는 새로 도입된 Arrow function 을 사용하여 변수 스코프를 보존하자. Arrow function를 통해서 함수를 정의하게 되면, 변수들이 사용되는 위치와는 상관없이 변수들이 정의되어 있는 값으로 scope가 binding 된다. 한 가지 특징을 덧붙이자면, arrow function을 사용하게 되면 arguments 객체가 생성되지 않는다. 하지만 우리는 ES6 문법을 사용하는 이상, arguments는 필요하지 않다! Arrow function RuleES6의 arrow function에는 몇 가지 규칙이 존재하며 대부분의 lamda에서도 비슷한 규칙을 가지고 있어서 lamda를 사용해본 경험이 있다면 어색하지 않을 것이다.1) Parameter와 화살표 사이에서 개행할 수 없다.2) Parameter가 하나일 때는 괄호를 생략할 수 있다.3) Parameter가 없으면 소괄호( ( ) )만 작성한다.4) Block scope({ })를 지정하지 않고 한 줄로 arrow function을 사용할 때는 return이 생략될 수 있다.5) 그 반대로 block scope를 사용한다면 return을 명시해줘야 한다. Arrow Function은 this를 bind하지 않는다!12345678//ES5document.getElementById(\"todos\").addEventListener(\"click\", function() &#123; console.log(this); //#todos&#125;);//ES6document.getElementById(\"todos\").addEventListener(\"click\", () =&gt; &#123; console.log(this); //Window&#125;); this의 정체ES5에서 this 결정되는 세 가지 조건을 짚고 넘어가자.1) 생성자 내에서생성자 함수를 new라는 키워드를 통해 호출하면 내부에서 this는 인스턴스 그 자체를 가리킨다. 생성자 함수 내부에서 return this;가 생략되어 있기 때문이다.2) 함수 내에서this는 생략된 매개 변수이다. 무엇이 함수를 호출했는가가 this를 결정한다.3) bind, apply, call method or proxy method of jQuerythis는 메소드로 바꿔준 대상을 가리키게 된다. 그렇다면 arrow function 내에서 this는 무엇을 가리키는가. 해당 function을 정의한 영역의 this를 가져온다. 한 단계 더 위의 element를 가리키는 것이다. 그렇기 때문에 prototype에 함수를 정의할 때 arrow function을 사용할 때 내부적으로 this를 사용하게 되면 객체를 가리키지 않고 window 객체를 가리키게 된다. 또한 arrow function은 명식적으로 bind, call로 this를 넣어줘도 이를 무시한다. ES6의 arrow function은 단순히 함수를 간단하게 작성할 수 있는 문법이 아니다. 기존의 방식대로 function을 작성해야만 의도대로 작동하는 function이 존재할 수 있고, arrow function으로 기존의 function을 작성하던 방식보다 편하게 작성할 수 있게 된 것이다. 두 가지 방식의 차이점을 제대로 이해하고 새로운 문법과 기존의 문법을 적재적소에서 사용하는 것이 중요해졌다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. 2. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]},{"title":"[ES6] 1. let-const","slug":"let-const","date":"2017-04-18T04:48:49.000Z","updated":"2017-04-18T06:48:56.000Z","comments":true,"path":"2017/04/18/let-const/","link":"","permalink":"https://jaeyeophan.github.io/2017/04/18/let-const/","excerpt":"","text":"[ES6] 1. let &amp; const자바스크립트의 정체ES6의 문법을 알아보기 전에 자바스크립트의 정체부터 짚고 넘어가자. 자바스크립트(JavaScript)는 스크립트 언어(script language)이다. 스크립트 언어란 언어를 해석하고 실행하는 소프트웨어가 따로 존재하는 언어를 말한다. 자바스크립트를 해석하고 실행하는 소프트웨어는 브라우저이다. 이러한 의미에서 Node.js는 스크립트 언어라고 부르기 애매하고 자바스크립트의 문법을 차용한 다른 종류의 언어라고 생각해도 된다. 우선 자바스크립트가 해석되고 실행될 때 일어나는 확보, 선언, 할당의 차이를 짚고 넘어가야 한다. 확보브라우저가 자바스크립트를 해석할 때 두 번 파싱(parsing)하는데 첫번째 파싱 과정이 Lexical parsing이다. 실행하려는 자바스크립트 파일이 어느 정도의 메모리를 필요로 하는지를 파악하기 위해 거치는 파싱 과정인 것이다. 이 때 자바스크립트의 모든 선언문은 호이스팅(Hoisting)된다. 선언말 그대로 선언하는 것이다. 값을 할당하지 않는다. 자바스크립트에서는 선언만 하고 값을 할당하지 않으면 undefined값이 할당된다. 확보만 하고 선언하지 않으면 Reference error가 발생하고 선언을 하게 되면 undefined 값이 나타난다. 할당특정 변수에 값을 할당하는 과정이다. 위 세 가지를 파악해야 var와 let 그리고 const의 차이를 이해할 수 있다 let 으로 변수 선언 및 할당하기let으로 정의된 변수들은 호이스팅 되지 않는다(?) 많은 책에서 이렇게 표현을 하고 있지만 이것은 잘못된 표현이다. let으로 선언해도 호이스팅된다. lexical parsing 단계에서 해당 자바스크립트 파일을 실행하기 위한 메모리 공간을 확보해야하기 때문이다. 다만 let 변수로 선언이 되기 전 해당 변수를 사용하려고 하면 Reference error를 발생시키는 것이다. 예제 코드를 보자.123456789101112//ES5 code :: var&gt;&gt;console.log(foo); //undefinedvar foo;console.log(foo); //undefinedfoo = 123;console.log(foo); //123//ES6 code :: let&gt;&gt;console.log(foo); //ReferenceErrorlet foo;console.log(foo); //undefinedfoo = 123;console.log(foo); //123 let은 유효범위의 시작에서부터 선언될 때까지 temporary dead zone(일시적 사각지대)에 있다. 이 dead zone에서 사용하게 되면 ReferenceError가 발생한다. let - in for looplet으로 정의된 변수들은 가장 가까운 블록으로 scope이 지정된다. 여기서 블록이란 if, else, for, while 같은 문법으로 지정된 { } 블록을 의미한다. let 키워드를 사용한 변수들은 그들 각각의 함수 block에 귀속된다. var 변수는 함수의 상단으로 호이스팅(hoisting) 된 다음에, 각 루프의 반복 변수가 공유하게 된다. 그 결과, 콜백이 실행될 때는 i 변수가 루프의 마지막 변수로 할당된다. 즉 콜백에서 반복문을 제어하는 변수에 접근할 때 문제가 발생하는 것이다. 이러한 문제를 해결하기 위해 let을 사용할 수 있다. 123456789101112131415//ES5 codefunction loadFiles( userNames ) &#123; for(var i in userNames)&#123; _fetchProfiles(userNames[i], function() &#123; console.log(userNames[i]); &#125; &#125;&#125;loadFiles([\"A\", \"B\", \"C\", \"D\"]);console &gt;D // userNames[4]D // userNames[4]D // userNames[4]D // userNames[4] ES6 code123456789101112131415//ES6 codefunction loadFiles( userNames )&#123; for( let i in userNames )&#123; _fetchProfile(userNames[i], function()&#123; console.log(userNames[i]); &#125; &#125;&#125;loadFiles([\"A\", \"B\", \"C\", \"D\"]);console &gt;A // userNames[1]B // userNames[2]C // userNames[3]D // userNames[4] let cannot be redeclaredlet으로 정의된 변수는 같은 블록에서 재할당될 수는 있지만 재정의는 될 수 없다.123456789101112//ES6 codelet a = 'hello';a = 'world' // availablelet a = 'hello';let a = 'world'; // false -&gt; TypeError : Identifier ‘a’ has already been declaredlet flashMessage = 'hello';function loadFiles(userNames)&#123; let flashMessage = 'world'; // available return flashMessage;&#125; const - declarationconst 키워드는 상수라고 불리는 읽기 전용 변수를 생성하는 키워드이다. 한 번 할당되면, 상수는 새로운 값으로 할당될 수 없다. 명시적으로 변경을 시도해도 바뀌지 않는다. const 로 정의된 변수는 초기에 정의할 때, 반드시 값을 할당해줘야 한다. 그렇지 않으면 Syntax Error가 발생하게 된다. const 로 정의된 변수는 let과 마찬가지로, 가장 가까운 블록에 scope이 지정된다. 예제로 사용된 코드는 Github Respository에서 확인하실 수 있습니다. chapter 1. end","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jaeyeophan.github.io/categories/ECMAScript6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://jaeyeophan.github.io/tags/es6/"}]}]}
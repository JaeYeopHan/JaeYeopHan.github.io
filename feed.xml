<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devlog</title>
  <subtitle>Front End Developer, Jbee&#39;s blog</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://jaeyeophan.github.io/"/>
  <updated>2017-04-19T04:50:02.000Z</updated>
  <id>https://jaeyeophan.github.io/</id>
  
  <author>
    <name>Jbee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[TS] 0. Quick Start</title>
    <link href="https://jaeyeophan.github.io/2017/04/19/TS-0-Quick-Start/"/>
    <id>https://jaeyeophan.github.io/2017/04/19/TS-0-Quick-Start/</id>
    <published>2017-04-19T04:49:15.000Z</published>
    <updated>2017-04-19T04:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-0-Quick-Start"><a href="#TS-0-Quick-Start" class="headerlink" title="[TS] 0. Quick Start"></a>[TS] 0. Quick Start</h1><p>이 포스팅은 TypeScript Official Document를 번역 및 의역한 자료입니다. 직접 타이핑 해본 결과 5분정도 소요되는 짧은 Quick start 입니다:) 가볍게 봐주세요.</p>
<h2 id="Install-TypeScript"><a href="#Install-TypeScript" class="headerlink" title="Install TypeScript"></a>Install TypeScript</h2><p>npm을 통해서 간단하게 TypeScript를 설치할 수 있습니다. VSCode 등 타입스크립트를 지원하는 에디터에서는 플러그인을 통해서 설치가 가능합니다.</p>
<p>via npm<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g typescript</div></pre></td></tr></table></figure></p>
<p>command를 이용하여 또는 Editor를 열어 <code>greeter.ts</code>라는 파일을 만듭니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch greeter.ts</div></pre></td></tr></table></figure></p>
<p><code>greeter.ts</code>코드는 다음과 같습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + person;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> user = <span class="string">"Jane User"</span>;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</div></pre></td></tr></table></figure></p>
<p>TypeScript는 <code>.ts</code>라는 확장자를 사용합니다. 이 파일은 컴파일되어 <code>greeter.js</code>파일이 됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tsc greeter.ts</div></pre></td></tr></table></figure></p>
<p><code>tsc</code>라는 명령어를 통해서 TypeScript로 작성된 파일을 컴파일할 수 있습니다.<br>현재 <code>greeter.ts</code>에 작성되어있는 코드는 기존의 JavaScript와 다를 바가 없습니다. 이 JavaScript code인 <code>greeter.ts</code>에 TypeScript 문법을 하나씩 추가해보겠습니다.</p>
<h2 id="TypeScript가-제공하는-대표적인-기능"><a href="#TypeScript가-제공하는-대표적인-기능" class="headerlink" title="TypeScript가 제공하는 대표적인 기능"></a>TypeScript가 제공하는 대표적인 기능</h2><h3 id="Type-annotations"><a href="#Type-annotations" class="headerlink" title="Type annotations"></a>Type annotations</h3><p>동적으로 변수의 타입을 결정했던 JavaScript에게 타입이 생겼습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>TypeScript</strong>는 Type을 제공합니다. Type annotations는 함수가 받는 parameter에 타입을 지정해주어, 함수 내부에서 별도의 타입 체크 없이 parameter를 사용할 수 있게 해줍니다. 즉, <code>person</code>에 다른 타입의 parameter가 주어지면 error가 발생하게 됩니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + person;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> user = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</div></pre></td></tr></table></figure></p>
<p>error:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">greeter.ts(7,26): Supplied parameters do not match any signature of call target</div></pre></td></tr></table></figure></p>
<p>타입스크립트는 코드의 구조와 작성된 <code>type annotation</code>으로 정적 분석을 제공합니다. 위와 같이 error가 발생하더라도 타입스크립트 파일은 컴파일되어 <code>.js</code>파일을 만들게 됩니다. TypeScript의 역할은 제대로 동작하지 않을 것 같은 코드에 대해 개발자에게 <code>warning</code>해주는 역할이라고 생각해도 될 것 같습니다 :)</p>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>Java개발자라면 익숙한 <code>interface</code> 문법입니다. 위에서 사용했던 예제를 <code>interface</code>를 사용하여 확장해보겠습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Person &#123;</div><div class="line">    firstName: <span class="built_in">string</span>;</div><div class="line">    lastName: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + person.firstName + <span class="string">" "</span> + person.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> user = &#123; firstName: <span class="string">"Jane"</span>, lastName: <span class="string">"User"</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</div></pre></td></tr></table></figure></p>
<p>함수의 parameter에 <code>String</code>이라는 타입 대신 인터페이스(interface)를 적용했습니다. Java의 Generic과 비슷하게 보이는데요, interface를 사용하여 함수가 넘겨받는 parameter의 타입을 보다 구체적으로 정의할 수 있게 되었습니다. 위의 예제 코드와 마찬가지로 정의된 type과 맞지 않은 type의 parameter가 전달되면 error를 출력합니다.</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>ES6(ECMAScript2015)에서부터 추가된 <code>Class</code> 문법입니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Student &#123;</div><div class="line">    fullName: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> firstName, <span class="keyword">public</span> middleInitial, <span class="keyword">public</span> lastName</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.fullName = firstName + <span class="string">" "</span> + middleInitial + <span class="string">" "</span> + lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> Student(<span class="string">"Jane"</span>, <span class="string">"M."</span>, <span class="string">"User"</span>);</div></pre></td></tr></table></figure></p>
<p>ES6의 <code>Class</code>와는 약간 다른 모습을 보입니다. 바로 Class 내부에서 <code>field member</code>를 갖게 된 것입니다. 하지만 그 근본은 ES6의 <code>Class</code>와 같습니다. JavaScript에서 프로토타입을 통해 구현했던 OOP를 보다 간결한 방법으로 문법을 제공하는 것입니다.</p>
<p>공식 문서에서 제공하는 Quick Start를 통해서 TypeScript 맛보기를 해봤습니다. 감사합니다.</p>
<p><em>0. Quick start end</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-0-Quick-Start&quot;&gt;&lt;a href=&quot;#TS-0-Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;[TS] 0. Qui
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 근황</title>
    <link href="https://jaeyeophan.github.io/2017/04/19/TypeScript-%E1%84%80%E1%85%B3%E1%86%AB%E1%84%92%E1%85%AA%E1%86%BC/"/>
    <id>https://jaeyeophan.github.io/2017/04/19/TypeScript-근황/</id>
    <published>2017-04-19T04:39:38.000Z</published>
    <updated>2017-04-19T04:48:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p>
<h1 id="TypeScript-근황"><a href="#TypeScript-근황" class="headerlink" title="TypeScript 근황"></a>TypeScript 근황</h1><p>얼마 전, 구글의 발표에 타입스크립트에 관심을 갖게 되었습니다. 기술적인 내용보다는 여러 기술 소식이 담긴 포스팅입니다.</p>
<h2 id="JavaScript의-미래"><a href="#JavaScript의-미래" class="headerlink" title="JavaScript의 미래"></a>JavaScript의 미래</h2><p>올해가 벌써 2017년이니, 재작년인 2015년에 <code>ECMAScript2015(aka ECMAScript6 or ES6)</code>가 JavaScript 표준으로 정의되었고, 작년에는 <code>ECMAScript2016(aka ECMAScript7 or ES7)</code>이 발표되었습니다. 머지않아 <code>ECMAScript2017</code>도 발표될 예정(6월 예정)이라고 합니다. <code>Node.js</code>의 등장으로 JavaScript가 소프트웨어 개발 환경에서 막대한 비중을 차지하자 현재 <a href="https://github.com/tc39/tc39-notes" target="_blank" rel="external">tc39</a>라는 커뮤니티에서 끊임없이 JavaScript라는 언어의 표준을 명세하고 있습니다. 이것은 무엇을 의미할까요?</p>
<p>TypeScript에 대한 이야기를 하기 위해 JavaScript에 관한 내용은 다음 글을 참조하시면 좋을 것 같아 링크를 첨부합니다. <a href="http://d2.naver.com/helloworld/2809766" target="_blank" rel="external">2017년과 이후 JavaScript의 동향 - JavaScript(ECMAScript)</a></p>
<h2 id="TypeScript의-정체"><a href="#TypeScript의-정체" class="headerlink" title="TypeScript의 정체"></a>TypeScript의 정체</h2><blockquote>
<p>TypeScript란 JavaScript의 <code>super set</code>이다.</p>
</blockquote>
<p>어디선가 이런 말을 많이 들어봤을것 같은데요.<br><img src="/images/typescript_javascript.png" alt=""><br>사실, TypeScript는 JavaScript입니다. 기존의 JavaScript와는 다르게 <code>.ts</code>라는 확장자를 갖고 있지만 결국 JavaScript로 compile되는 언어입니다. JavaScript의 성장과 동시에 언어 자체의 한계점을 인지한 MicroSoft는 JavaScript에 <code>타입(Type)</code>을 추가해서 TypeScript를 만듭니다.(TypeScript의 Type system을 <a href="https://en.wikipedia.org/wiki/Structural_type_system" target="_blank" rel="external">Structural Type System</a>이라고 합니다.) 그리고 2016년 9월에 TypeScript 2.0 버전이 공개되었습니다.(현재는 <a href="http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html" target="_blank" rel="external">2.2 version</a> 이네요!)</p>
<p>이와 같은 움직임은 Google에서 개발한 <code>Dart</code>에서도 찾아볼 수 있습니다. 하지만 얼마 전, 프론트엔드 개발자들의 눈길을 끌만한 소식이 들려왔습니다.</p>
<blockquote>
<p><a href="http://www.zdnet.co.kr/news/news_view.asp?artice_id=20170413085316&amp;lo=z45" target="_blank" rel="external">MS 타입스크립트, 구글 사내 표준 언어되다.</a></p>
</blockquote>
<p>Google이 만든 프론트엔드 프레임워크 Angular2(얼마 전, <a href="http://angularjs.blogspot.kr/2017/03/angular-400-now-available.html" target="_blank" rel="external">Angular4.0</a>이 release되었습니다.)도 Dart, JavaScript를 지원하지만 TypeScript를 공식 언어로 지정할만큼 TypeScript의 위상이 높아졌다는 것을 확인하실 수 있습니다.</p>
<p>이에 더해, 다들 아실만한 협업 툴인 Slack이 TypeScript로 전환했습니다. 다음 링크는 Slack이 코드베이스를 TypeScript로 전환하는 과정에 대한 글로, 정적 분석의 필요성에 대해 인지했다는 내용입니다. <a href="https://slack.engineering/typescript-at-slack-a81307fa288d" target="_blank" rel="external">TypeScript at Slack</a></p>
<p>Facebook에서 개발한 정적 타입 분석기(static typechecker of javascript) <code>Flow</code>도 마찬가지 행보가 아닐까 생각합니다. 애플리케이션의 규모가 커질 수록 안정성에 대한 수요는 높아지기 마련입니다. 동적 타입이라는 JavaScript가 갖고 있는 장점이자 한계점인 이 부분을 해결하기 위해 정적 분석의 중요도가 높아지고 있습니다.</p>
<h2 id="TypeScript의-현주소"><a href="#TypeScript의-현주소" class="headerlink" title="TypeScript의 현주소"></a>TypeScript의 현주소</h2><p>이젠 개발자들에게 없어서는 안 될 존재인 <code>Github</code>의 <a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="external">star</a>를 보니 <code>21,076개</code>입니다! (star개수가 64,556개인 React에 비하면 한참 멀었네요!) 올라온 Issue는 2,351개고 진행중인 Pull Request는 82개가 되네요.<br><img src="/images/github_typescript.png" alt=""><br>다음 자료는 Github과 마찬가지로 개발자들에게 없어선 안 되는 <a href="http://stackoverflow.com/insights/survey/2017/#most-loved-dreaded-and-wanted" target="_blank" rel="external">Stackoverflow의 조사 자료</a>입니다. 개발자들이 가장 사랑하는 언어로 Rust, Smalltalk에 이어 TypeScript가 3위를 당당히 차지했습니다.(오, 이 정도인가요?)<br><img src="/images/stackoverflow_survey.png" alt=""></p>
<p>추가된 Type System을 바탕으로 여러 가지 Tool과 구문 완성(content assist) 등의 도움을 받을 수 있는 TypeScript 소개였습니다. 얼마 전 공개된 <a href="https://github.com/Microsoft/reactxp" target="_blank" rel="external">ReactXP</a>를 만든 Microsoft의 지지로 React에서도 TypeScript 방향으로 가지 않을까 생각해봅니다.(Flow 의문의 1패?) 무엇을 공부해야 하나 걱정할 필요없는 프론트엔드 개발자분들을 응원합니다. 감사합니다 :)</p>
<p><em>cf. 짤막하게 정리해본 <a href="">TypeScript Quick Start</a>입니다.</em></p>
<h3 id="TypeScript와-관련된-글과-그룹"><a href="#TypeScript와-관련된-글과-그룹" class="headerlink" title="TypeScript와 관련된 글과 그룹"></a>TypeScript와 관련된 글과 그룹</h3><ul>
<li><a href="https://github.com/Microsoft/TypeScript-Handbook" target="_blank" rel="external">Microsoft/TypeScript-Handbook</a></li>
<li><a href="https://www.facebook.com/groups/TSKorea/?hc_ref=SEARCH" target="_blank" rel="external">TypeScript Korea 페이스북 그룹</a></li>
<li><a href="http://han41858.tistory.com/14" target="_blank" rel="external">TypeScript를 무서워하지 않아도 되는 이유(번역)</a></li>
<li><a href="https://hyunseob.github.io/2016/09/25/typescript-introduction/index.html" target="_blank" rel="external">TypeScript 소개(hyunseob님 블로그)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TypeScript-근황&quot;&gt;&lt;a href=&quot;#TypeScript-근황&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 근황&quot;&gt;&lt;/
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 6. Class sugar syntax</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/ES6-6-Class-sugar-syntax/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/ES6-6-Class-sugar-syntax/</id>
    <published>2017-04-18T12:11:41.000Z</published>
    <updated>2017-04-18T13:26:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p>
<h1 id="ES6-6-Class-sugar-syntax"><a href="#ES6-6-Class-sugar-syntax" class="headerlink" title="[ES6] 6. Class sugar syntax"></a>[ES6] 6. Class sugar syntax</h1><p>ES6에서 자바스크립트에는 존재하지 않았던 클래스(Class)가 도입되었다. 자바스크립트에 대해 잘 모르는 사람들이 Java에서의 클래스와 <strong>똑같은</strong> 기능을 하는 녀석인 줄 알고 많이 혼동한다. 자바스크립트는 기본적으로 프로토타입 기반의 언어이기 때문에 새로 도입된 이 클래스도 프로토타입 기반이다. 객체 지향을 <strong>흉내</strong>내고 있지만, 그 내부는 여전히 프로토타입으로 구성되어 있는 것이다. 프로토타입 기반으로 객체 지향적으로 설계하는 것이 복잡하여 클래스라는 <code>sugar syntax</code> 문법이 도입된 것이다. 그렇기 때문에 이에 따른 제약사항이 많다. 편한 만큼 고려해야할 사항도 많은 것이다. 하나씩 살펴보자.</p>
<h3 id="클래스는-선언문-또는-표현식으로-선언할-수-있다"><a href="#클래스는-선언문-또는-표현식으로-선언할-수-있다" class="headerlink" title="클래스는 선언문 또는 표현식으로 선언할 수 있다."></a>클래스는 선언문 또는 표현식으로 선언할 수 있다.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//클래스 선언문으로 클래스 선언</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">name</span> </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//클래스 표현식으로 클래스 선언</span></div><div class="line"><span class="keyword">let</span> name = <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> name = <span class="class"><span class="keyword">class</span> <span class="title">inner_name</span> </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name); <span class="comment">//function</span></div></pre></td></tr></table></figure>
<p>자바스크립트 엔진은 <code>class</code> 키워드를 만나면 <code>Class 오브젝트</code>를 생성한다. <code>Class 오브젝트</code>도 마찬가지로 <code>String</code>, <code>Function</code>과 같은 하나의 오브젝트 타입이다.<br><em>cf&gt; 표현식으로 선언했을 때의 inner-name은 클래스 내부에서 자신을 호출할 때 사용한다.</em></p>
<h2 id="Class-keyword-특징"><a href="#Class-keyword-특징" class="headerlink" title="Class keyword 특징"></a>Class keyword 특징</h2><ol>
<li>클래스의 선언부는 <code>let</code>과 <code>const</code>와 마찬가지로 호이스팅은 되지만 <code>temporary dead zone</code>이 형성된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Not hoisting</span></div><div class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//Error:Use before declaration</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>클래스를 선언한 다음, <code>new</code> 키워드를 통해 인스턴스를 생성할 수 있다.</p>
<ol>
<li>클래스의 코드는 ‘use strict’를 선언하지 않아도 strict 모드에서 실행된다.</li>
<li>메서드를 작성할 때, function 키워드와 콜론( : )을 작성하지 않는다.</li>
<li>메서드 사이에 콤마(,)를 작성하지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//class method</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    getName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"name"</span>);</div><div class="line">    &#125;</div><div class="line">    getScore() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"score"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> student = <span class="keyword">new</span> Student();</div><div class="line">student.getName(); <span class="comment">//name</span></div><div class="line">student.getScore(); <span class="comment">//score</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>바로 함수를 정의하고, 콤마(,)가 없다.</p>
<ol>
<li>생성자 함수를 통해 인스턴스를 생성하면 window에 설정되지만 class 키워드를 통해 생성하면 window에 설정되지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//window object?</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.Foo); <span class="comment">// function Foo() &#123;...&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.Student); <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Sugar-Syntax"><a href="#Sugar-Syntax" class="headerlink" title="Sugar Syntax"></a>Sugar Syntax</h3><p><code>Class</code> keyword는 <code>sugar syntax</code>라고 했다. 자바스크립트는 기본적으로 <code>prototype</code> 기반의 언어이기 때문에 엔진이 <code>prototype</code>에 메서드들을 연결한다. 즉, 클래스에서 메서드를 추가하면 자동으로 <code>prototype</code>에 추가되는 것이다. 자바스크립트에서는 프로토타입을 사용해서 클래스 밖에서도 메서드를 추가할 수 있다. 이미 생성된 인스턴스에 메서드를 추가하게 되면, 이전에 생성되었던 인스턴스들이 새로 추가된 메서드들을 공유해야하기 때문에 부하가 걸리지만 코드가 유연해진다는 장점도 존재한다. 위 예제코드에서 생성한 <code>Student</code> 클래스의 프로토타입에 새로운 메서드를 추가하고 이전에 생성되었던 인스턴스에서 새롭게 추가한 메서드를 호출할 수 있는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//add method to prototype</span></div><div class="line">Student.prototype.newMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Add new Method"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">student.newMethod(); <span class="comment">//Add new Method</span></div></pre></td></tr></table></figure></p>
<p><code>new</code> 연산자는 <code>constructor</code>를 호출하면서 받은 인자들을 <code>constructor</code>의 파라미터로 전달한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//new keyword</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, score) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.score = score;</div><div class="line">    &#125;</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Student(<span class="string">"Jbee"</span>, <span class="number">100</span>);</div><div class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">//Jbee</span></div><div class="line"><span class="built_in">console</span>.log(s.score); <span class="comment">//100</span></div><div class="line"><span class="built_in">console</span>.log(s.getName()); <span class="comment">//Jbee</span></div></pre></td></tr></table></figure></p>
<p>위 예제 코드에서 볼 수 있듯이 <code>class</code> 키워드로 선언한 클래스에 대해서 <code>new</code> keyword를 통해 인스턴스를 생성할 수 있다. 이 때 클래스 내부에 별도의 <code>constructor</code>가 설정되어 있지 않으면 기존의 <code>protytype</code>의 constructor가 호출되고 이를 <code>default constructor</code>라고 부른다. 별도로 작성된 <code>constructor</code>는 <code>Student.prototype.constructor</code>로 호출된다. </p>
<p><strong>new 키워드가 실행되는 메커니즘은 다음과 같다.</strong></p>
<pre><code>1. constructor는 우선적으로 빈(empty) 오브젝트(인스턴스)를 생성한다.
2. 넘겨받은 파라미터를 생성한 빈 오브젝트의 프로퍼티에 설정한다.
3. 인스턴스를 먼저 생성하므로, constructor 내부에서는 this keyword를 통해 인스턴스 자신을 가리킬 수 있다.
4. constructor에 별도의 return이 설정되어 있지 않으면 new를 실행한 곳으로 해당 클래스의 인스턴스를 반환한다.
</code></pre><p><em>cf) constructor는 별도의 return을 설정할 수 있다. 하지만 Number, String 값이 return value로 지정되어 있으면 이를 무시하고 인스턴스 자신을 return 한다.</em></p>
<h3 id="extends-keyword"><a href="#extends-keyword" class="headerlink" title="extends keyword"></a>extends keyword</h3><p>자바스크립트에서도 <code>extends</code>라는 키워드를 통해 클래스 간의 상속이 가능해졌다. 상속받은 클래스(이하 슈퍼클래스)의 메소드를 사용할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    getName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</div><div class="line">bar.getName(); <span class="comment">//Foo</span></div></pre></td></tr></table></figure></p>
<p>슈퍼 클래스의 메소드를 오버라이딩(Overriding)할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    getName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    getName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Bar"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</div><div class="line">bar.getName(); <span class="comment">//Bar</span></div></pre></td></tr></table></figure></p>
<p><code>super</code> 키워드를 통해 슈퍼 클래스의 메소드에 접근할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Foo"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">" Bar"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</div><div class="line">bar.getName(); <span class="comment">//Foo Bar</span></div></pre></td></tr></table></figure></p>
<h3 id="constructor-keyword"><a href="#constructor-keyword" class="headerlink" title="constructor keyword"></a>constructor keyword</h3><p>서브 클래스에서 정의된 <code>constructor</code>가 없다면 슈퍼 클래스의 <code>constructor</code>가 호출된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo constructor"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</div><div class="line"><span class="comment">//console&gt; Foo constructor</span></div></pre></td></tr></table></figure></p>
<p>서브 클래스에서 <code>constructor</code>를 정의하려면 <strong>반드시</strong> constructor 내부에서 <code>super()</code>를 <strong>호출</strong>해야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Bar"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</div><div class="line"><span class="comment">//ReferenceError: this is not defined</span></div></pre></td></tr></table></figure></p>
<p><code>constructor()</code>메소드 안에서 <code>super()</code>를 호출해주면, 슈퍼 클래스가 생성되고 서브 클래스가 생성된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo constructor"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Bar constructor"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</div><div class="line"><span class="comment">//console&gt; Foo constructor</span></div><div class="line"><span class="comment">//console&gt; Bar constructor</span></div></pre></td></tr></table></figure></p>
<h3 id="static-keyword"><a href="#static-keyword" class="headerlink" title="static keyword"></a>static keyword</h3><p>자바스크립트 클래스에서 <code>static</code> 키워드를 사용하면 정적 메소드를 정의할 수 있다. 정적 메소드라 함은 인스턴스를 생성하지 않고 사용할 수 있는 메소드를 말한다. 정적 메소드는 인스턴스를 생성하지 않고도 호출할 수 있지만 인스턴스에서는 호출할 수 없다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> getName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.getName(); <span class="comment">//Foo</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</div><div class="line">foo.getName();<span class="comment">//not a function</span></div></pre></td></tr></table></figure></p>
<p>정적 메소드는 <code>prototype</code>에 추가되지 않는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> getName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getAlias() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Foo.prototype.getName === Foo.getName);<span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(Foo.prototype.getAlias === <span class="keyword">new</span> Foo().getAlias);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>클래스 내부에서 <code>정적 변수(static variable)</code>를 지정할 수는 없지만 클래스 밖에서 지정할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line">Foo.name = <span class="string">"foo"</span>;</div></pre></td></tr></table></figure></p>
<h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p><code>new.target</code>을 이용하면 슈퍼 클래스에서 서브 클래스의 static method에 접근할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);<span class="comment">//[Function: Bar]</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span>.target);<span class="comment">//function</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo: "</span>, <span class="keyword">new</span>.target.getName());<span class="comment">//Foo: bar</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> getName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"bar"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</div></pre></td></tr></table></figure></p>
<p>ES6에서 추가된 sugar syntax class에 대해 정리해봤다. TypeScript에서는 보다 더 객체지향적인 클래스로서 사용할 수 있다. 아직 불완전한 ES6의 클래스는 신경써야할 부분도 많지만 제대로 이해하면 <code>prototype</code>을 사용하는 것보다 효율적으로 자바스크립트 코드를 작성할 수 있을 것이다.</p>
<p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="external">Github Respository</a>에서 확인하실 수 있습니다.</p>
<p><em>6. end</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-6-Class-sugar-syntax&quot;&gt;&lt;a href=&quot;#ES6-6-Class-sugar-syntax&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 5. Destructuring and Default Parameter</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/ES6-5-Destructuring-and-Default-Parameter/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/ES6-5-Destructuring-and-Default-Parameter/</id>
    <published>2017-04-18T11:59:34.000Z</published>
    <updated>2017-04-18T12:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p>
<h1 id="ES6-5-Destructuring-and-Default-Parameter"><a href="#ES6-5-Destructuring-and-Default-Parameter" class="headerlink" title="[ES6] 5. Destructuring and Default Parameter"></a>[ES6] 5. Destructuring and Default Parameter</h1><h2 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a>Destructuring</h2><p><code>shorthand</code> 방식을 이용하여 함수의 반환값을 <strong>바로 객체에 할당</strong>할 수 있다. 이 때 함수에서 반환되는 <strong>프로퍼티 값</strong>과 <strong>지역 변수</strong>의 이름이 같아야 가능하다. 이렇게 하면 함수의 반환 값을 <strong>임시 객체에 저장</strong>하고 그 객체의 프로퍼티를 통해 접근하여 지역 변수에 할당하는 과정을 축소할 수 있다. 굳이 전체를 객체에 할당하지 않고 부분적으로만 할당도 가능하다. 즉, 리턴되는 값이 객체일 경우, 그 객체를 분해하여 바로 지역변수로 접근이 가능하다는 것이다. (iterable protocol을 구현해야만 destructuring이 가능하다.)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUser</span>(<span class="params">first, last</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> fullName = first + <span class="string">" "</span> + last;</div><div class="line">    <span class="keyword">return</span> &#123;first, last, fullName&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> &#123; first, last, fullName &#125; = buildUser(<span class="string">"Sam"</span>, <span class="string">"Williams"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(first); <span class="comment">// Sam</span></div><div class="line"><span class="built_in">console</span>.log(last); <span class="comment">// Williams</span></div><div class="line"><span class="built_in">console</span>.log(fullName); <span class="comment">// Sam Williams</span></div></pre></td></tr></table></figure></p>
<p>굳이 전체를 객체에 할당하지 않고 부분적으로만 할당도 가능하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; fullName &#125; = buildUser(<span class="string">"Sam"</span>, <span class="string">"Williams"</span>);</div><div class="line"><span class="built_in">console</span>.log( fullName ); <span class="comment">// Sam Williams</span></div></pre></td></tr></table></figure></p>
<h3 id="Method-Initializer-Shorthand"><a href="#Method-Initializer-Shorthand" class="headerlink" title="Method Initializer Shorthand"></a>Method Initializer Shorthand</h3><p>객체에 함수를 추가할 때, 객체의 프로퍼티에 익명 함수를 추가하는 방식을 사용했다. ES6에서는 메소드를 활용한다. 비교를 위해 ES5도 함께 제시한다.<br><em>ES6code&gt;&gt;</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUser</span>(<span class="params">first, last, postCount</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        first,</div><div class="line">        last,</div><div class="line">        <span class="attr">isActive</span> : <span class="function"><span class="keyword">function</span>(<span class="params"> </span>) </span>&#123;</div><div class="line">            <span class="comment">//...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>ES6code&gt;&gt;</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUser</span>(<span class="params">first, last, postCount</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        first,</div><div class="line">        last,</div><div class="line">        isActive( ) &#123;</div><div class="line">            <span class="comment">//...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Destructuring-Assignment"><a href="#Destructuring-Assignment" class="headerlink" title="Destructuring Assignment"></a>Destructuring Assignment</h3><p>오른쪽의 배열을 분할하여 왼쪽 변수에 값을 <code>할당</code>한다. 인덱스 번째의 엘리먼트 값을 인덱스 번째의 변수에 할당하는 것이다. 엘리먼트가 아직 남았는데 할당할 변수가 없다면 그대로 할당되지 않고, 엘리먼트가 남지 않았는데 할당한 변수가 있다면 그 변수는 <code>undefined</code>로 할당된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> one, two, three, four;</div><div class="line"><span class="comment">//case1</span></div><div class="line">[one, two] = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(one); <span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(two); <span class="comment">//2</span></div><div class="line"><span class="comment">//case2</span></div><div class="line">[one, two, three] = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(one); <span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(two); <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(three);<span class="comment">//undefined</span></div><div class="line"><span class="comment">//case3</span></div><div class="line">[one, two] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(one); two<span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(two); <span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>이전 Chapter에서 다뤘던 <code>Spread</code> 연산자를 사용할 수 있으며, 공백으로 두어 해당 값을 건너 뛰고 <code>할당</code>할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[one, ...other] = [<span class="number">1</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>];</div><div class="line"><span class="built_in">console</span>.log(one); <span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(other); <span class="comment">//[23, 24, 25]</span></div><div class="line"></div><div class="line">[one, , , four] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(one); <span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(four); <span class="comment">//4</span></div></pre></td></tr></table></figure></p>
<h2 id="Default-Value"><a href="#Default-Value" class="headerlink" title="Default Value"></a>Default Value</h2><p><code>destructuring</code>을 통해 값을 할당할 때, 해당하는 값이 없을 때, <code>undefined</code> 대신 할당할 default value를 지정해줄 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [first, second, third = <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(first); <span class="comment">//1 by destructuring</span></div><div class="line"><span class="built_in">console</span>.log(second); <span class="comment">//2 by destructuring</span></div><div class="line"><span class="built_in">console</span>.log(third); <span class="comment">//3 by default value</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [fourth, fifth, sixth = <span class="number">6</span>] = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">66</span>];</div><div class="line"><span class="built_in">console</span>.log(first); <span class="comment">//4 by destructuring</span></div><div class="line"><span class="built_in">console</span>.log(second); <span class="comment">//5 by destructuring</span></div><div class="line"><span class="built_in">console</span>.log(third); <span class="comment">//66 by destructuring</span></div></pre></td></tr></table></figure></p>
<h2 id="Default-Parameter"><a href="#Default-Parameter" class="headerlink" title="Default Parameter"></a>Default Parameter</h2><p>parameter에 값이 넘어가지 않아도, default value로 설정된 값이 해당 파라미터 대신 값이 할당된다. parameter에서도 마찬가지로 기존의 default value는 <code>undefined</code> 값이었지만, 그 값을 코드 상에서 설정할 수 있게 된 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> somethingFunction = <span class="function">(<span class="params">prev, post = <span class="number">20</span></span>) =&gt;</span> prev + post;</div><div class="line"><span class="built_in">console</span>.log(somethingFunction(<span class="number">1</span>)); <span class="comment">//21 by default parameter</span></div><div class="line"><span class="built_in">console</span>.log(somethingFunction(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(somethingFunction(<span class="number">1</span>, <span class="literal">undefined</span>)); <span class="comment">//21 by default parameter</span></div><div class="line"><span class="built_in">console</span>.log(somethingFunction(<span class="number">1</span>, <span class="literal">null</span>)); <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>함수에도 <code>length</code>라는 <code>property</code>가 따로 존재한다. 그런데 이 때, <code>default parameter</code>는 <code>length</code>에서 무시된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getTotal(<span class="number">100</span>); <span class="comment">//1</span></div><div class="line">getTotal(<span class="number">100</span>, <span class="number">0.05</span>); <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(getTotal.length); <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>한 가지 주의할 점이 있다. <code>let</code>으로 선언했을 때의 값은 Default parameter와는 다르기 때문에, <code>Destructuring</code>으로 값을 덮어쓸 수 있다. <code>let</code>으로 선언했을 때 할당하는 것과는 다르다.<br><em>default parameter code&gt;&gt;</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> salary = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</div><div class="line"><span class="keyword">let</span> [low, avg, high = <span class="number">500</span>] = salary;</div><div class="line"><span class="built_in">console</span>.log(high); <span class="comment">//500</span></div></pre></td></tr></table></figure></p>
<p><em>let assignment code</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> low, avg, high = <span class="number">500</span>;</div><div class="line"><span class="keyword">let</span> [low, avg, high] = salary;</div><div class="line"><span class="built_in">console</span>.log(high); <span class="comment">//300</span></div></pre></td></tr></table></figure></p>
<p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="external">Github Respository</a>에서 확인하실 수 있습니다.</p>
<p><em>5. end</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-5-Destructuring-and-Default-Parameter&quot;&gt;&lt;a href=&quot;#ES6-5-Destructuring-and-De
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 4. Spread, Rest parameter</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/ES6-4-Spread-Rest-parameter/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/ES6-4-Spread-Rest-parameter/</id>
    <published>2017-04-18T11:59:13.000Z</published>
    <updated>2017-04-18T12:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p>
<h1 id="ES6-4-Spread-Rest-parameter"><a href="#ES6-4-Spread-Rest-parameter" class="headerlink" title="[ES6] 4. Spread, Rest parameter"></a>[ES6] 4. Spread, Rest parameter</h1><h2 id="Spread"><a href="#Spread" class="headerlink" title="Spread"></a>Spread</h2><p>이터러블 오브젝트(Iterable object)의 엘리먼트를 하나씩 분리하여 전개한다. 전개한 결과를 변수에 할당하거나 호출하는 함수의 파라미터 값으로 사용할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> prev = [<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"><span class="keyword">let</span> post = [<span class="number">7</span>,<span class="number">8</span>];</div><div class="line"><span class="keyword">let</span> spreadObj = [<span class="number">1</span>, <span class="number">2</span>, ...prev, <span class="number">5</span>, <span class="number">6</span>, ...post, <span class="number">9</span>];</div><div class="line"><span class="built_in">console</span>.log(spreadObj); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></div></pre></td></tr></table></figure></p>
<p>문자열도 가능하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sObj = [...<span class="string">"javascript"</span>];</div><div class="line"><span class="built_in">console</span>.log(sObj); <span class="comment">// ["j", "a", "v", "a", "s", "c", "r", "i", "p", "t"]</span></div></pre></td></tr></table></figure></p>
<h2 id="Rest-Parameter"><a href="#Rest-Parameter" class="headerlink" title="Rest Parameter"></a>Rest Parameter</h2><p>함수를 호출할 때 <code>spread</code> 연산자로 파라미터를 작성한 형태를 <code>Rest parameter</code>라고 한다. 함수안의 코드를 확인하지 않고도 호출문의 형태만 보더라도 <code>Rest parameter</code> 의 범위를 확인할 수 있어 가독성이 높아진다. 또한 <code>Rest parameter</code>는 <code>Array</code>, 즉 배열이므로 <code>Array</code> 오브젝트의 메서드를 사용할 수 있다. 그리고 <code>arrow funtion</code>에서도 사용 가능하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> price = [<span class="number">12</span>, <span class="number">20</span>, <span class="number">18</span>];</div><div class="line"><span class="built_in">Math</span>.max(<span class="number">12</span>, <span class="number">20</span>, <span class="number">18</span>);</div></pre></td></tr></table></figure></p>
<p>built in Object인 <code>Math</code>의 메소드 <code>max()</code>를 사용하기 위해서는 위 코드처럼 하나씩 넘겨줘야 한다.<br>또는 다음과 같은 방식을 사용했다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>, price);</div></pre></td></tr></table></figure></p>
<p>하지만 Rest parameter를 사용하면 보다 깔끔하게 작성할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> maxPrice = Max.max(...price);</div></pre></td></tr></table></figure></p>
<p><code>Rest parameter</code>는 동적(dynamic)으로 생성된 파라미터라고 할 수 있기 때문에 함수의 <code>length</code>에서 포함되지 않는다. 기본적으로 함수의 <code>length</code> 프로퍼티는 파라미터의 개수를 의미한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> getElementByRestWithParam = <span class="function">(<span class="params">param, ...rest</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(param);</div><div class="line">    <span class="built_in">console</span>.log(rest);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(getElementByRestWithParam.length); <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>위 <code>getElementByRestWithParam</code>메소드에 <code>spread operator</code>를 사용하여 인자를 넘겨보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> values = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</div><div class="line">getElementByRestWithParam(...values); <span class="comment">//10 \n [20, 30]</span></div></pre></td></tr></table></figure></p>
<p><code>param</code>에 해당하는 인자가 따로받아지고 나머지 인자들은 <code>...rest</code>로 넘겨지면서 다시 배열로 넘겨지게 된다!</p>
<p><code>Rest parameter</code>를 사용했을 때와 기존의 자바스크립트에서 <code>arguments</code>를 사용했을 때의 차이점을 살펴보기 위해 <code>arguments</code>에 대해서 잠깐 살펴보자. <code>arguments</code>는 <code>Array-Like Object</code>라는 공식 명칭을 하고 있는 유사 배열이다.</p>
<h2 id="Array-like-Object-유사배열"><a href="#Array-like-Object-유사배열" class="headerlink" title="Array-like Object(유사배열)"></a>Array-like Object(유사배열)</h2><p>배열의 특징 중 하나는 index를 갖고 있어서 임의 접근(random access)가 가능하고, 그 index가 순차적으로 증가한다는 것이다. 만약 Object가 key값이 순차적으로 증가하는 값이고, 그에 따른 value가 존재한다고 했을 때, <code>Array-like Object</code>라고 한다.<br>배열의 인덱스 값을 프로퍼티 key 값으로 사용하는 것이다. 그리고 <code>length</code>라는 프로퍼티 값을 갖고 있어서 전개를 할 때는 다음과 같이 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Array-like object</span></div><div class="line"><span class="keyword">let</span> arrLikeObj = &#123;</div><div class="line">    <span class="number">0</span> : <span class="string">"zero"</span>,</div><div class="line">    <span class="number">1</span> : <span class="string">"one"</span>,</div><div class="line">    <span class="number">2</span> : <span class="string">"two"</span>,</div><div class="line">    <span class="attr">length</span> : <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrLikeObj.length; i++) &#123;</div><div class="line">    <span class="built_in">console</span>.log(arrLikeObj[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Array-like Object</code>는 다음 두 가지 규칙을 모두 만족시켜야 한다.<br>1) 프로퍼티 값을 0부터 1씩 증가하면서 순차적으로 작성해야 한다.<br>2) length를 프로퍼티 키로 하여 전체 프로퍼티 수를 작성해야 한다.</p>
<h3 id="Rest-parameter와-arguments의-차이"><a href="#Rest-parameter와-arguments의-차이" class="headerlink" title="Rest parameter와 arguments의 차이"></a>Rest parameter와 arguments의 차이</h3><p><code>arguments</code>도 <code>Array-like object</code>이기 때문에 <code>for statement</code>로 전개할 수 있다. 하지만 <code>Array</code> 오브젝트의 메서드를 사용할 수 없다. 이것이 치명적인 단점인 것이다. 또 <code>arrow function</code>에서는 <code>arguments</code>를 사용할 수 없다. 이것으로 미루어보아, ES6에서는 <code>arguments</code>를 사용하는 것을 최대한 자제하라는 느낌이다. 사실 <code>Rest parameter</code>에 익숙해지기만 하면 <code>arguments</code>를 통해 인자를 받는 것보다 유연한 코드를 작성할 수 있다.</p>
<p>한 가지 더 한계점을 지적하자면 <code>arguments</code>는 함수 내부를 봐야 어느 부분에서 <code>arguments</code> 객체를 사용하는지 알 수 있어 코드의 가독성이 떨어지게 된다. 그렇기 때문에 <code>arguments</code> 대신 <code>Rest parameter</code>를 도입한 것이다.</p>
<p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="external">Github Respository</a>에서 확인하실 수 있습니다.</p>
<p><em>4. end</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-4-Spread-Rest-parameter&quot;&gt;&lt;a href=&quot;#ES6-4-Spread-Rest-parameter&quot; class=&quot;head
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 3. Iteration and for-of statement</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/ES6-3-Iteration-and-for-of-statement/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/ES6-3-Iteration-and-for-of-statement/</id>
    <published>2017-04-18T04:52:45.000Z</published>
    <updated>2017-04-18T04:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p>
<h1 id="ES6-3-Iteration-and-for-of-statement"><a href="#ES6-3-Iteration-and-for-of-statement" class="headerlink" title="[ES6] 3. Iteration and for-of statement"></a>[ES6] 3. Iteration and for-of statement</h1><h2 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h2><p>ES6에서 이터레이션 프로토콜은 <code>Iterable 프로토콜</code>과 <code>Iterator 프로토콜</code>로 구성된다. 결론부터 말하자면 <code>Iterable</code> 프로토콜은 <code>반복 가능한</code> 오브젝트를 나타내는 프로토콜이며 <code>Iterator</code> 프로토콜은 이터러블 오브젝트(<code>Iterable</code> 프로토콜을 따르는 오브젝트)의 값을 <code>작성한 순서대로</code> 처리하는 프로토콜이다.</p>
<h2 id="Iterable-프로토콜"><a href="#Iterable-프로토콜" class="headerlink" title="Iterable 프로토콜"></a>Iterable 프로토콜</h2><p>오브젝트의 반복 처리 규약을 정의한다.<br>Iterable Object</p>
<blockquote>
<p><code>String</code>, <code>Array</code>, <code>Map</code>, <code>Set</code>, <code>TypedArray</code>, <code>Argument</code> 오브젝트 그리고 DOM의 <code>NodeList</code>  </p>
</blockquote>
<p>위 <em>built in 오브젝트</em>들은 디폴트로 이터러블 프로토콜을 갖고 있다. 오브젝트에 <code>Symbol.iterator</code>가 있어야 한다. <code>Symbol.iterator</code>가 있는 오브젝트는 이터러블 오브젝트이다. 또한 상속받은 prototype chain에 있어도 이터러블 오브젝트이다. (Symbol에 대해서는 다음 포스팅에서 다룰 예정이다.)</p>
<p>오브젝트에 프로퍼티 존재 여부를 체크할 때, Symbol의 경우에는 arrayObj[Symbol.iterator]와 같이 대괄호 []안에 작성해야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [];</div><div class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]); <span class="comment">//function values() &#123; [native code] &#125;</span></div><div class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>.iterator]); <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p><code>Array</code> 오브젝트는 기본적으로 <code>iterable</code> 프로토콜을 구현한다. 하지만 <code>Object</code> 오브젝트는 <code>iterable</code> 프로토콜을 구현하지 않는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> iteratorObj = arr[<span class="built_in">Symbol</span>.iterator](); <span class="comment">//iterator object</span></div></pre></td></tr></table></figure></p>
<p>위와 같은 방식으로 <code>Array</code> 오브젝트는 <code>iterator</code>를 받을 수 있다.</p>
<h2 id="JavaScript’s-for-statement"><a href="#JavaScript’s-for-statement" class="headerlink" title="JavaScript’s for statement"></a>JavaScript’s for statement</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>forEach 문은 arrow function과 조합해서 사용하면 추가적인 변수 사용 없이 코드가 깔끔해질 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> categories = [<span class="string">"Korean"</span>, <span class="string">"English"</span>, <span class="string">"Science"</span>];</div><div class="line">categories.forEach(<span class="function"><span class="params">subject</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(subject);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>&gt;</div><div class="line">Korean</div><div class="line">English</div><div class="line">Science</div></pre></td></tr></table></figure></p>
<p>그러나 for문 중간에 <code>continue</code> or <code>break</code> or <code>return</code> 선언문을 사용할 수 없다. 기존의 for-statement를 사용하는 경우를 보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subject.length; i++) &#123;</div><div class="line">    <span class="built_in">console</span>.log(categoried[i]);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>&gt;</div><div class="line">Korean</div><div class="line">English</div><div class="line">Science</div></pre></td></tr></table></figure></p>
<p><code>i</code>의 역할이 index를 잡아주는 것 외에 별 다른 기능이 없다. 그래서 기존에는 <code>for-in statement</code>를 사용했다. 하지만 <code>for-in statement</code> 은 문자열 키를 가진 일반 <code>Object</code> 객체들을 위해 만들어졌다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> categories) &#123;</div><div class="line">    <span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>&gt;</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>그래서 ES6에서 <code>for-of statement</code>가 등장했다.<br><code>for-in loop statement</code>는 객체의 프로퍼티들을 루프시키지만 <code>for-of loop statement</code>는 데이터, 즉 배열 내의 value들을 루프시킨다. 또한 for-of는 배열 뿐만 아니라 다양한 Collection에도 동작한다. DOM의 <code>NodeList</code> 같은 유사배열 객체들에도 동작하고 문자열에도 동작한다. 문자열을 유니코드 문자의 배열로 취급하는 것이다. <code>Set</code>, <code>Map</code>에 대해서도 물론 동작한다. key-value 형식의 <code>Map</code>에 대해서는 for (let [key, value] of …) 형식의 <code>destructuring</code>을 사용한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> categories) &#123;</div><div class="line">    <span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>&gt;</div><div class="line">Korean</div><div class="line">English</div><div class="line">Science</div></pre></td></tr></table></figure></p>
<p>단 for-of 가 만능은 아니다. <code>Object</code>의 프로퍼티를 루프시키려면 <code>for-in statement</code>를 사용해야 한다. 사실 <code>for-in statement</code>의 원래 목적이 <code>Object</code> 프로퍼티 순회이다. Object를 순회하는 경우를 살펴보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">one</span> : <span class="number">1</span>,</div><div class="line">    <span class="attr">two</span> : <span class="number">2</span>,</div><div class="line">    <span class="attr">three</span> : <span class="number">3</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>위와 같은 obj라는 오브젝트를 정의한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// console&gt;</span></div><div class="line"><span class="comment">// one</span></div><div class="line"><span class="comment">// two</span></div><div class="line"><span class="comment">// three</span></div></pre></td></tr></table></figure></p>
<p><code>for-in statement</code>를 통해서 정의한 오브젝트(obj)의 key를 순회했다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">    <span class="built_in">console</span>.log(obj[key]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// console&gt;</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>오브젝트를 <code>for-of statment</code>로 순회하면 어떻게 될까?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> obj) &#123;</div><div class="line">    <span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div><div class="line"><span class="comment">// console&gt;</span></div><div class="line"><span class="comment">// Uncaught TypeError: obj[Symbol.iterator] is not a function</span></div></pre></td></tr></table></figure></p>
<p>JavaScript의 Object는 <code>iterable</code> 프로토콜을 구현하고 있지 않기 때문에, <code>Symbol.iterator</code>가 존재하지 않는다.</p>
<p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="external">Github Respository</a>에서 확인하실 수 있습니다.</p>
<p><em>3. end</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-3-Iteration-and-for-of-statement&quot;&gt;&lt;a href=&quot;#ES6-3-Iteration-and-for-of-stat
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 2. Arrow function</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/ES6-2-Arrow-function/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/ES6-2-Arrow-function/</id>
    <published>2017-04-18T04:51:49.000Z</published>
    <updated>2017-04-18T04:54:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p>
<h1 id="ES6-2-Arrow-Function"><a href="#ES6-2-Arrow-Function" class="headerlink" title="[ES6] 2. Arrow Function"></a>[ES6] 2. Arrow Function</h1><blockquote>
<p>Always apply to ‘Anonymous function’  </p>
</blockquote>
<h3 id="자바스크립트의-Scope"><a href="#자바스크립트의-Scope" class="headerlink" title="자바스크립트의 Scope"></a>자바스크립트의 Scope</h3><p>자바스크립트에서 생성자 함수를 통해 객체를 생성하면 변수 scope가 변경된다. 즉, 생성자 함수 내부에서의 this는 자신을 호출한 대상이 아닌 생성자 함수를 가리키게 된다. 생성자 함수를 통해 생성되는 객체의 과정 때문이다. 그래서 우리는 여태껏 별의 별짓을 다해왔다. <code>self</code>며 <code>bind</code>며 jQuery에서는 <code>proxy</code>라는 녀석도 사용했다.</p>
<h3 id="새로운-function의-등장"><a href="#새로운-function의-등장" class="headerlink" title="새로운 function의 등장"></a>새로운 function의 등장</h3><p>하지만 이제는 새로 도입된 Arrow function 을 사용하여 변수 스코프를 보존하자. Arrow function를 통해서 함수를 정의하게 되면, 변수들이 사용되는 위치와는 상관없이 변수들이 정의되어 있는 값으로 scope가 binding  된다. 한 가지 특징을 덧붙이자면, arrow function을 사용하게 되면 <code>arguments</code> 객체가 생성되지 않는다. 하지만 우리는 ES6 문법을 사용하는 이상, <code>arguments</code>는 필요하지 않다!</p>
<h3 id="Arrow-function-Rule"><a href="#Arrow-function-Rule" class="headerlink" title="Arrow function Rule"></a>Arrow function Rule</h3><p>ES6의 arrow function에는 몇 가지 규칙이 존재하며 대부분의 <code>lamda</code>에서도 비슷한 규칙을 가지고 있어서 <code>lamda</code>를 사용해본 경험이 있다면 어색하지 않을 것이다.<br>1) Parameter와 화살표 사이에서 개행할 수 없다.<br>2) Parameter가 하나일 때는 괄호를 생략할 수 있다.<br>3) Parameter가 없으면 소괄호( ( ) )만 작성한다.<br>4) Block scope({ })를 지정하지 않고 한 줄로 arrow function을 사용할 때는 return이 생략될 수 있다.<br>5) 그 반대로 block scope를 사용한다면 return을 명시해줘야 한다.</p>
<h3 id="Arrow-Function은-this를-bind하지-않는다"><a href="#Arrow-Function은-this를-bind하지-않는다" class="headerlink" title="Arrow Function은 this를 bind하지 않는다!"></a>Arrow Function은 this를 bind하지 않는다!</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"todos"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//#todos</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"todos"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//Window</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="this의-정체"><a href="#this의-정체" class="headerlink" title="this의 정체"></a>this의 정체</h3><p>ES5에서 <code>this</code> 결정되는 세 가지 조건을 짚고 넘어가자.<br>1) 생성자 내에서<br>생성자 함수를 <code>new</code>라는 키워드를 통해 호출하면 내부에서 <code>this</code>는 인스턴스 그 자체를 가리킨다. 생성자 함수 내부에서 <code>return this;</code>가 생략되어 있기 때문이다.<br>2) 함수 내에서<br><code>this</code>는 생략된 매개 변수이다. 무엇이 함수를 호출했는가가 <code>this</code>를 결정한다.<br>3) <code>bind</code>, <code>apply</code>, <code>call</code> method or <code>proxy</code> method of jQuery<br><code>this</code>는 메소드로 바꿔준 대상을 가리키게 된다.</p>
<blockquote>
<p>그렇다면 arrow function 내에서 <code>this</code>는 무엇을 가리키는가.</p>
</blockquote>
<p>해당 function을 정의한 영역의 <code>this</code>를 가져온다. 한 단계 더 위의 <code>element</code>를 가리키는 것이다. 그렇기 때문에 <code>prototype</code>에 함수를 정의할 때 arrow function을 사용할 때 내부적으로 <code>this</code>를 사용하게 되면 객체를 가리키지 않고 <code>window</code> 객체를 가리키게 된다. 또한 arrow function은 명식적으로 <code>bind</code>, <code>call</code>로 <code>this</code>를 넣어줘도 이를 무시한다. </p>
<p>ES6의 arrow function은 단순히 함수를 간단하게 작성할 수 있는 문법이 아니다. 기존의 방식대로 function을 작성해야만 의도대로 작동하는 function이 존재할 수 있고, arrow function으로 기존의 function을 작성하던 방식보다 편하게 작성할 수 있게 된 것이다. 두 가지 방식의 차이점을 제대로 이해하고 새로운 문법과 기존의 문법을 적재적소에서 사용하는 것이 중요해졌다.</p>
<p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="external">Github Respository</a>에서 확인하실 수 있습니다.</p>
<p><em>2. end</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-2-Arrow-Function&quot;&gt;&lt;a href=&quot;#ES6-2-Arrow-Function&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 1. let-const</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/let-const/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/let-const/</id>
    <published>2017-04-18T04:48:49.000Z</published>
    <updated>2017-04-18T06:48:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p>
<h1 id="ES6-1-let-amp-const"><a href="#ES6-1-let-amp-const" class="headerlink" title="[ES6] 1. let &amp; const"></a>[ES6] 1. let &amp; const</h1><h2 id="자바스크립트의-정체"><a href="#자바스크립트의-정체" class="headerlink" title="자바스크립트의 정체"></a>자바스크립트의 정체</h2><p>ES6의 문법을 알아보기 전에 자바스크립트의 정체부터 짚고 넘어가자. 자바스크립트(JavaScript)는 스크립트 언어(script language)이다. 스크립트 언어란 언어를 해석하고 실행하는 소프트웨어가 따로 존재하는 언어를 말한다. 자바스크립트를 해석하고 실행하는 소프트웨어는 브라우저이다. 이러한 의미에서 Node.js는 스크립트 언어라고 부르기 애매하고 자바스크립트의 문법을 차용한 다른 종류의 언어라고 생각해도 된다. 우선 자바스크립트가 해석되고 실행될 때 일어나는 확보, 선언, 할당의 차이를 짚고 넘어가야 한다.</p>
<h3 id="확보"><a href="#확보" class="headerlink" title="확보"></a>확보</h3><p>브라우저가 자바스크립트를 해석할 때 두 번 파싱(parsing)하는데 첫번째 파싱 과정이 Lexical parsing이다. 실행하려는 자바스크립트 파일이 어느 정도의 메모리를 필요로 하는지를 파악하기 위해 거치는 파싱 과정인 것이다. 이 때 자바스크립트의 모든 선언문은 호이스팅(Hoisting)된다.</p>
<h3 id="선언"><a href="#선언" class="headerlink" title="선언"></a>선언</h3><p>말 그대로 선언하는 것이다. 값을 할당하지 않는다. 자바스크립트에서는 선언만 하고 값을 할당하지 않으면 <code>undefined</code>값이 할당된다. 확보만 하고 선언하지 않으면 <code>Reference error</code>가 발생하고 선언을 하게 되면 <code>undefined</code> 값이 나타난다.</p>
<h3 id="할당"><a href="#할당" class="headerlink" title="할당"></a>할당</h3><p>특정 변수에 값을 할당하는 과정이다. 위 세 가지를 파악해야 var와 let 그리고 const의 차이를 이해할 수 있다</p>
<h2 id="let-으로-변수-선언-및-할당하기"><a href="#let-으로-변수-선언-및-할당하기" class="headerlink" title="let 으로 변수 선언 및 할당하기"></a>let 으로 변수 선언 및 할당하기</h2><p><code>let</code>으로 정의된 변수들은 호이스팅 되지 않는다(?) 많은 책에서 이렇게 표현을 하고 있지만 이것은 잘못된 표현이다. <code>let</code>으로 선언해도 호이스팅된다. lexical parsing 단계에서 해당 자바스크립트 파일을 실행하기 위한 메모리 공간을 <code>확보</code>해야하기 때문이다. 다만 let 변수로 선언이 되기 전 해당 변수를 사용하려고 하면 <code>Reference error</code>를 발생시키는 것이다. 예제 코드를 보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5 code :: var&gt;&gt;</span></div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//undefined</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//undefined</span></div><div class="line">foo = <span class="number">123</span>;</div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//123</span></div><div class="line"><span class="comment">//ES6 code :: let&gt;&gt;</span></div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//ReferenceError</span></div><div class="line"><span class="keyword">let</span> foo;</div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//undefined</span></div><div class="line">foo = <span class="number">123</span>;</div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//123</span></div></pre></td></tr></table></figure></p>
<p>let은 유효범위의 시작에서부터 <code>선언</code>될 때까지 <code>temporary dead zone</code>(일시적 사각지대)에 있다. 이 dead zone에서 사용하게 되면 <code>ReferenceError</code>가 발생한다.</p>
<h2 id="let-in-for-loop"><a href="#let-in-for-loop" class="headerlink" title="let - in for loop"></a>let - in for loop</h2><p><code>let</code>으로 정의된 변수들은 가장 가까운 블록으로 scope이 지정된다. 여기서 블록이란 <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code> 같은 문법으로 지정된 { } 블록을 의미한다. <code>let</code> 키워드를 사용한 변수들은 그들 각각의 함수 block에 귀속된다. <code>var</code> 변수는 함수의 상단으로 호이스팅(hoisting) 된 다음에, 각 루프의 반복 변수가 공유하게 된다. 그 결과, 콜백이 실행될 때는 <code>i</code> 변수가 루프의 마지막 변수로 할당된다. 즉 콜백에서 반복문을 제어하는 변수에 접근할 때 문제가 발생하는 것이다. 이러한 문제를 해결하기 위해 <code>let</code>을 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5 code</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadFiles</span>(<span class="params"> userNames </span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> userNames)&#123;</div><div class="line">        _fetchProfiles(userNames[i], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(userNames[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">loadFiles([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span> &gt;</div><div class="line">D <span class="comment">// userNames[4]</span></div><div class="line">D <span class="comment">// userNames[4]</span></div><div class="line">D <span class="comment">// userNames[4]</span></div><div class="line">D <span class="comment">// userNames[4]</span></div></pre></td></tr></table></figure>
<p>ES6 code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6 code</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadFiles</span>(<span class="params"> userNames </span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i <span class="keyword">in</span> userNames )&#123;</div><div class="line">        _fetchProfile(userNames[i], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(userNames[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">loadFiles([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span> &gt;</div><div class="line">A <span class="comment">// userNames[1]</span></div><div class="line">B <span class="comment">// userNames[2]</span></div><div class="line">C <span class="comment">// userNames[3]</span></div><div class="line">D <span class="comment">// userNames[4]</span></div></pre></td></tr></table></figure></p>
<h2 id="let-cannot-be-redeclared"><a href="#let-cannot-be-redeclared" class="headerlink" title="let cannot be redeclared"></a>let cannot be redeclared</h2><p><code>let</code>으로 정의된 변수는 같은 블록에서 재할당될 수는 있지만 재정의는 될 수 없다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6 code</span></div><div class="line"><span class="keyword">let</span> a = <span class="string">'hello'</span>;</div><div class="line">a = <span class="string">'world'</span> <span class="comment">// available</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="string">'hello'</span>;</div><div class="line"><span class="keyword">let</span> a = <span class="string">'world'</span>; <span class="comment">// false -&gt; TypeError : Identifier ‘a’ has already been declared</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> flashMessage = <span class="string">'hello'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadFiles</span>(<span class="params">userNames</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> flashMessage = <span class="string">'world'</span>; <span class="comment">// available</span></div><div class="line">    <span class="keyword">return</span> flashMessage;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="const-declaration"><a href="#const-declaration" class="headerlink" title="const - declaration"></a>const - declaration</h2><p>const 키워드는 상수라고 불리는 읽기 전용 변수를 생성하는 키워드이다. 한 번 할당되면, 상수는 새로운 값으로 할당될 수 없다. 명시적으로 변경을 시도해도 바뀌지 않는다. const 로 정의된 변수는 초기에 정의할 때, 반드시 값을 할당해줘야 한다. 그렇지 않으면 <code>Syntax Error</code>가 발생하게 된다. const 로 정의된 변수는 <code>let</code>과 마찬가지로, 가장 가까운 블록에 scope이 지정된다.</p>
<p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="external">Github Respository</a>에서 확인하실 수 있습니다.</p>
<p><em>chapter 1. end</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-1-let-amp-const&quot;&gt;&lt;a href=&quot;#ES6-1-let-amp-const&quot; class=&quot;headerlink&quot; title=&quot;[
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
</feed>

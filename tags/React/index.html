
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Devlog">
    <title>Tag: React - Devlog</title>
    <meta name="author" content="Jbee">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/feed.xml">
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="blog posted about front end development">
<meta property="og:type" content="blog">
<meta property="og:title" content="Devlog">
<meta property="og:url" content="https://jaeyeophan.github.io/tags/React/index.html">
<meta property="og:site_name" content="Devlog">
<meta property="og:description" content="blog posted about front end development">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Devlog">
<meta name="twitter:description" content="blog posted about front end development">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Devlog</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Search"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/" target="_blank" rel="noopener" title="Google +">
                    
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/profile/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/mailto"
                            title="Mail"
                        >
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/01/02/React-tips-for-beginners/">
                            [번역] React를 본격적으로 하기 전 알면 좋은 6가지
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-02T13:36:04+09:00">
	
		    Jan 02, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/react_special_1.png" alt=""></p>
<h1 id="I-wish-I-knew-these-before-diving-into-React"><a href="#I-wish-I-knew-these-before-diving-into-React" class="headerlink" title="I wish I knew these before diving into React"></a>I wish I knew these before diving into React</h1><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488" target="_blank" rel="external">https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488</a></em></p>
<h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul>
<li>By default, setState triggers a re-render</li>
<li>setState updates the local state asynchronously</li>
<li>Component Lifecycle is important!</li>
<li>Use componentWillReceiveProps</li>
<li>Use React Developer Tools</li>
<li>Use CRA(Create React App)</li>
</ul>
<p><br></p>
<h2 id="1-By-default-setState-triggers-a-re-render"><a href="#1-By-default-setState-triggers-a-re-render" class="headerlink" title="1. By default, setState triggers a re-render"></a>1. By default, setState triggers a re-render</h2><blockquote>
<p>기본적으로 <code>setState</code> 메소드는 해당 컴포넌트의 재렌더링(re-render)을 발생시킨다.</p>
</blockquote>
<p>리액트의 기본 동작은 애플리케이션을 구성하고 있는 컴포넌트에서 발생하는 모든 변경사항에 대해서 다시 렌더링 하는 것이고 대부분의 경우 이 이러한 기본 동작에 맡겨도 정상적으로 동작합니다. 하지만 불필요한 re-render는 컴포넌트의 라이프 사이클 압장에서 봤을 때, Best practice일 수 없습니다.</p>
<p>각각의 컴포넌트들은 <code>shouldComponentUpdate</code>라는 메소드를 가지고 있고 이것은 <code>state</code>가 변경되거나 부모 컴포넌트로부터 새로운 <code>props</code>를 전달받을 때 실행됩니다. React는 이 메소드(<code>shouldComponentUpdate</code>)의 반환 값에 따라서 re-render를 할지에 대한 여부를 결정하게 됩니다.</p>
<p>기본적으로 <code>shouldComponentUpdate</code> 메소드는 <code>true</code>를 반환합니다. 하지만 React 개발자는 re-render를 원하지 않는 경우에, 이 return value를 <code>false</code>로 오버라이드 할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">    <span class="keyword">const</span> vitalPropsChange = <span class="keyword">this</span>.props.bar !== nextProps.bar;</div><div class="line">    <span class="keyword">const</span> vitalStateChange = <span class="keyword">this</span>.state.foo !== nextState.foo;    </div><div class="line">    <span class="keyword">return</span> vitalPropsChange || vitalStateChange;</div><div class="line">&#125;</div><div class="line"><span class="comment">// React will not re-render the component unless vitalPropsChange</span></div><div class="line"><span class="comment">// or vitalStateChange is true.</span></div></pre></td></tr></table></figure>
<h3 id="important-notes"><a href="#important-notes" class="headerlink" title="important notes:"></a>important notes:</h3><ol>
<li><code>shouldComponentUpdate</code>를 잘못 설정하거나 이러한 설정을 잊어 버리면 구성 요소가 예상대로 업데이트되지 않아 애플리케이션에 문제가 발생할 수 있습니다.</li>
<li><code>shouldComponentUpdate</code>에서 계산을 실행하는 것은 성능과 노력면에서 비용이 많이들 수 있으므로 그만한 가치가 있는지 확인해야합니다. <a href="https://reactjs.org/docs/perf.html" target="_blank" rel="external">React ‘s Performance Tools</a>를 사용하여 <code>shouldComponentUpdate</code> 사용 전후에 낭비되는 사이클 수를 확인하는 것이 좋습니다. 아주 간단한 사용법이 있습니다.<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Perf.start() </div><div class="line"><span class="comment">// React operations in-between are recorded for analyses.</span></div><div class="line">Perf.stop()</div><div class="line">Perf.printWasted()</div></pre></td></tr></table></figure>
</li>
</ol>
<p><br></p>
<h2 id="2-setState-updates-the-local-state-asynchronously"><a href="#2-setState-updates-the-local-state-asynchronously" class="headerlink" title="2. setState updates the local state asynchronously"></a>2. setState updates the local state asynchronously</h2><blockquote>
<p><code>setState</code> 메소드는 <strong>비동기</strong>로 state를 업데이트 한다.</p>
</blockquote>
<p><code>setState</code>메소드는 즉시 실행되는, 동기적으로 실행되는 것이 아니라 하나의 <strong>요청</strong>이라고 생각해야 합니다. 즉, <code>setState</code>를 통해 상태를 변경하더라도 해당 메소드가 실행된 직후에 변경된 상태가 적용되는 것이 아닙니다.</p>
<p><code>setState</code>를 호출한 직후에 <code>this.state</code>에 접근하는 것은 흔한 실수 입니다. 일반적으로, <code>setState</code> 메소드 내에서 <code>this.state</code>를 사용하는 것은 신뢰할 수 없습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this.state.value is initially 0</span></div><div class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line"><span class="comment">// this.state.value is 1 instead of 3</span></div></pre></td></tr></table></figure></p>
<p>만약 이전의 상태에 기반하여 상태를 변경해야 한다면 가장 좋은 방법 중 하나는 <code>updater</code> 함수를 사용하는 것입니다. <code>updater</code>함수를 <code>setState</code> 메소드의 첫번째 인자로 넘기는 방식으로 사용할 수 있습니다. ( <code>setState(updater, [callback])</code> ) 예제 코드입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;<span class="attr">value</span>: prevState.value + <span class="number">1</span>&#125;));</div></pre></td></tr></table></figure></p>
<p>여기서 <code>[callback]</code>은 optional argument로 <code>setState</code>의 실행이 완료된 후 실행되며 해당 <code>callback</code>이 실행된 후에 해당 컴포넌트의 re-render가 이루어집니다. <code>updater</code>에 대한 보다 자세한 내용은 다음 <a href="https://reactjs.org/docs/react-component.html#setstate" target="_blank" rel="external">링크</a>를 참고하세요.</p>
<p><br></p>
<h2 id="3-Component-Lifecycle-is-important"><a href="#3-Component-Lifecycle-is-important" class="headerlink" title="3. Component Lifecycle is important!"></a>3. Component Lifecycle is important!</h2><blockquote>
<p>컴포넌트의 라이프 사이클이 중요하다!</p>
</blockquote>
<p>React를 이해하는데 있어서 가장 첫번째로 이해해야 하는 부분이 바로 <strong>Component life cycle</strong>입니다. 각각의 React 컴포넌트는 component의 life cycle 안에서 특정 시간에 호출할 수 있는 메소드들을 내장하고 있습니다. 이 컴포넌트 내장 메소드들을 올바르게 사용하기 위해서는 해당 메소드들이 실행되는 순서를 이해해야만 합니다. 이 라이프 사이클을 세 부분으로 나눌 수 있습니다.</p>
<h3 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h3><p>React 컴포넌트의 인스턴스가 생성되고 DOM에 삽입되는 과정의 life cycle 입니다.</p>
<ol>
<li>constructor</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ol>
<h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p><code>prop</code> 또는 <code>state</code>의 변경으로 해당 컴포넌트가 re-render 되는 경우의 life cycle 입니다.</p>
<h4 id="Props-Change"><a href="#Props-Change" class="headerlink" title="Props Change"></a>Props Change</h4><ol>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h4 id="State-Change"><a href="#State-Change" class="headerlink" title="State Change"></a>State Change</h4><ol>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h3 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h3><ul>
<li>componentWillUnmount</li>
</ul>
<h3 id="Life-Cycle과-관련된-좋은-Article"><a href="#Life-Cycle과-관련된-좋은-Article" class="headerlink" title="Life Cycle과 관련된 좋은 Article"></a>Life Cycle과 관련된 좋은 Article</h3><ul>
<li>React Lifecycle Methods - how and when to use them<ul>
<li><a href="https://jaeyeophan.github.io/2018/01/01/React-4-Component-Life-Cycle/">번역 링크</a></li>
<li><a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="external">원본 링크</a></li>
</ul>
</li>
<li><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="external">React Official Document</a></li>
</ul>
<p><br></p>
<h2 id="4-Use-componentWillReceiveProps"><a href="#4-Use-componentWillReceiveProps" class="headerlink" title="4. Use componentWillReceiveProps"></a>4. Use componentWillReceiveProps</h2><blockquote>
<p><code>componentWillReceiveProps</code> 메소드를 사용해라.</p>
</blockquote>
<p>만약 <code>props</code>의 변경에 따라서 상태를 변경해야 한다면, 이 <code>componentWillReceiveProps</code> 메소드가 필요합니다. <code>this.props</code>와 <code>nextProps</code>를 비교해서 중요한 변화(significant change)가 있다면 해당 메소드를 실행합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps(nextProps) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.foo !== nextProps.foo) &#123;</div><div class="line">    <span class="keyword">this</span>.whenFooChanges();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.porps.bar !== nextProps.bar) &#123;</div><div class="line">    <span class="keyword">this</span>.whenBarChanges();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Two-important-notes"><a href="#Two-important-notes" class="headerlink" title="Two important notes:"></a>Two important notes:</h3><ol>
<li><code>props</code>가 변경되지 않아도 <code>componentWillReceiveProps</code>는 실행하기 때문에 <code>this.props</code>와 <code>nextProps</code>를 비교하는 것이 중요합니다.</li>
<li><code>componentWillReceiveProps</code>은 해당 컴포넌트가 <strong>mounted</strong> 되기 전에 실행되어 새로운 <code>props</code>를 받습니다. 이것은 React가 mount 중에는 초기 props에 대해 <code>componentWillReceiveProps</code>를 호출하지 않는다는 것을 의미합니다.</li>
</ol>
<h3 id="추가-내용"><a href="#추가-내용" class="headerlink" title="추가 내용"></a>추가 내용</h3><p>React version 16에서 <code>componentWillReceiveProps</code>를 사용하여 상태를 변경할 때는 <strong>동기적으로</strong> 업데이트 해야 합니다.(dispatch request 또는 <code>setTimeout</code>과 같은 비동기적 요청은 해당 메소드에서 처리하면 안 됩니다.)<br><strong>React Fiber</strong> 를 사용하면 라이프 사이클이 진행되기 전에 <code>componentWill[*]</code> 메서드가 여러 번 호출 될 수 있습니다. <code>props</code>이 변경될 때 상태를 비동기적으로 업데이트하려면 <code>componentDidUpdate</code>를 사용해야 합니다.</p>
<p><br></p>
<h2 id="5-Use-React-Developer-Tools"><a href="#5-Use-React-Developer-Tools" class="headerlink" title="5. Use React Developer Tools"></a>5. Use React Developer Tools</h2><blockquote>
<p>각종 React 개발자 도구를 사용해라.</p>
</blockquote>
<p>React Developer Tools를 사용하면 애플리케이션을 구성하고 있는 React 컴포넌트의 계층, 컴포넌트의 <code>props</code> 및 <code>state</code>를 검사 할 수 있습니다. React는 모두 컴포넌트에 관한 것이기 때문에 많은 경우, 매우 유용합니다. 브라우저 확장 프로그램 (<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="external">Chrome용</a> 및 <a href="https://addons.mozilla.org/ko/firefox/addon/react-devtools/" target="_blank" rel="external">Firefox 용</a>)과 <a href="https://github.com/facebook/react-devtools/tree/master/packages/react-devtools" target="_blank" rel="external">독립 실행 형 앱</a>으로 존재합니다.</p>
<p><br></p>
<h2 id="6-Use-CRA-Create-React-App"><a href="#6-Use-CRA-Create-React-App" class="headerlink" title="6. Use CRA(Create React App)"></a>6. Use CRA(Create React App)</h2><blockquote>
<p>CRA를 사용해라.</p>
</blockquote>
<p>Facebook의 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">Create React App</a>을 사용하면 빌드 구성없이 React 앱을 만들 수 있습니다. CRA는 사용하기가 매우 쉽고 잘 갖춰진 documentation을 가지고 있습니다. Node&gt; = 6 만 있으면 되며 macOS, Windows 및 Linux에서 작동합니다. 개발 생산성을 높여주는 HRM도 해당 scaffolding 모듈에서 지원하고 있습니다. (개인적으로는 글로벌로 설치해도 아쉽지 않은 녀석입니다!)</p>
<p><br></p>
<h3 id="역자-덧붙임"><a href="#역자-덧붙임" class="headerlink" title="역자 덧붙임"></a>역자 덧붙임</h3><p>좋은 참고자료를 첨부합니다.</p>
<ul>
<li><a href="https://github.com/reactkr/learn-react-in-korean" target="_blank" rel="external">한국어로 배우는 리액트</a></li>
<li><a href="https://github.com/Microsoft/TypeScript-React-Starter" target="_blank" rel="external">TypeScript-React-Stater</a></li>
<li><a href="https://github.com/chantastic/reactpatterns.com" target="_blank" rel="external">react-patterns (영어)</a></li>
</ul>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>일부 의역이 들어갔으며 오역이 존재할 수 있습니다. 해당 사항에 대해서는 댓글로 피드백 주시면 감사하겠습니다. 더 좋은 포스팅으로 뵙겠습니다! 감사합니다.</p>
<p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488" target="_blank" rel="external">https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488</a></em></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/01/02/React-tips-for-beginners/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2018/01/02/React-tips-for-beginners/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/01/01/React-4-Component-Life-Cycle/">
                            [React] 4. Component Life Cycle
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-01T17:08:03+09:00">
	
		    Jan 01, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/react_logo.png" alt=""></p>
<h1 id="React-Lifecycle-Methods-how-and-when-to-use-them"><a href="#React-Lifecycle-Methods-how-and-when-to-use-them" class="headerlink" title="React Lifecycle Methods - how and when to use them"></a>React Lifecycle Methods - how and when to use them</h1><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="external">https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1</a></em></p>
<h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul>
<li>Intro</li>
<li>React Component Life Cycle<ul>
<li>componentWillMount</li>
<li>componentDidMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
</li>
</ul>
<p><br></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><img src="/images/react_component_life_cycle.png" alt=""></p>
<p>위 다이어그램은 React 컴포넌트의 출생(pre-mounting)과 사망 (unmounting)에서의 Life Cycle입니다. React의 장점은 복잡한 UI를 작은 크기로 나누는 것입니다. 따라서 앱을 각각의 컴포넌트 단위로 분류 할 수 있을 뿐만 아니라 각 컴포넌트에 대해 customize 할 수 있습니다.</p>
<p>React Component의 라이프 사이클 메소드를 통해 UI의 각 컴포넌트가 <strong>렌더링(rendering)</strong>, <strong>업데이트(update)</strong>, <strong>재렌더링(re-rendering)</strong> 될 때를 고려할 수 있으며 <strong>완전히 사라질 때(unmount)</strong> 일어나는 일을 제어 할 수 있습니다.</p>
<p><br></p>
<h2 id="React-Component-Life-Cycle"><a href="#React-Component-Life-Cycle" class="headerlink" title="React Component Life Cycle"></a>React Component Life Cycle</h2><p>React 컴포넌트의 생명 주기를 부분적으로 나누어 간단히 살펴보면 다음과 같습니다.</p>
<h3 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h3><p>React 컴포넌트의 인스턴스가 생성되고 DOM에 삽입되는 과정의 life cycle 입니다.</p>
<ol>
<li>constructor</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ol>
<h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p><code>prop</code> 또는 <code>state</code>의 변경으로 해당 컴포넌트가 re-render 되는 경우의 life cycle 입니다.</p>
<h4 id="Props-Change"><a href="#Props-Change" class="headerlink" title="Props Change"></a>Props Change</h4><ol>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h4 id="State-Change"><a href="#State-Change" class="headerlink" title="State Change"></a>State Change</h4><ol>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h3 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h3><ul>
<li>componentWillUnmount</li>
</ul>
<p>이제 각각에 대해서 살펴봅시다.</p>
<p><br></p>
<h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a><code>componentWillMount</code></h2><p>개발자가 정의한 컴포넌트는 눈 깜짝할 사이에 화면에 그려집니다. 이 순간 무엇을 할 수 있을까요? 그에 대한 대답은 사실 할 수 있는 것이 별로 없습니다. <code>componentWillMount</code> 메소드는 딱히 쓸모가 없습니다.</p>
<p><code>componentWillMount</code>에서는 아직 생성된 컴포넌트가 없으므로 DOM 관련 작업을 수행 할 수 없습니다. 또한 컴포넌트의 기본 구성(<code>props</code> or <code>state</code>)을 설정하는 생성자(constructor)가 호출된 이후에는 아무 것도 변경되지 않았습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sidebar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  tooltipsEnabled = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">analyticsOpen</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">requirementsOpen</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">brandInfoOpen</span>: <span class="literal">false</span>,</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>생성자가 호출되고 나면 그 상태가 바로 컴포넌트의 초기 상태가 됩니다. 추가적인 라이프 사이클 메소드를 복잡하게 사용하지 않고도 거의 모든 것이 컴포넌트 코드의 나머지 부분에서 처리되어야 합니다. 그 중에서도 예외가 있다면 초기에만 수행할 수있는 설정 즉, 외부 API에 연결하는 작업이 있을 것입니다. 예를 들어, 앱에 Firebase를 사용한다면, 앱이 처음 설치 될 때 설정을 가져와야합니다. 그러나 여기서 핵심은 이러한 작업은 앱의 최상위 컴포넌트 (루트 컴포넌트)에서 수행되어야 한다는 것입니다.</p>
<p>이는 컴포넌트의 99 %가 <code>componentWillMount</code>를 사용하지 않아야 함을 의미합니다. <code>componentWillMount</code>를 사용하여 컴포넌트에 대한 데이터를 로드하기 위해 AJAX 호출을 시작하는 사람들을 볼 수 있습니다. 하지만 이 글을 읽는 당신은 이러지 않았으면 좋겠습니다. 바로 다음 section인 두번째 section에서 이 부분에 대해 이야기하겠습니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례"><a href="#이-메소드의-가장-일반적인-사용-사례" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>루트 컴포넌트에서 App과 관련된 외부 API를 설정할 떄.</li>
<li>setState 호출(?) : <code>setState</code>도 호출하지 말고 constructor에서 설정한 <code>this.state</code>를 사용하세요.</li>
</ul>
<p><br></p>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a><code>componentDidMount</code></h2><p>이제 컴포넌트가 mount되고 사용할 준비가 되었습니다.</p>
<p><code>componentDidMount</code>는 가지고 놀 컴포넌트가 없을 때 할 수 없었던 것들을 모두 할 수 있는 메소드입니다. 몇 가지 예를 들면 다음과 같습니다.</p>
<ul>
<li><code>&lt;canvas&gt;</code> 에 렌더링을 수행한다.</li>
<li>요소 컬렉션에서 <a href="https://masonry.desandro.com/" target="_blank" rel="external">Masonry</a> 그리드 레이아웃을 초기화한다.</li>
<li>Event listener를 추가한다.</li>
</ul>
<p>기본적으로 여기에서는 DOM에 대한 접근이 필요한 모든 설정을 수행하고 필요한 데이터를 가져오기 시작합니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-1"><a href="#이-메소드의-가장-일반적인-사용-사례-1" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>Ajax 호출을 시작하여 컴포넌트에서 사용해야 하는 데이터를 로드합니다.</li>
<li>setState를 호출할 수 있습니다.</li>
</ul>
<p><br></p>
<h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><code>componentWillReceiveProps</code></h2><p>컴포넌트가 정상적으로 잘 동작하고 있었는데 새로운 <code>props</code>가 전달되었습니다. 아마 상위 컴포넌트에서 <code>componentDidMount</code>에 의해 로드된 데이터 중 일부가 내려왔을 것입니다.</p>
<p>새로운 <code>props</code>로 어떠한 작업을 수행하기 전 이 새로운 <code>props</code>를 인자로 하여 <code>componentWillReceiveProps</code>가 호출됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps(nextProps) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">parseInt</span>(nextProps.id, <span class="number">10</span>) !== <span class="built_in">parseInt</span>(<span class="keyword">this</span>.props.id, <span class="number">10</span>)) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">postsLoaded</span>: <span class="literal">false</span> &#125;);</div><div class="line">    <span class="keyword">this</span>.contentLoaded = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>우리는 이 메소드 안에서 <code>nextProps</code>를 통해 다음의 <code>props</code>(새로운 <code>props</code>)에 접근할 수 있고 <code>this.props</code>를 통해 현재의 <code>props</code>에 접근할 수 있습니다.</p>
<p>이 메소드에서 우리 해야하는 것은 다음과 같습니다.</p>
<ol>
<li>props가 바뀌었는지 확인합니다. 가끔 <code>props</code>가 변경되지 않은 경우에도 호출됩니다.</li>
<li>만약 <code>props</code>가 변경되었다면 그에 따라 로직을 구성해야 한다.</li>
</ol>
<p>새로운 <code>props</code>를 받았을 때, 다음과 같이 처리합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps(nextProps) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.percent !== nextProps.percent) &#123;</div><div class="line">    <span class="keyword">this</span>.setUpPercent(nextProps.percent);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>하나 더 주의해야 할 것은 <code>componentWillReceiveProps</code>는 초기 렌더링시 호출되지 않습니다. 코드 상으로는 컴포넌트가 <code>props</code>를 받는다는 것을 의미하지만 비교할 기존의 <code>props</code>가 없으므로 로직에 포함되지 않습니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-2"><a href="#이-메소드의-가장-일반적인-사용-사례-2" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>해당 컴포넌트의 상태 변경에 영향을 끼지는 <code>props</code>의 변경에 따라 로직을 구성합니다.</li>
<li>setState를 호출할 수 있습니다.</li>
</ul>
<p><br></p>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a><code>shouldComponentUpdate</code></h2><p>컴포넌트가 불안정한(?) 상태입니다. 이 메소드가 호출되었다는 것은 현재 컴포넌트의 상태와 view에 그려진 내용, 상태가 다르다는 것을 의미하기 때문입니다.</p>
<p>우리에게는 새로운 <code>props</code>가 있습니다. 전형적인 React 신조에 따르면 컴포넌트가 새로운 <code>props</code>나 새로운 <code>state</code>를 받으면 업데이트해야 한다고 말합니다.</p>
<p><code>shouldComponentUpdate</code> 메소드는 <code>nextProps</code>를 첫 번째 인수로 사용하고 <code>nextState</code>는 두 번째 인수로 사용합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.engagement !== nextProps.engagement</div><div class="line">    || nextState.input !== <span class="keyword">this</span>.state.input;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>shouldComponentUpdate</code>는 항상 <code>boolean</code>을 반환해야 합니다. 이것은 “해당 컴포넌트를 다시 렌더링(re-render)해야 하나요?”라는 질문에 대한 답이 됩니다. 해당 컴포넌트를 특별히 override하지 않는 이상 이 메소드는 기본적으로 <code>true</code>를 반환합니다.</p>
<p>하지만 불필요한 재렌더링(re-render)를 방지하기 위해서는 <code>shouldComponentUpdate</code>를 override 할 수 있습니다. 자세한 내용은 다음 <a href="https://engineering.musefind.com/how-to-benchmark-react-components-the-quick-and-dirty-guide-f595baf1014c" target="_blank" rel="external">링크</a>를 참고해주세요. (이 링크에서는 많은 필드가 있는 테이블에서 테이블이 다시 렌더링 될 때 각 필드가 다시 렌더링되어 작업속도가 느려지게 된다는 것을 보여주고 있습니다.)</p>
<p><code>shouldComponentupdate</code>를 사용하면 변화에 신경써야 하는 <code>props</code>의 변경에 대해서만 update를 진행할 수 있습니다. 하지만 이에 대한 설정을 잊으면 React 컴포넌트가 제대로 동작하지 않기 때문에 명심해야 합니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-3"><a href="#이-메소드의-가장-일반적인-사용-사례-3" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>해당 컴포넌트의 re-render를 제어할 때 사용합니다.</li>
<li>setState를 호출할 수 없습니다.</li>
</ul>
<p><br></p>
<h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a><code>componentWillUpdate</code></h2><p>방금 전까지 컴포넌트를 update하는데 집중을 했는데요, 이 메소드에서는 update가 발생하기 전 어떠한 작업이 필요한 경우 해당 메소드 안에서 해결할 수 있습니다.<br>이 메소드는 메소드 내에서 <code>this.setState</code>를 호출할 수 없다는 점을 제외하면 기본적으로 <code>componentWillReceiveProps</code>와 동일합니다.</p>
<p>이미 <code>shouldComponentUpdate</code>를 사용 중인데 또 <code>props</code>가 변경될 때 작업이 필요한 경우 이 메소드가 적절하겠지만 추가적인 유용성은 많이 주지는 못할 것입니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-4"><a href="#이-메소드의-가장-일반적인-사용-사례-4" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li><code>shouldComponentUpdate</code>가 이미 사용되고 있는 컴포넌트에서 <code>componentWillReceiveProps</code> 대신 사용됩니다. 단 해당 메소드 내에서는 이전 <code>props</code>에 접근할 수 없습니다.</li>
<li>setState를 호출할 수 없습니다.</li>
</ul>
<p><br></p>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a><code>componentDidUpdate</code></h2><p>이 메소드에서는 <code>componentDidMount</code>에서 했던 것과 동일한 작업을 수행할 수 있습니다. (예를 들면, 레이아웃을 다시 설정한다던가 canvas를 그린다던가) </p>
<p><code>shouldComponentUpdate</code>가 호출된 다음, <code>render</code>가 호출된 다음 호출되는 메소드입니다. 하지만 아쉽게도 이 메소드 내에서는 어떠한 이유로 update가 이루어졌는지 알 수 없습니다. 그렇기 때문에 변경된 데이터에 대해 DOM조작을 다시 해줘야하는 경우가 있다면 이 메소드에서 수행해줄 수 있습니다.</p>
<p><code>componentWillReceiveProps</code>에서도 충분히 해줄 수 있는 작업들이지만 불필요한 re-render를 방지하기 위해 DOM과 관련된 작업들을 주로 수행합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">componentDidUpdate() &#123;</div><div class="line">  <span class="keyword">this</span>.createGrid();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="이-메소드의-가장-일반적인-사용-사례-5"><a href="#이-메소드의-가장-일반적인-사용-사례-5" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li><code>prop</code> 또는 <code>state</code>에 따라서 DOM을 업데이트 합니다.</li>
<li>setState를 호출할 수 있습니다.</li>
</ul>
<p><br></p>
<h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a><code>componentWillUnmount</code></h2><p>컴포넌트가 unmount 되기 전 호출되는 메소드로 마지막으로 수행해야하는 작업이 있다면 이 메소드에서 수행해줄 수 있습니다. 여기서는 네트워크 요청을 취소하거나 컴포넌트와 관련된 모든 이벤트 리스터를 제거할 수 있습니다. 기본적으로 해당 컴포넌트와 관련있는 작업들만 수행합니다.</p>
<h4 id="이-메소드의-가장-일반적인-사용-사례-6"><a href="#이-메소드의-가장-일반적인-사용-사례-6" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul>
<li>컴포넌트와 관련된 것들을 제거하는 메소드입니다.</li>
<li>setState를 호출할 수 없습니다.</li>
</ul>
<p><br></p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>이상적인 애플리케이션에서는 life cycle 에 접근할 필요가 없습니다. 렌더링과 관련된 거의 모든 이슈는 <code>state</code>와 <code>props</code>만을 통해 제어될 수 있습니다. 하지만 몇몇의 경우, 컴포넌트의 업데이트 방법과 그 순간 순간에 대해 좀 더 명확히 제어할 필요가 있습니다. 때문에 life cycle에 접근하여 컴포넌트를 제어하는 것이 필요하다면 이상적인 동작에 영향이 끼치지 않도록 조심스럽게 사용해야 합니다.</p>
<p><br></p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>일부 의역이 들어갔으며 오역이 존재할 수 있습니다. 해당 사항에 대해서는 댓글로 피드백 주시면 감사하겠습니다. 더 좋은 포스팅으로 뵙겠습니다! 감사합니다.</p>
<p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="external">https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1</a></em></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/01/01/React-4-Component-Life-Cycle/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2018/01/01/React-4-Component-Life-Cycle/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/08/30/React-router-1-react-router-basic/">
                            [React-router] 1. react-router basic
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-08-30T18:03:18+09:00">
	
		    Aug 30, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/react_router_logo.png" alt=""></p>
<h1 id="React-router-1-react-router-basic"><a href="#React-router-1-react-router-basic" class="headerlink" title="[React-router] 1. react-router basic"></a>[React-router] 1. react-router basic</h1><p><em><a href="https://github.com/ReactTraining/react-router" target="_blank" rel="external">react-router</a>라이브러리에 대해서 살펴봅니다 :) 포스팅 시점의 react-router의 버전은 <code>v4.1.1</code>입니다.</em></p>
<h2 id="Why-react-router"><a href="#Why-react-router" class="headerlink" title="Why react-router?"></a>Why react-router?</h2><p>React는 SPA(Single Page Application)를 위한 View 라이브러리입니다.즉 여러 개의 <code>html</code>파일로 구성된, 여러 개의 페이지의 웹 애플리케이션이 아닌 단일 페이지로 구성된 웹 애플리케이션을 위한 라이브러리인 것입니다. 하나의 url로 웹 애플리케이션이 실행된다고 볼 수 있습니다. 하지만 이렇게 되면 특정 url에 따른 다른 페이지를 보여줄 수가 없습니다. 이로 인해 여러 가지 아쉬운 점들이 생겼습니다. 물론 html의 <code>anchor</code> 태그(<code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code>)를 사용하면 되지만, 이 태그는 모든 페이지를 모두 reloading합니다. <code>react-router</code>를 사용하게 되면 지정한 부분에 대해서만 reloading시킬 수 있습니다 :D</p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ yarn add react-router-dom</div><div class="line"><span class="comment"># or</span></div><div class="line">$ npm install react-router-dom</div></pre></td></tr></table></figure>
<p>React project에서 해당 npm을 추가합니다.</p>
<p><br></p>
<h2 id="Sample-code-directory’s-structure"><a href="#Sample-code-directory’s-structure" class="headerlink" title="Sample code directory’s structure"></a>Sample code directory’s structure</h2><p>이번 포스팅에서 사용되는 프로젝트의 구조는 다음과 같습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">src</div><div class="line">--containers</div><div class="line">----App.js</div><div class="line">--components</div><div class="line">----Navigators.js</div><div class="line">----Home.js</div><div class="line">----Comp1.js</div><div class="line">----Comp2.js</div><div class="line">----Comp3.js</div><div class="line">--index.js</div></pre></td></tr></table></figure></p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><figure class="highlight js"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Switch&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</div></pre></td></tr></table></figure>
<p><code>BrowserRouter</code>, <code>Route</code>, <code>Switch</code> 세 가지 모듈을 <code>react-router-dom</code>으로부터 불러옵니다.<br>사용하는 방식은 다음과 같습니다.</p>
<figure class="highlight js"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></div><div class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">Navigators</span>/&gt;</span></div><div class="line">                    //[components according to path]</div><div class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</div></pre></td></tr></table></figure>
<p><code>Router</code>(<code>BrowserRouter</code>) 태그로 rendering하고자 하는 태그들을 감싸줍니다. <code>Router</code>태그 child로는 하나의 자식, 즉 하나의 태그만이 올 수 있기 때문에 <code>div</code>태그로 하위 태그들을 감싸줍니다. 위 예제는 <code>Navigators</code>에 있는 버튼들로 하위 태그들을 렌더링하기 위한 구조입니다. <code>Router</code>태그 안쪽의 구성을 살펴보겠습니다.</p>
<figure class="highlight js"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import components</span></div><div class="line"><span class="keyword">import</span> Navigators <span class="keyword">from</span> <span class="string">'../components/Navigators'</span>;</div><div class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../components/Home'</span>;</div><div class="line"><span class="keyword">import</span> Comp1 <span class="keyword">from</span> <span class="string">'../components/Comp1'</span></div><div class="line"><span class="keyword">import</span> Comp2 <span class="keyword">from</span> <span class="string">'../components/Comp2'</span></div><div class="line"><span class="keyword">import</span> Comp3 <span class="keyword">from</span> <span class="string">'../components/Comp3'</span></div><div class="line"><span class="comment">//...</span></div><div class="line">&lt;Router&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">        &lt;Navigators/&gt;</div><div class="line">        &lt;Switch&gt;</div><div class="line">            &lt;Route exact path="/" component=&#123;Home&#125;/&gt;</div><div class="line">            &lt;Route path="/comp1" component=&#123;Comp1&#125;/&gt;</div><div class="line">            &lt;Route path="/comp2" component=&#123;Comp2&#125;/&gt;</div><div class="line">            &lt;Route path="/comp3" component=&#123;Comp3&#125;/&gt;</div><div class="line">        &lt;/Switch&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure>
<p>이제 <code>Switch</code>태그와 <code>Route</code>태그들을 사용해줍니다. 변경될 부분에 대해서 <code>Switch</code>태그로 감싸준 다음, 지정해준 <code>path</code>에 따라서 렌더링될 component를 지정해줍니다.</p>
<p><code>exact</code>라는 키워드가 <code>/</code> path에 대해서만 지정이 된 것을 확인할 수 있는데요, 이 <code>/</code>는 각각의 <code>/comp1</code>, <code>/comp2</code>, <code>/comp3</code> path에도 포함되는 path입니다. 그렇기 때문에 중복으로 렌더링이 되는데요, <code>exact</code>는 “<code>/</code>일 경우에만 해당 component를 렌더링해!” 라는 의미의 키워드입니다. 렌더링 해줄 컴포넌트는 이렇게만 작성해주면 됩니다!</p>
<p>이제 <code>Navigators</code> 컴포넌트를 살펴봅시다.</p>
<figure class="highlight js"><figcaption><span>Navigators.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;NavLink&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</div></pre></td></tr></table></figure>
<p>이 컴포넌트에서는 <code>NavLink</code>라는 녀석을 불러와줍니다.</p>
<figure class="highlight js"><figcaption><span>Navigators.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Navigators = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"Navigators"</span>&gt;</span></span></div><div class="line">            <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">exact</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span> Home <span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">"/comp1"</span>&gt;</span> One <span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">"/comp2"</span>&gt;</span> Two <span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">"/comp3"</span>&gt;</span> Three <span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">&#125;;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Navigators;</div></pre></td></tr></table></figure>
<p>그리고 <code>NavLink</code> 태그를 사용해서 <code>to</code>를 통해 <code>App.js</code>에서 <code>path</code>로 지정해준 값들과 매핑시켜줍니다. 정말 간단합니다.</p>
<h3 id="NoMatch"><a href="#NoMatch" class="headerlink" title="NoMatch"></a>NoMatch</h3><p>사용자가 어쩌다가 잘못된 url로 접속했을 시, <code>404 Not Found</code> 페이지가 나타나는데요, 이러한 문제를 방지하기 위해 잘못된 접근을 처리해줄 수 있는 Route를 추가해줍니다. 우선 잘못된 접근에 대해 보여줄 컴포넌트를 만듭니다.<br><figure class="highlight js"><figcaption><span>NoMatch.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> NoMatch = <span class="function">(<span class="params">&#123;location&#125;</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>No match for &#123;location.pathname&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">    );</div><div class="line">&#125;;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> NoMatch;</div></pre></td></tr></table></figure></p>
<p>다른 컴포넌트와 다른 건 없습니다. 그리고 <code>App.js</code>에서 <code>Switch</code> 하위에 <code>Route</code>를 추가해주면 됩니다.</p>
<figure class="highlight js"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> NoMatch <span class="keyword">from</span> <span class="string">'../components/NoMatch'</span>;</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">//[Other Route tags]</span></div><div class="line">&lt;Route component=&#123;NoMatch&#125;/&gt;</div></pre></td></tr></table></figure>
<p>다른 <code>Route</code>태그들과는 달리 <code>path</code>가 지정되어 있지 않습니다. 이 <code>NoMatch</code>에 해당하는 <code>Route</code>태그는 가장 마지막에 작성해주어야 합니다 :)</p>
<h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p><code>react-router</code>라이브러리는 이 포스팅에서 소개해준 기능외에 <code>Server-Rendering</code>, <code>Code-Splitting</code>, <code>Testing</code> 등 다양한 기능을 제공하고 있는 유용한 라이브러리 입니다 :) 얼른 공식 React에 포함되었으면 좋겠네요!</p>
<p>!<code>React</code>와 관련된 포스팅은 <a href="https://github.com/JaeYeopHan/react_tutorial_with_docs" target="_blank" rel="external">Github Repository</a>에서 받아볼 수 있으며 <code>watch</code> 또는 <code>star</code>로 피드를 받아보실 수 있습니다.</p>
<h4 id="Reference-gt"><a href="#Reference-gt" class="headerlink" title="Reference&gt;"></a>Reference&gt;</h4><p><a href="https://reacttraining.com/react-router/web/example/basic" target="_blank" rel="external">react-router docs</a></p>
<p><em>1. end</em></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/08/30/React-router-1-react-router-basic/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/08/30/React-router-1-react-router-basic/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/06/13/React-3-Props-and-State-in-Component/">
                            [React] 3. Props and State in Component
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-06-13T11:23:14+09:00">
	
		    Jun 13, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/react_logo.png" alt=""></p>
<h1 id="React-3-Props-and-State-in-Component"><a href="#React-3-Props-and-State-in-Component" class="headerlink" title="[React] 3. Props and State in Component"></a>[React] 3. Props and State in Component</h1><p>React Component에는 <code>props</code>라는 것이 존재합니다.</p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p><code>Props</code>은 컴포넌트가 가지고 있는 속성으로 컴포넌트 내부에서는 <code>this.props.[xxx]</code>와 같은 형식으로 접근할 수 있는 것을 말합니다. <code>Props</code>은 외부에서 컴포넌트로 전달하는 값이기 때문에 컴포넌트 내부에서 전달받은 <code>props</code>을 변경해서는 안됩니다. 즉 <code>Props</code>은 immutable한 속성을 갖고 있습니다.</p>
<h3 id="Use-Props"><a href="#Use-Props" class="headerlink" title="Use Props"></a>Use Props</h3><p>함수로 작성된 Component의 경우와 class 문법으로 작성된 Component의 경우, 두 가지에 대해서 props를 살펴봅니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">"Jbee"</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('root')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>Component 외부(해당 Component를 사용하는 Component 또는 render 메소드)에서 name이라는 속성을 props라는 객체를 통해 전달할 수 있습니다. 함수로 작성된 Component에서는 파라미터를 통해 <code>props</code>를 전달받아 이를 내부에서 사용할 수 있습니다. ES6의 destructuring 문법을 사용하면 다음과 같이 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">&#123;name&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('root')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>class 문법을 사용하여 Component를 정의하는 경우에는 <code>constructor</code>를 통해 props를 받아 사용할 수 있습니다.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class App extends Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    return &#123;</div><div class="line">      &lt;div&gt;Hello! &#123;this.props.name&#125;&lt;/div&gt;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">ReactDOM.render(</div><div class="line">  &lt;App name="Jbee"/&gt;,</div><div class="line">  document.getElementById('root')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p><code>constructor(props)</code>내부에 <code>super(props)</code>이 부분이 보이시나요? 이 부분을 빠뜨리면 에러가 발생합니다. ES6 문법에서도 어떠한 클래스를 상속받은 다음 super를 호출해주지 않으면 에러가 발생하는데요, 그와 같은 원리라고 생각하시면 됩니다.</p>
<h3 id="TypeChecking-to-Props"><a href="#TypeChecking-to-Props" class="headerlink" title="TypeChecking to Props"></a>TypeChecking to Props</h3><p>컴포넌트가 외부와의 데이터를 주고 받기 위해 props를 사용했는데요, 이럴 경우 props의 Type을 확인해줘야 하는 필요성이 생깁니다. (물론 애플리케이션의 크기가 작을 때는 props를 주고 받는 것이 한 눈에 보이기 때문에 필수적이지는 않습니다. 하지만 정적 언어를 주로 사용하셨던 분들에게는 적지 않은 찝찝함이 남아있을 거라생각합니다.)</p>
<p>이러한 니즈를 충족시키기 위해 기존에는 React.PropTypes라는 방식을 사용했지만 React v15.5 부터 prop-types라는 npm을 통해 해결합니다. Facebook에서 개발한 <code>Flow</code>를 사용하는 방법도 존재하고, MS의 <code>TypeScript</code>를 사용하는 것도 한 가지 방법이겠습니다 :)</p>
<p>기존의 방식과 npm을 설치하는 방법은 import 구문이 추가되는 것을 제외하고 모두 동일합니다.<br>App Component에서 받는 props에 대한 TypeChecking 예제 코드입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">App.propTypes = &#123;</div><div class="line">  <span class="attr">title</span>: React.PropType.string,</div><div class="line">  <span class="attr">author</span>: React.PropType.string.isRequired</div><div class="line">  onSubmit: React.PropType.func</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>기존의 React에 포함되어 있는 <code>PropType</code>을 사용하는 경우에는 위와 같이 사용하면 됩니다. 필수적으로 요구하는 값에 대해서는 <code>isRequired</code>라는 속성을 더해줍니다. (포스팅을 작성하는 시점에서는 경고 메시지만 로그로 찍힐 뿐 실행에는 문제가 없습니다.)</p>
<p><code>Prop-Types</code> npm 설치는 다음과 같습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install --save prop-types</div><div class="line"><span class="comment"># or</span></div><div class="line">$ yarn add prop-types</div></pre></td></tr></table></figure></p>
<p>그리고 해당 npm을 import하여 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</div><div class="line">App.propTypes = &#123;</div><div class="line">  <span class="attr">title</span>: PropType.string,</div><div class="line">  <span class="attr">author</span>: PropType.string.isRequired,</div><div class="line">  <span class="attr">onSubmit</span>: PropType.func</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Prop-Type</code>npm에서는 다음과 같은 Type들을 제공합니다.<br><code>array</code>, <code>bool</code>,<code>func</code>,<code>number</code>,<code>object</code>,<code>string</code>,<code>symbol</code>,<code>node</code>,<code>element</code><br>또한 다음과 같은 메소드를 제공하여 보다 강력한 TypeChecking을 제공합니다.<br><code>instanceOf()</code>,<code>oneOf([[array]])</code>,<code>oneOfType([[array]])</code>  etc…<br>보다 더 자세한 내용은 다음 링크를 참고하시면 됩니다. <a href="https://github.com/reactjs/prop-types" target="_blank" rel="external">reactjs/prop-types</a></p>
<h3 id="Set-Default-Props"><a href="#Set-Default-Props" class="headerlink" title="Set Default Props"></a>Set Default Props</h3><p>Component에서 외부로부터 받기로 한 props가 전달되지 않았을 경우를 대비해 props에 대한 default value도 지정해줘야 합니다. default props를 지정하는 것은 props의 type을 check하는 것과 매우 유사합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">App.defaultProps = &#123;</div><div class="line">  <span class="attr">title</span>: <span class="string">"unknown"</span>,</div><div class="line">  <span class="attr">author</span>: <span class="string">"unknown"</span>,</div><div class="line">  <span class="attr">onSubmit</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.warn(<span class="string">'onSubmit function is not defined!'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>각 타입에 맞는 적절한 default value를 설정해줄 수 있습니다. propType을 통해 정의한 type은 defaultProps에도 적용됩니다.</p>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>Component 내부에서 관리해야하는 상태 값이 존재하는 경우 <code>state</code>를 통해 관리할 수 있습니다. 이 <code>state</code>는 <code>constructor()</code> 내부에서 정의할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">isSelected</span>: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위의 예제 코드와 같이 Object로 state를 관리할 수 있습니다. state를 <strong>업데이트할 경우</strong>에는 Component의 <code>.setState()</code>라는 메소드를 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">isSelected</span>: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  handleClick() &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">isSelected</span>: <span class="literal">true</span>&#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Component의 <code>.setState()</code>메소드를 사용하는 메소드를 만들었습니다. Component의 메소드를 JSX 구문에서 사용하기 위해서는 <code>constructor</code>내부에서 <code>this</code>를 binding해줘야 합니다. 해당 메소드를 실행하는 시점에서 메소드 내부에 정의된 <code>this</code>가 달라지기 때문입니다.</p>
<p><code>.setState()</code>에 대해서 추가적으로 반드시 알아둬야 하는 부분이 있습니다. 바로 이 메소드는 비동기로 호출된다는 점입니다. 즉 일반 메소드처럼 콜스택에 추가되어 호출되는 것이 아니라 이벤트 큐로 들어가게 됩니다. 메소드를 호출할 때 이 부분을 유의하여 작성해야 합니다 :)</p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>외부, 즉 상위 컴포넌트에 의해 값이 변경될 수 있는 경우에 대해서는 props를 통해 해결하고 이 props는 해당 컴포넌트에서 변경해서는 안됩니다. 컴포넌트 내부에서 변경될 수 있는 값에 대해서는 state를 통해 해결합니다.</p>
<p>React와 관련된 포스트는 <a href="https://github.com/JaeYeopHan/react_tutorial_with_docs" target="_blank" rel="external">Github Repository</a>에서 실시간 피드를 받으실 수 있습니다.</p>
<p><em>Reference&gt;</em><br><a href="https://facebook.github.io/react/docs/components-and-props.html" target="_blank" rel="external">https://facebook.github.io/react/docs/components-and-props.html</a><br><a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank" rel="external">https://facebook.github.io/react/docs/typechecking-with-proptypes.html</a></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/06/13/React-3-Props-and-State-in-Component/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/06/13/React-3-Props-and-State-in-Component/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/05/19/React-2-Elements-and-Component/">
                            [React] 2. Elements and Component
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-05-19T14:02:02+09:00">
	
		    May 19, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/react_logo.png" alt=""></p>
<h1 id="React-2-Elements-and-Component"><a href="#React-2-Elements-and-Component" class="headerlink" title="[React] 2. Elements and Component"></a>[React] 2. Elements and Component</h1><h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p><code>Element</code>는 화면에 표시되는 내용이며, React를 구성하고 있는 가장 작은 블록이라고 할 수 있습니다. 브라우저 요소인 DOM과 달리 React Element는 보다 적은 비용으로 생성할 수 있으며 React DOM은 React Element와 일치하도록 DOM을 업데이트 합니다.</p>
<h2 id="Rendering-Elements"><a href="#Rendering-Elements" class="headerlink" title="Rendering Elements"></a>Rendering Elements</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>위와 같은 html 코드가 존재합니다. 실제로 존재하는 코드는 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>뿐이라고 볼 수 있습니다. React에서는 이것을 루트 노드(<code>Root DOM node</code>)라고 부릅니다. 이 태그 내부의 모든 element들은 <code>React DOM</code>에 의해 관리됩니다.</p>
<p>이전 포스팅에서 다뤘던 예제 코드를 다시 한번 살펴볼 차례입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">);</div><div class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</div></pre></td></tr></table></figure></p>
<p><code>루트 노드</code>를 select하여 내부에 작성한 element를 <code>render</code>할 수 있습니다.</p>
<p><br></p>
<h2 id="Immutable-Element"><a href="#Immutable-Element" class="headerlink" title="Immutable Element"></a>Immutable Element</h2><p>React element는 <code>immutable</code>입니다. element 렌더링한 후에는, 해당 element의 자식이나 attribute를 변경할 수 없습니다. React에서는 <strong>새로운 element를 전달</strong>하여 UI를 업데이트할 수 있습니다. 뭔가 너무 비효율적으로 보이지 않나요?</p>
<p>만약에 렌더링 된 element가 위의 예제처럼 짧지 않고 엄청 긴 element인데, 모든 element를 새로 전달해야 한다니. <strong>하지만</strong> React는 <strong>필요한 부분만 업데이트</strong> 합니다! React DOM은 새로 전달받은 element와 그 자식들을 이전의 element들과 비교하여 업데이트가 필요한 부분만 업데이트 합니다.</p>
<p>다음은 공식 홈페이지에 올라온 예제 코드입니다. 1초마다 <code>ReactDOM.render()</code>를 호출하여 UI를 업데이트합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> element = (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  );</div><div class="line">  ReactDOM.render(</div><div class="line">    element,</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">setInterval(tick, <span class="number">1000</span>);</div></pre></td></tr></table></figure></p>
<p>개발자 도구를 열어서 확인해보면 <code>{new Date().toLocaleTimeString()}</code>부분만 업데이트 되는 것을 확인하실 수 있습니다.</p>
<p><br></p>
<h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>Component는 Element로 구성될 수 있습니다. React에서는 Component를 설계하고 이를 사용하여 UI를 독립적이고 재사용 가능한 부분으로 분할할 수 있습니다.</p>
<h3 id="Component-정의"><a href="#Component-정의" class="headerlink" title="Component 정의"></a>Component 정의</h3><p>Component는 ES6의 <code>class</code>문법을 사용하여 정의할 수 있고 <code>React.createClass</code> 문법을 통하여 정의할 수 있고, <code>stateless한 Component</code>에 대하여 <code>functional Component</code> 방식으로 정의할 수 있습니다.</p>
<h4 id="class문법을-사용하여-React-Component를-extends-하는-방식으로-컴포넌트를-정의"><a href="#class문법을-사용하여-React-Component를-extends-하는-방식으로-컴포넌트를-정의" class="headerlink" title="class문법을 사용하여 React.Component를 extends 하는 방식으로 컴포넌트를 정의."></a><code>class</code>문법을 사용하여 React.Component를 extends 하는 방식으로 컴포넌트를 정의.</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello React World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="일반-함수-or-Arrow-function-를-사용하여-컴포넌트를-정의"><a href="#일반-함수-or-Arrow-function-를-사용하여-컴포넌트를-정의" class="headerlink" title="일반 함수(or Arrow function)를 사용하여 컴포넌트를 정의"></a>일반 함수(or Arrow function)를 사용하여 컴포넌트를 정의</h4><p><a href="https://facebook.github.io/react/docs/context.html" target="_blank" rel="external">React 공식 문서</a>에서는 <code>stateless functional component</code>라는 용어로 해당 컴포넌트를 설명하고 있습니다. 개발자들 사이에서는 Pure Component, Dumb Component, Presential Component 라고 불리기도 합니다. UI를 구성하게 되는 Component 중 state가 없거나 LifeCycle API를 사용할 일이 없는 경우 함수를 사용하여 정의합니다. 즉, 렌더링의 역할만 수행하는 컴포넌트를 정의할 때 사용하는 방식이라고 할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">const</span> dumb = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">);</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> dumb;</div></pre></td></tr></table></figure>
<p>위와 같이 Arrow function을 사용할 수도 있지만 일반 함수를 사용하는 경우에는 함수의 이름을 추론할 수 있기 때문에 airbnb convention에서는 다음과 같은 일반 함수 방식을 권장하고 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dumb</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Functional Component에 대해 자세히 설명된 포스팅입니다.<a href="https://velopert.com/2994" target="_blank" rel="external">Velopert-함수형 컴포넌트</a></p>
<ol>
<li><code>React.createElement()</code>를 사용하여 컴포넌트를 정의<br>사실 JSX로 작성된 element 또는 Component는 <code>React.createElement()</code>로 컴파일됩니다. React에서 일종의 sugar syntax를 제공하는 셈입니다. 즉 1번 case의 예제 코드는 다음과 같이 컴파일됩니다.<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>, <span class="string">`Hello React World`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>물론 위 코드도 <code>babel</code>에 의해 ES5 문법으로 transpile되겠지만 그 결과는 생략했습니다. 저번 포스팅에서도 언급된 <a href="https://github.com/apple77y/javascript/tree/master/react" target="_blank" rel="external">airbnb 에서 제공하는 React convention</a>에서는 JSX를 사용하고 있는데, 특별한 사유가 없다면 위 구문을 사용하지 말라고 합니다.</p>
<p>정의된 컴포넌트는 ReactDOM에서 render하거나 Component를 정의할 때 사용(composition)할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">Hello</span>/&gt;</span></span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</div></pre></td></tr></table></figure></p>
<p>혹시 위 예제와 이전 예제에서 차이점을 발견하셨나요? 일부러 다르게 작성해보았습니다. 달라진 점은 바로 <code>extends</code>하고 있는 클래스가 달라진 점인데요, 이 부분은 어떻게 React 라이브러리를 import하느냐에 따라 달라질 수 있습니다. 바로 위의 예제 같은 경우에는 다음과 같이 import하여 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div></pre></td></tr></table></figure></p>
<p><code>Component</code>만 import하지 않고 <code>React</code>까지 import하는 것은 바로 <code>React.createElement()</code>로 컴파일 되기 때문입니다. 마찬가지의 이유로 일반 함수로 Component를 정의할 때도 <code>React</code>를 import해줘야 합니다. <code>React.Component</code>보다는 <code>Component</code>만 extends하는 것이 타이핑도 줄고 더 깔끔하겠죠? 물론 snippet이 제공되서 직접 타이핑 할 필요는 없지만요 :)</p>
<p>Element에 대해서 그리고 Component를 어떻게 정의하는가에 대한 포스팅이었습니다. 감사합니다 :D</p>
<p>React와 관련된 포스트는 <a href="https://github.com/JaeYeopHan/react_tutorial_with_docs" target="_blank" rel="external">Github Repository</a>에서 실시간 피드를 받으실 수 있습니다.</p>
<p>Reference&gt;<br><a href="https://facebook.github.io/react/docs/react-without-jsx.html" target="_blank" rel="external">https://facebook.github.io/react/docs/react-without-jsx.html</a></p>
<p><em>2. end</em></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/05/19/React-2-Elements-and-Component/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/05/19/React-2-Elements-and-Component/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/05/15/React-1-Introducing-JSX-and-DOM/">
                            [React] 1. Introducing JSX and DOM
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-05-15T13:15:27+09:00">
	
		    May 15, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/react_logo.png" alt=""></p>
<h1 id="React-1-Introducing-JSX-and-DOM"><a href="#React-1-Introducing-JSX-and-DOM" class="headerlink" title="[React] 1. Introducing JSX and DOM"></a>[React] 1. Introducing JSX and DOM</h1><h2 id="JSX란-무엇인가"><a href="#JSX란-무엇인가" class="headerlink" title="JSX란 무엇인가"></a>JSX란 무엇인가</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p><code>JSX</code>라고 불리는 이 구문은 <code>string</code>도 아니고 <code>HTML</code>도 아닙니다. React 라이브러리에서 UI를 구성할 때 사용하는 구문으로 <strong>JavaScript의 extension</strong>이라고 할 수 있습니다.(물론, 사용하지 않을 수도 있습니다.) 타 프레임워크에서 사용했던 템플릿 엔진이라고 불리는 것들과 유사한 문법을 취하며(생김새만), JavaScript의 모든 기능을 제공합니다.</p>
<h2 id="JSX에-표현식-포함하기"><a href="#JSX에-표현식-포함하기" class="headerlink" title="JSX에 표현식 포함하기"></a>JSX에 표현식 포함하기</h2><p>자바스크립트의 표현식을 <code>{}</code>으로 묶어 JSX에 삽입할 수 있습니다. 기존의 템플릿 엔진에서 사용했던 방법과 비슷합니다. ES6에서 도입된 Template literal과도 비슷한 모습을 보입니다. 코드를 살펴보겠습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">);</div><div class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</div><div class="line"><span class="comment">//이 코드는 다음 포스팅에서 설명하며, 다음 예제 코드부터는 추가하지 않습니다.</span></div></pre></td></tr></table></figure></p>
<p>위와 같이 <code>element</code>라는 객체를 만들어서 <code>render()</code>메소드에 전달하여 렌더링할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1 + 1 = &#123;1 + 1&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p><code>{}</code>내부에서 자바스크립트 문법을 그대로 사용할 수도 있습니다.</p>
<h2 id="JSX는-결국-표현식입니다"><a href="#JSX는-결국-표현식입니다" class="headerlink" title="JSX는 결국 표현식입니다."></a>JSX는 결국 표현식입니다.</h2><p>컴파일이 끝나면 JSX 표현식은 일반 자바스크립트 <strong>객체</strong>가 됩니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> url = <span class="string">"api/get/someting"</span>;</div><div class="line"><span class="keyword">const</span> element = (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;url&#125;</span> /&gt;</span></span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>JSX로 HTML 태그의 속성 값을 지정하고자 할 때는 <code>&quot;&quot;</code>(double quote)를 사용하지 않습니다. 사용하게 되면 JSX는 속성을 표현식이 아닌 문자열 리터럴로 인식하게 됩니다. 위 <code>img</code>태그의 경우처럼 태그가 비어있으면 <code>/&gt;</code>로 바로 닫아줘야 합니다. 자식 컴포넌트가 없거나 한 줄로 element 작성이 끝나는 경우에는 닫힘 태그로 self-close를 해줍니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>1 + 1 = &#123;1 + 1&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>위의 같은 경우처럼 HTML의 문법을 사용하여 태그들을 계층화하여 구성할 수 있습니다. 하지만 이 때 주의할 사항이 한 가지 있습니다. 반드시 루트 노드(Root Node)로 <strong>하나의 노드를 지정</strong>해야 한다는 것입니다. ReactDOM은 오직 하나의 루트 노드만 렌더링하기 때문에 다음의 경우는 렌더링하지 못합니다.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//Error!</div><div class="line">const element = (</div><div class="line">    &lt;h1&gt;Hi&lt;/h1&gt;</div><div class="line">    &lt;h2&gt;1 + 1 = &#123;1 + 1&#125;&lt;/h2&gt;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>동일 depth에 존재하는 element가 여러 개 존재하기 때문에 error가 발생하게 됩니다. 여러 개의 element들을 계층화하는 경우에는 이전의 예제 코드처럼 element들을 <code>div</code>태그로 감싸줘야 합니다.</p>
<p>기본적으로 <code>React DOM</code>은 렌더링하기 전에 JSX에 임베디드 된 모든 값을 이스케이프 처리합니다. 따라서 응용프로그램에 명시적으로 작성되지 않은 것을 삽입할 수 없고 XSS 공격을 방지할 수 있습니다.</p>
<h2 id="DOM-Elements"><a href="#DOM-Elements" class="headerlink" title="DOM Elements"></a>DOM Elements</h2><p>React는 성능과 크로스 브라우징 이슈를 해결하기 위해 브라우저로부터 독립적인 DOM 체계를 구축하고 있습니다. 그렇기 때문에 기존의 HTML 속성과 다른 점이 존재합니다.</p>
<h3 id="Camel-Case-Attributes"><a href="#Camel-Case-Attributes" class="headerlink" title="Camel-Case Attributes"></a>Camel-Case Attributes</h3><p>기본적으로 React에서는 모든 DOM 속성 또는 이벤트 핸들러를 Camel-case로 처리해야 합니다.</p>
<h3 id="다른-Attributes"><a href="#다른-Attributes" class="headerlink" title="다른 Attributes"></a>다른 Attributes</h3><h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><p><code>style</code> 속성은 camelCase를 기반으로 작성된 style JavaScript 객체로 설정합니다. 모든 DOM의 속성과 일치하여, 원래 CSS에서 사용하던 속성들을 camelCase로 변경해서 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> headerStyle = &#123;</div><div class="line">  <span class="attr">backgroundColor</span>: <span class="string">'#EEE'</span>;</div><div class="line">  borderRadius: <span class="string">'5px'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;headerStyle&#125;</span>&gt;</span>Apply style as camelCase<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="className"><a href="#className" class="headerlink" title="className"></a>className</h4><p>기본적으로 HTML에서는 태그에 class를 지정해줄 때, <code>&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;</code>와 같은 방식을 사용했습니다. 그러나 React에서는 <code>className</code>이라는 속성을 통해 접근합니다. 다음과 같이 나타낼 수 있습니다.<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> container = (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</div></pre></td></tr></table></figure></p>
<p>cf&gt; JSX 속성값에는 항상 <strong>double quote</strong>를 사용합니다. JSX 속성값을 제외한 나머지 경우에 대해서는 <strong>single quote</strong>를 사용합니다. 강제적인 것이 아닌 <a href="https://github.com/apple77y/javascript/tree/master/react" target="_blank" rel="external">airbnb 에서 제공하는 React convention</a> 입니다.</p>
<h4 id="onChange"><a href="#onChange" class="headerlink" title="onChange"></a>onChange</h4><p>이 속성을 가지고 있는 필드가 변경될 때마다 이벤트가 발생합니다. React에서는 실시간으로 사용자 입력을 처리하기 위한 방법으로 이벤트를 사용합니다.<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125;/&gt;</div></pre></td></tr></table></figure></p>
<p>위 예제 코드에서는 <code>input</code>태그에 event가 발생할 때마다 <code>handleChange</code>라는 메소드가 호출됩니다.</p>
<h4 id="checked"><a href="#checked" class="headerlink" title="checked"></a>checked</h4><p><code>input</code>태그 중 <code>checkbox</code>타입 또는 <code>radio</code>타입에서 지원되는 <code>checked</code> 속성입니다. 이 속성은 <code>controlled components</code>에 대해서 사용할 때 유용합니다.</p>
<h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p><code>value</code> 속성은 <code>input</code>과 <code>textarea</code>태그에 대해 지원되는 속성입니다. 이 속성을 통하여 요소의 값을 설정할 수 있습니다. 하지만 이 값은 DOM의 값보다 우선됩니다. 그렇기 때문에 이 속성은 <code>controlled components</code>에 대해서 사용할 때 유용합니다. 초기값만 지정하려는 경우에는. 즉 <code>uncontrolled components</code>에 대해서는 <code>defaultValue</code> 속성을 사용할 수 있습니다.</p>
<h4 id="defaultValue-defaultChecked"><a href="#defaultValue-defaultChecked" class="headerlink" title="defaultValue, defaultChecked"></a>defaultValue, defaultChecked</h4><p><code>&lt;textarea&gt;</code>와 <code>&lt;input type=&#39;text&#39;&gt;</code>에 대해서 지원합니다. 또한 <code>type=checkbox</code>와 <code>type=radio</code>타입의 <code>&lt;input&gt;</code>태그에 대해서는 <code>defaultChecked</code>를 지원합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;input  </div><div class="line">  type=<span class="string">"text"</span></div><div class="line">  defaultValue=<span class="string">"Jbee"</span>  </div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
<h4 id="htmlFor"><a href="#htmlFor" class="headerlink" title="htmlFor"></a>htmlFor</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">'name'</span>&gt;</span>Name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div><div class="line">//"Warning: Unknown DOM property for. Did you mean htmlFor?</div><div class="line">//  in label</div><div class="line">//  in div"</div></pre></td></tr></table></figure>
<p><code>for</code>를 대체하는 <code>htmlFor</code>입니다. <code>for</code>속성을 사용하려고 하면 warning이 발생합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">'name'</span>&gt;</span>Name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>JavaScript 문법의 <code>for</code> 예약어와 겹치기 때문에 <code>htmlFor</code>가 생겨났습니다.</p>
<h4 id="dangerouslySetInnerHTML"><a href="#dangerouslySetInnerHTML" class="headerlink" title="dangerouslySetInnerHTML"></a>dangerouslySetInnerHTML</h4><p>이 속성은 DOM에서 사용하던 <code>innerHTML</code> 속성을 대체하기 위해 만들어졌습니다. 코드에서 HTML을 설정하는 것은 XSS 공격에 노출되기 쉽기 때문에 위험합니다. 그렇기 때문에 React에서는 이 속성 사용을 최소화하기 위해 장치를 마련해놓은 것입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">innerHTML</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">__html</span>: <span class="string">'Dangerous inner html!'</span>&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;innerHTML()&#125;</span> /&gt;</span>;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>그럼에도 불구하고 <code>dangerouslySetInnerHTML</code> 속성을 사용하려면 위의 예제 코드와 같이 <code>__html</code>이라는 키 값과 함께 객체를 전달하여 사용할 수 있습니다.</p>
<p>React와 관련된 포스트는 <a href="https://github.com/JaeYeopHan/react_tutorial_with_docs" target="_blank" rel="external">Github Repository</a>에서 실시간 피드를 받으실 수 있습니다.</p>
<p><em>1. end</em></p>
<p>Reference&gt;<br><a href="https://facebook.github.io/react/docs/introducing-jsx.html" target="_blank" rel="external">React Documentation - Introducing JSX</a><br><a href="https://facebook.github.io/react/docs/dom-elements.html" target="_blank" rel="external">React Documentation - DOM Elements</a></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/05/15/React-1-Introducing-JSX-and-DOM/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/05/15/React-1-Introducing-JSX-and-DOM/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Jbee. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Jbee</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->



    </body>
</html>


<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Devlog">
    <title>Tag: ts - Devlog</title>
    <meta name="author" content="Jbee">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/feed.xml">
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="blog posted about front end development">
<meta property="og:type" content="blog">
<meta property="og:title" content="Devlog">
<meta property="og:url" content="https://jaeyeophan.github.io/tags/ts/index.html">
<meta property="og:site_name" content="Devlog">
<meta property="og:description" content="blog posted about front end development">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Devlog">
<meta name="twitter:description" content="blog posted about front end development">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Devlog</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Search"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/" target="_blank" rel="noopener" title="Google +">
                    
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/profile/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/mailto"
                            title="Mail"
                        >
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/06/16/TS-8-enum-vs-const-enum/">
                            [TS] 8. enum vs const enum
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-06-16T15:02:44+09:00">
	
		    Jun 16, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-8-enum-vs-const-enum"><a href="#TS-8-enum-vs-const-enum" class="headerlink" title="[TS] 8. enum vs const enum"></a>[TS] 8. enum vs const enum</h1><p>TypeScript 문법 중 <code>enum</code> 이라는 것이 있다. 주로 상수를 선언할 때 namespace 를 줘서 상수끼리의 응집도를 높이고 그 의미를 더할 수 있으며 VSCode 의 auto complete 의 지원을 받을 때 유용하다. 이 <code>enum</code> 키워드를 사용하는 방법에는 두 가지가 존재한다. 그냥 <code>enum</code> 키워드를 사용해 선언할 수 있으며 <code>const</code> 키워드와 함께 사용하여 <code>const enum</code>으로 선언할 수 있다.</p>
<p>이 두 가지는 무엇이 다를까.</p>
<p><a href="http://www.typescriptlang.org/play/" target="_blank" rel="external">TypeScript Playground</a>에 가서 JavaScript 로 compile 된 모습을 먼저 살펴보자.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> JustEnumNumber &#123;</div><div class="line">  zero,</div><div class="line">  one</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(JustNumber.one); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>간단한 <code>enum</code> 을 선언했다. 이 <code>JustEnumNumber</code>는 다음과 같이 transpile 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> JustEnumNumber;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">JustEnumNumber</span>) </span>&#123;</div><div class="line">  JustEnumNumber[(JustEnumNumber[<span class="string">"zero"</span>] = <span class="number">0</span>)] = <span class="string">"zero"</span>;</div><div class="line">  JustEnumNumber[(JustEnumNumber[<span class="string">"one"</span>] = <span class="number">1</span>)] = <span class="string">"one"</span>;</div><div class="line">&#125;)(JustEnumNumber || (JustEnumNumber = &#123;&#125;));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(JustNumber.one); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p><code>enum</code>에 대해 알아본 적이 있다면 익숙한 JavaScript 형태로 transpile 되는 것을 확인할 수 있다. 사실 저 코드는 조금 복잡해보여도 다음과 같은 코드이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> JustEnumNumber;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">JustEnumNumber</span>) </span>&#123;</div><div class="line">  JustEnumNumber[<span class="string">"zero"</span>] = <span class="number">0</span>;</div><div class="line">  JustEnumNumber[<span class="string">"one"</span>] = <span class="number">1</span>;</div><div class="line">  JustEnumNumber[<span class="number">0</span>] = <span class="string">"zero"</span>;</div><div class="line">  JustEnumNumber[<span class="number">1</span>] = <span class="string">"one"</span>;</div><div class="line">&#125;)(JustEnumNumber || (JustEnumNumber = &#123;&#125;));</div></pre></td></tr></table></figure>
<p>이젠 <code>const enum</code>을 보자.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">enum</span> ConstEnumNumber &#123;</div><div class="line">  zero,</div><div class="line">  one</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ConstEnumNumber.one); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>아까와 같은 간단한 <code>enum</code>을 선언했고 플레이그라운드에서 JavaScript 도 transpile 을 해보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="comment">/* one */</span>); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p><code>enum</code> 구현체는 다 사라지고 console 을 위한 코드만 남아있다. <code>const</code> 키워드를 사용하고 안 하고의 차이가 좀 큰 것 같다.</p>
<p>다시 <code>`JustEnumNumber</code>코드를 보자.<code>enum</code>만으로 선언할 경우, namespace 를 위한 변수가 선언이 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> JustEnumNumber;</div></pre></td></tr></table></figure>
<p>그리고 선언된 변수를 객체로 우리가 원하는 상수값들을 선언하게 된다. 이 때 선언된 변수는 transpile 되어서도 남아있게 되어 우리는 <code>enum</code>으로 선언한 객체 자체에 접근할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(JustEnumNumber); <span class="comment">// [object object]</span></div></pre></td></tr></table></figure>
<p>하지만 <code>const enum</code>으로 enum 을 선언하게 되면 compile 단계에서 namespace 가 날라가게 되므로 접근할 수 없다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(ConstEnumNumber); <span class="comment">// [ERROR] 'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query.</span></div></pre></td></tr></table></figure>
<p>내부 상수값들이 전부 compile 단계에서 대치된 것이다. 내부 필드를 전부 상수로 변경하기 때문에 런타임에 의존 모듈의 영향을 받지 않게 되며, 코드 크기가 더 적기 때문에 더 선호된다고 한다.</p>
<p>사실 이 부분은 TypeScript Official Document 에 다음과 같이 나와있다.</p>
<blockquote>
<p>To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use <code>const</code> enums.</p>
</blockquote>
<p>그렇다면 <code>enum</code>만으로 선언하는 경우는 언제일까.</p>
<p>우선 namespace 가 남아있으니 우리는 enum 을 이렇게도 사용할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(JustEnumNumber[JustEnumNumber.one]); <span class="comment">// one</span></div></pre></td></tr></table></figure>
<p>상수만으로 로그가 찍히면 알아보기 힘드니 reverse 참조를 하여 로그를 찍을 수 있다. lookup object 로 사용하는 것이다. 하지만 이렇게 선언된 enum 은 런타임에 이 lookup object 를 통해 참조가 이루어지므로 조심해야 한다. 물론 webpack 환경에서는</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이렇게 scope 를 쳐주지만 test 환경에서는 browser 객체(ex. window…)를 참조하는 경우 에러가 발생할 수 있다.</p>
<p>참고한 블로그의 문장을 인용하여 해당 글을 마친다.</p>
<blockquote>
<p><code>const enum</code> is a <strong>compile-time only</strong> feature, while the original <code>enum</code> is a <strong>runtime + compile-time</strong>feature. Most projects will be well suited for <code>const enum</code>, but there may be cases where <code>enum</code> is preferred.</p>
</blockquote>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="external">https://www.typescriptlang.org/docs/handbook/enums.html</a></li>
<li><a href="https://www.sitepoint.com/10-essential-typescript-tips-tricks-angular/?WT.mc_id=link-twitter-jeliknes" target="_blank" rel="external">https://www.sitepoint.com/10-essential-typescript-tips-tricks-angular/?WT.mc_id=link-twitter-jeliknes</a></li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/06/16/TS-8-enum-vs-const-enum/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2018/06/16/TS-8-enum-vs-const-enum/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/01/10/TS-7-TypeScript-type-system/">
                            [TS] 7. TypeScript type system
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-10T13:31:30+09:00">
	
		    Jan 10, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-7-Typescript’s-Type-System"><a href="#TS-7-Typescript’s-Type-System" class="headerlink" title="[TS] 7. Typescript’s Type System"></a>[TS] 7. Typescript’s Type System</h1><h3 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h3><ul>
<li>TypeScript의 Type Checking System</li>
<li>Type Inference</li>
<li>Type Assertion</li>
<li>Type Guards</li>
<li>Type Compatibility</li>
</ul>
<p><br></p>
<h2 id="TypeScript의-Typing-Checking-System"><a href="#TypeScript의-Typing-Checking-System" class="headerlink" title="TypeScript의 Typing Checking System"></a>TypeScript의 Typing Checking System</h2><p><code>TypeScript</code>에서의 Type System에 대한 이해를 하기 전, 기존 프로그래밍 언어의 큰 두 축인 정적 언어와 동적 언어에 대한 정의를 다시 한 번 살펴볼 필요가 있습니다.</p>
<h3 id="정적언어-Static-Language"><a href="#정적언어-Static-Language" class="headerlink" title="정적언어 (Static Language)"></a>정적언어 (Static Language)</h3><ul>
<li>변수(variables) 또는 함수(function)의 <code>Type</code>을 <strong>미리</strong> 지정해야 한다.</li>
<li>컴파일되는 시점에 Type Check를 수행한다.</li>
</ul>
<h3 id="동적-언어-Dynamic-Language"><a href="#동적-언어-Dynamic-Language" class="headerlink" title="동적 언어 (Dynamic Language)"></a>동적 언어 (Dynamic Language)</h3><ul>
<li>변수(variables) 또는 함수(function)의 <code>Type</code>을 지정하지 않는다.</li>
<li>Type Check는 런타임(runtime) 환경에서나 알 수 있다.</li>
</ul>
<h3 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h3><p>덕 타이핑(Duck Typing)이라고 많이 들어보셨을 텐데요, 현재 이 덕 타이핑 체계를 기반으로 동적 언어에 타입을 추론하는 언어는 GoLang과 Python 등이 있습니다. 하지만 TypeScript는 이 덕타이핑과는 조금 다른 체계로 <strong>Typing</strong>을 하고 있습니다.</p>
<blockquote>
<p>덕 타이핑에 대한 보다 자세한 내용은 <a href="https://www.google.co.kr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwjj5dzEl8PYAhXCNJQKHfG9DdYQFggxMAE&amp;url=http%3A%2F%2Fwww.popit.kr%2Fgolang%25EC%259C%25BC%25EB%25A1%259C-%25EB%25A7%258C%25EB%2582%2598%25EB%25B3%25B4%25EB%258A%2594-duck-typing%2F&amp;usg=AOvVaw1dXNKFpMsVofdtJ-QOglzu" target="_blank" rel="external">여기</a>를 참고해주세요.</p>
</blockquote>
<h3 id="Structural-typing"><a href="#Structural-typing" class="headerlink" title="Structural typing"></a>Structural typing</h3><p>TypeScript는 <strong>Structural typing</strong> (구조적 타이핑)을 기반으로 타입 시스템을 갖추고 있습니다. 구조적 타이핑이란, <code>멤버</code>에 따라 타입을 <strong>연관짓는</strong> 방법을 말합니다. 구조적 타이핑과 반대인 방법으로 <code>nominal typing</code>이 있습니다. 우리가 알고 있는 일반적인 정적 언어인 C#, Java는 이 <code>nominal typing</code> 방식으로 <strong>type checking</strong>이 이루어집니다.</p>
<p><em>Official Document</em>에 나온 예제를 통해 설명드립니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Named &#123;</div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Person &#123;  </div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p: Named;</div><div class="line">p = <span class="keyword">new</span> Person(); <span class="comment">// Ok, because of structural typing</span></div></pre></td></tr></table></figure></p>
<p>위 코드를 C# 또는 Java의 문법에 맞게 변경한다면 동작하지 않는 잘못된 코드가 됩니다. 하지만 TypeScript에서는 정상적으로 동작합니다. <code>Named</code>와 <code>Person</code> 두 가지는 오로지 <code>name</code>이라는 프로퍼티(or 멤버)만 갖고 있는 타입이므로 서로 <code>compatibility</code> 하다고 볼 수 있습니다. 때문에 위 코드는 문제되지 않습니다. (compatibility에 대해서는 뒤에서 알아봅니다.)</p>
<p><br></p>
<h2 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h2><p>‘누가봐도 이 변수는 이 타입이다.’라는 것에 대해 TypeScript가 지원해주는 것을 <strong>타입 추론</strong> 이라고 합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">`jbee`</span>;</div></pre></td></tr></table></figure></p>
<p><code>name</code>이라는 변수는 <code>string</code> 타입의 변수가 됩니다. 그렇기 때문에 굳이 <code>: string</code>이라고 타입을 지정해주지 않아도 다음과 같이 에러가 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name = <span class="number">1</span>; <span class="comment">// Error: Type '1' is not assignable to type 'string'.</span></div></pre></td></tr></table></figure></p>
<p>그렇다면 다음과 같은 경우에는 어떻게 추론될까요?<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mixedArr = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">`jbee`</span>];</div></pre></td></tr></table></figure></p>
<p><code>number</code>에 해당되는 value와 <code>string</code>에 해당하는 value가 공존하기 때문에 위 코드에서 <code>mixedArr</code>은 <code>(number | string)[]</code>의 타입을 갖게 됩니다. 이렇게 여러 타입이 공존하는 경우에 추론하여 지정되는 타입을 <strong>Best common type</strong>이라고 합니다.</p>
<p><br></p>
<h2 id="Type-Assertion"><a href="#Type-Assertion" class="headerlink" title="Type Assertion"></a>Type Assertion</h2><p>이 변수의 타입은 분명 <code>A</code>인데 TypeScript에서 보수적으로 처리하여 에러를 발생시키는 경우가 있습니다. 이럴 경우 해당 변수를 <code>A</code>라고 명시하여 에러를 사라지게 할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">type</span> Todo = &#123;</div><div class="line">  id: <span class="built_in">number</span>;</div><div class="line">  text: <span class="built_in">string</span>;</div><div class="line">  completed: <span class="built_in">boolean</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">type</span> Todos = Todo[];</div></pre></td></tr></table></figure></p>
<p>위와 같이 <code>Todo</code> 타입과 <code>Todos</code> 타입을 지정한 상황이라고 했을 때를 예로 들어보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState: Todos = [</div><div class="line">  &#123;</div><div class="line">    id: <span class="number">0</span>,</div><div class="line">    text: <span class="string">'Study RxJS'</span>,</div><div class="line">    completed: <span class="literal">false</span>,</div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>위 코드에서 <code>Todos</code>에 해당하는 타입을 제대로 지정해줬지만 뭔가 아쉬움이 남을 수 있는데요, 이 때 두 가지 방법을 사용할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState: Todos = [</div><div class="line">  &lt;TODO&gt;&#123;</div><div class="line">    id: <span class="number">0</span>,</div><div class="line">    text: <span class="string">'Study RxJS'</span>,</div><div class="line">    completed: <span class="literal">false</span>,</div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>위 코드처럼 <code>&lt;&gt;</code>을 사용하거나<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState: Todos = [</div><div class="line">  &#123;</div><div class="line">    id: <span class="number">0</span>,</div><div class="line">    text: <span class="string">'Study RxJS'</span>,</div><div class="line">    completed: <span class="literal">false</span>,</div><div class="line">  &#125; <span class="keyword">as</span> Todo</div><div class="line">];</div></pre></td></tr></table></figure></p>
<p>위 코드처럼 <code>as</code> 키워드를 사용할 수 있습니다. 두 가지 모두 동일하지만 <code>tsx</code>와 함께 사용하기 위해서는 <code>as</code> 키워드를 사용하는 것이 좋습니다.</p>
<blockquote>
<p>[!] 이 Type Assertion은 Type Casting과는 다릅니다. 자세한 내용은 <a href="https://hyunseob.github.io/2017/12/12/typescript-type-inteference-and-type-assertion/" target="_blank" rel="external">DailyEngineering - 타입 추론과 타입 단언</a>을 참고해주세요!</p>
</blockquote>
<p><br></p>
<h2 id="Type-Guards"><a href="#Type-Guards" class="headerlink" title="Type Guards"></a>Type Guards</h2><p>자바스크립트에서는 <code>typeof</code> 또는 <code>instanceof</code>와 같은 오퍼레이터가 타입을 확인해주는 역할을 했었습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.state[key] !== <span class="keyword">typeof</span> newData) &#123;</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>하지만 이 방법은 런타임에서 타입 체크를 수행하게 됩니다. 따라서 컴파일 시점에서는 올바른 타입인지 알 수 없습니다. TypeScript에서는 컴파일 시점에서 타입 체크를 수행할 수 있도록 <code>Type Guard</code>를 지원합니다.</p>
<p><br></p>
<h3 id="typeof-instanceof"><a href="#typeof-instanceof" class="headerlink" title="typeof, instanceof"></a><code>typeof</code>, <code>instanceof</code></h3><p>TypeScript에서도 마찬가지로 <code>typeof</code>와 <code>instanceof</code> 오퍼레이터를 지원합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setNumberOrString</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x.subtr(<span class="number">1</span>)); <span class="comment">// Error</span></div><div class="line">    <span class="built_in">console</span>.log(x.substr(<span class="number">1</span>)); <span class="comment">// OK</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(typof x); <span class="comment">// number</span></div><div class="line">  &#125;</div><div class="line">  x.substr(<span class="number">1</span>); <span class="comment">// Error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위 코드에서 <code>if-block</code>내에서의 <code>x</code>변수의 타입은 <code>string</code>일 수 밖에 없다는 것을 컴파일 시점에 체크하여 transpiler가 Error를 발생시키는 경우입니다. 이 예제와 비슷한 방법으로 <code>instanceof</code> 오퍼레이터를 사용할 수 있습니다. <code>instanceof</code>는 클래스를 기반으로 생성된 인스턴스의 타입을 판단하는데 사용됩니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Pet &#123;</div><div class="line">  name = <span class="number">123</span>;</div><div class="line">  common = <span class="string">'123'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Basket &#123;</div><div class="line">  size = <span class="number">123</span>;</div><div class="line">  common = <span class="string">'123'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">arg: Pet | Basket</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Pet) &#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.name); <span class="comment">// OK</span></div><div class="line">    <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error!</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Basket) &#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.name); <span class="comment">// Error!</span></div><div class="line">    <span class="built_in">console</span>.log(arg.size); <span class="comment">// OK</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(arg.common); <span class="comment">// OK</span></div><div class="line">  <span class="built_in">console</span>.log(arg.name); <span class="comment">// Error!</span></div><div class="line">  <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error!</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>typeof</code>와 마찬가지로 <code>instanceof</code>로 필터링 된 block 내부에서 <strong>Type checking</strong>이 이루어집니다.</p>
<p><br></p>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> A &#123;</div><div class="line">  x: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> B &#123;</div><div class="line">  y: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">q: A | B</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="string">'x'</span> <span class="keyword">in</span> q) &#123;</div><div class="line">    <span class="comment">// q: A</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// q: B</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>A</code> 또는 <code>B</code>를 유니온 타입으로 받을 수 있는 <code>execute</code> 함수 내에서 각각에 대해 다른 처리를 할 경우, <code>in</code>이라는 오퍼레이터를 사용할 수 있습니다. 해당 오퍼레이터는 check하고자 하는 타입에 해당 프로퍼티가 존재하는지의 유무를 판단할 수 있습니다.</p>
<p><br></p>
<h3 id="kind-Literal-Type-Guard"><a href="#kind-Literal-Type-Guard" class="headerlink" title=".kind Literal Type Guard"></a><code>.kind</code> Literal Type Guard</h3><p>사용자에 의해 <code>type</code>으로 정의된 타입에 대해서, 즉 TypeScript 내부에서 지원하는 primitive type이 아닌 <strong>사용자 정의 타입에 대해서 타입 검사를 수행할 때</strong>, <code>.kind</code>를 사용할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Foo = &#123;</div><div class="line">  kind: <span class="string">'foo'</span>, <span class="comment">// Literal type </span></div><div class="line">  foo: <span class="built_in">number</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> Bar = &#123;</div><div class="line">  kind: <span class="string">'bar'</span>, <span class="comment">// Literal type </span></div><div class="line">  bar: <span class="built_in">number</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">arg: Foo | Bar</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arg.kind === <span class="string">'foo'</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.foo); <span class="comment">// OK</span></div><div class="line">    <span class="built_in">console</span>.log(arg.bar); <span class="comment">// Error!</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위 코드에서 처럼 <code>type</code> 키워드를 사용하여 별도 타입을 지정할 때, <code>kind</code>라는 프로퍼티를 추가하여 타입 검사를 수행할 수 있습니다.</p>
<p><br></p>
<h3 id="User-Defined-Type-Guards"><a href="#User-Defined-Type-Guards" class="headerlink" title="User Defined Type Guards"></a>User Defined Type Guards</h3><p>메소드를 별도로 분리하여 Type Guard를 지정할 수 있습니다. 아까 지정한 interface A로 만들어보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> A &#123;</div><div class="line">  x: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Define Type Guard</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isA</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">arg</span> <span class="title">is</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> arg.x !== <span class="literal">undefined</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>arg is A</code>라는 타입으로 <code>isA</code> 메소드가 Type Guard의 역할을 수행한다는 것을 명시할 수 있습니다. if 내부에 들어가는 로직을 별도로 추출하여 보다 가독서이 좋은 코드를 작성할 수 있습니다.</p>
<p><br></p>
<h2 id="Type-Compatibility"><a href="#Type-Compatibility" class="headerlink" title="Type Compatibility"></a>Type Compatibility</h2><p>한국어로 번역하게 되면 <strong>타입 호환성</strong> 정도로 할 수 있겠는데요, TypeScript는 위에서 언급했듯이 <strong>Structural subtyping</strong>을 기반으로 Type checking을 하기 때문에 이를 기반으로 타입 간의 호환성을 고려할 수 있습니다.</p>
<h4 id="1-Comparing-two-Objects"><a href="#1-Comparing-two-Objects" class="headerlink" title="1. Comparing two Objects"></a>1. Comparing two Objects</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = &#123;name: <span class="string">`Jbee`</span>&#125;;</div><div class="line"><span class="keyword">let</span> y = &#123;name: <span class="string">`James`</span>, age: <span class="number">34</span>&#125;;</div><div class="line"></div><div class="line">x = y; <span class="comment">// OK!</span></div><div class="line">y = x; <span class="comment">// Error!</span></div></pre></td></tr></table></figure>
<p>위 코드에서 <code>x</code>는 <code>{name: string}</code> 타입으로 추론되며, <code>y</code>는 <code>{name: string, age: number}</code>로 추론됩니다. 이 경우 <code>x = y</code>는 <code>y</code>에 <code>name</code>이라는 속성이 있으므로 가능하지만 <code>y = x</code>의 경우, <code>x</code>에는 <code>age</code>라는 속성이 없으므로 에러가 발생합니다.</p>
<h4 id="2-Comparing-two-functions"><a href="#2-Comparing-two-functions" class="headerlink" title="2. Comparing two functions"></a>2. Comparing two functions</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">y = x; <span class="comment">// OK</span></div><div class="line">x = y; <span class="comment">// Error</span></div></pre></td></tr></table></figure>
<p>함수일 경우에는 객체인 경우와 조금 다른 것을 볼 수 있습니다. 위 코드에서 두 <code>x</code>, <code>y</code>함수는 parameter 만 다르게 정의되어 있습니다. 이 경우, <code>x</code> 함수에 전달할 수 있는 parameter의 경우의 수가 y에 모두 해당하므로 <code>y = x</code>가 정상적으로 동작합니다. 하지만 그 반대인 <code>x = y</code>는 <code>y</code> 함수에 전달할 수 있는 parameter를 <code>x</code>가 모두 포용할 수 없으므로 에러가 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">`Jbee`</span>&#125;);</div><div class="line"><span class="keyword">let</span> y = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">`James`</span>, age: <span class="number">34</span>&#125;);</div><div class="line"></div><div class="line">x = y; <span class="comment">// OK!</span></div><div class="line">y = x; <span class="comment">// Error!</span></div></pre></td></tr></table></figure></p>
<p>이번에는 return value의 type이 다른 경우입니다. 이 경우에는 함수의 경우를 따르지 않고 객체인 경우를 따르게 됩니다.</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>TypeScript의 단순한 문법을 조금 넘어서 어떻게 Type Checking이 이루어지는지 살펴봤습니다.<br>감사합니다.</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/type-inference.html" target="_blank" rel="external">TypeScript Official Document - Type Inference</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="external">TypeScript Official Document - Type Compatibility</a></li>
<li><a href="http://www.popit.kr/golang%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%82%98%EB%B3%B4%EB%8A%94-duck-typing/" target="_blank" rel="external">Golang으로 만나보는 duck typing</a></li>
<li><a href="https://medium.com/@thejameskyle/type-systems-structural-vs-nominal-typing-explained-56511dd969f4" target="_blank" rel="external">Type Systems: Structural vs Nominal typing explained</a></li>
<li><a href="https://basarat.gitbooks.io/typescript/docs/types/typeGuard.html" target="_blank" rel="external">TypeScript Deep dive - Type Guard</a></li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/01/10/TS-7-TypeScript-type-system/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2018/01/10/TS-7-TypeScript-type-system/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/01/09/TS-6-Decorator/">
                            [TS] 6. Decorator
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-09T09:59:14+09:00">
	
		    Jan 09, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-6-Decorators"><a href="#TS-6-Decorators" class="headerlink" title="[TS] 6. Decorators"></a>[TS] 6. Decorators</h1><p>이번 포스팅에서는 현재 JavaScript에서도 <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="external">ts39/proposal stage-2</a>에 올라와있는 <code>Decorator</code>에 대해 알아보겠습니다.</p>
<h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul>
<li>Setup</li>
<li>Intro</li>
<li>Decorator to method</li>
<li>Decorator to class</li>
<li>Decorator with parameter</li>
</ul>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>자바스크립트 babel환경에서 데코레이터를 테스트해보기 위해서는 babel 플러그인이 추가적으로 필요합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install babel-core babel-plugin-transform-decorators-legacy --save-dev</div></pre></td></tr></table></figure></p>
<p><code>babel-core</code>를 기본으로 하며, babel-plugin을 추가적으로 설치해줍니다.<br><figure class="highlight"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  //...</div><div class="line">  "plugins": ["transform-decorators-legacy"]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>해당 프로젝트의 babel설정을 담고 있는 <code>.babelrc</code>파일에 설치한 플러그인을 추가해줍니다. 보다 구체적인 해당 개발환경은 <a href="https://github.com/JaeYeopHan/esnext_labs" target="_blank" rel="external">여기</a>를 참고해주세요.</p>
<p>TyeScript에서는 <code>tsconfig.json</code>의 <code>compilerOption</code>을 다음과 같이 변경해줍니다.<br><figure class="highlight json"><figcaption><span>tsconfig.json</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"compilerOptions"</span>: &#123;</div><div class="line">        <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</div><div class="line">        <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>TypeScript(JavaScript)에서 <code>@</code>이라는 character로 사용하는 문법을 <code>Decorator(데코레이터)</code>라고 합니다. 자바를 경험해보신 분이라면 <code>Annotation</code>인가? 라고 생각하기 쉬운데요, 조금 다릅니다. 데코레이터는 <strong>함수</strong> 라고 할 수 있습니다. 데코레이터는 말 그대로 코드 조각을 장식해주는 역할을 하며 타입스크립트에서는 그 기능을 함수로 구현할 수 있습니다.</p>
<p>Decorator는 클래스 선언, 메서드, 접근 제어자, 속성 또는 매개 변수에 첨부 할 수 있는 특별한 종류의 선언입니다. 데코레이터는 <code>@expression</code> 형식을 사용하는데, expression은 데코레이팅 된 선언에 대한 정보와 함께 존재하며 이는 <strong>런타임에</strong> 호출됩니다.</p>
<h4 id="참조-reference"><a href="#참조-reference" class="headerlink" title="참조(reference)"></a>참조(reference)</h4><p>데코레이터는 <code>@decorator</code>과 같이 사용할 수 있으며 <code>@[name]</code>의 형식일 때 <code>name</code>에 해당하는 이름의 함수를 참조하게 됩니다.</p>
<h4 id="실행-시점-execute-time"><a href="#실행-시점-execute-time" class="headerlink" title="실행 시점(execute time)"></a>실행 시점(execute time)</h4><p>이렇게 데코레이터로 정의된 함수는 데코레이터가 적용된 메소드가 실행되거나 클래스가 <code>new</code>라는 키워드를 통해 인스턴스화 될 때가 아닌 런타임 때 실행됩니다. 즉, 매번 실행되지 않습니다.</p>
<p><em>그럼 데코레이터가 메소드에 적용되는 경우, 클래스에 적용되는 경우, 프로퍼티에 적용되는 경우 이렇게 세 가지로 나누어 코드를 살펴보겠습니다.</em></p>
<p><br></p>
<h2 id="Decorator-to-Method"><a href="#Decorator-to-Method" class="headerlink" title="Decorator to Method"></a>Decorator to Method</h2><blockquote>
<p>메소드에 적용되는 경우</p>
</blockquote>
<p>우선 데코레이터로 사용할 <code>chaining</code>이라는 함수를 정의해줍니다.<br><figure class="highlight ts"><figcaption><span>decorator.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">chaining</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>): <span class="title">any</span> </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(target); <span class="comment">// &#123;bark: f, constructor: f&#125;</span></div><div class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// bark</span></div><div class="line">  <span class="built_in">console</span>.log(descriptor); <span class="comment">// &#123;value: f, writable: true, enumerable: true, configurable: true&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위 함수는 추후 메소드에 <code>@chaining</code> 형식으로 사용될 함수입니다. <code>@</code>과 함께 함수가 호출되는 경우 받게 되는 파라미터는 다음과 같습니다.</p>
<blockquote>
<ul>
<li>target : 속성을 정의하고자 하는 객체</li>
<li>name : 속성의 이름</li>
<li>descriptor : 새로 정의하고자 하는 속성에 대한 설명</li>
</ul>
</blockquote>
<p>이는 <code>Object.defineProperty()</code>를 통해 이를 정의하고 있기 때문입니다.</p>
<p><code>target</code>은 해당 메소드가 속해있는 클래스 프로토타입을 가리키게 되며 <code>Pet</code>의 프로토타입에는 <code>constructor</code>와 <code>bark</code>메소드가 있는 것을 확인할 수 있습니다. <code>name</code>은 데코레이터가 적용된 메소드의 이름이 됩니다. <code>descriptor</code>는 <code>defineProperty</code>에서 정의할 수 있는 각각의 속성값들이 됩니다.</p>
<p>Object의 <code>defineProperty</code>에 해당하는 보다 자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">여기</a>에서 살펴보실 수 있습니다. 그럼 각각을 활용해서 <code>chaining</code> 기능을 구현해보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Decorator to method</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">chaining</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>): <span class="title">any</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> fn: <span class="built_in">Function</span> = descriptor.value;</div><div class="line"></div><div class="line">  descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</div><div class="line">    fn.apply(target, args);</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>descriptor의 <code>value</code>가 데코레이터가 적용된 함수, 즉 실행 대상이라고 할 수 있습니다. <code>descriptor.value</code>를 재정의(override)하기 전에 <code>fn</code>이라는 변수로 caching해둔 다음, 호출한 후의 일을 정의하기 위해 위와 같이 재정의 해줍니다. 재정의 하기 전 caching 해둔 함수를 호출하기 위해서 <code>apply</code> 함수를 사용했습니다. 어떠한 변수가 얼만큼 전달될지 모르니 rest parameter를 통해 <code>fn</code>을 호출해주는 코드입니다.</p>
<p>위와 같이 <code>descriptor.value</code>가 재정의 되면 <code>chaining</code>이 적용된 메소드는 재정의된대로 호출되게 됩니다.</p>
<blockquote>
<p><code>apply</code> 함수에 대한 내용은 <a href="https://www.google.co.kr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwj9wKqt1cDYAhUBtpQKHQNvC34QFggmMAA&amp;url=https%3A%2F%2Fdeveloper.mozilla.org%2Fko%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fapply&amp;usg=AOvVaw2tqAzWzgnT49rXId1wsV11" target="_blank" rel="external">여기</a>를 참고해주세요.</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Pet &#123;</div><div class="line">  <span class="meta">@chaining</span></div><div class="line">  bark() &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위와 같이 적용해보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Pet();</div></pre></td></tr></table></figure></p>
<p><code>Pet</code>클래스에서 <code>bark</code>라는 메소드는 <code>Pet.prototype.bark</code>로 됩니다. class syntax 내부에서 위 코드에서는 <code>bark</code>라는 메소드가 <code>Pet</code>의 prototype의 프로퍼티로 추가되기 전에 <code>decorate</code> 함수가 실행되어 본래 <code>bark</code>라는 메소드에서 정의된 것에 추가적인 <strong>‘장식’</strong> 을 더해 prototype에 추가되도록 합니다.</p>
<blockquote>
<p>만약 compile target이 ES5보다 낮다면 <code>PropertyDescriptor</code> 값으로 <code>undefined</code>이 전달됩니다.</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pet.bark().bark();</div></pre></td></tr></table></figure>
<p>위 데코레이터의 효과로 <code>return this;</code>를 해주지 않아도 chaining 기능을 사용하여 메소드를 호출할 수 있습니다.</p>
<p><br></p>
<h2 id="Decorator-to-Class"><a href="#Decorator-to-Class" class="headerlink" title="Decorator to Class"></a>Decorator to Class</h2><p>하지만 데코레이터가 class에 적용되었을 때는 그 signature가 조금 달라집니다. 클래스 데코레이터는 클래스 선언 바로 전에 선언됩니다. 클래스 데코레이터는 클래스 생성자에 적용되며 클래스 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다.</p>
<p>클래스 데코레이터가 값을 반환하면 클래스 선언을 제공된 생성자 함수로 바꿉니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(target); <span class="comment">// ...</span></div><div class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></div><div class="line">  <span class="built_in">console</span>.log(descriptor); <span class="comment">//undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>메소드에 데코레이터를 적용하듯이 데코레이터 함수를 선언하면 올바른 선언을 할 수 없습니다. 클래스에 적용되는 데코레이터 함수에 전달되는 인자는 <code>constructor</code>하나입니다. 제대로 된 데코레이터 선언은 다음과 같습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;<span class="keyword">new</span>(...args:<span class="built_in">any</span>[]):&#123;&#125;&#125;&gt;(<span class="keyword">constructor</span>:T) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> <span class="keyword">constructor</span> &#123;</div><div class="line">    newProperty = <span class="string">"new property"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>클래스에 적용되는 데코레이터 함수 내에서 새로운 생성자 함수를 반환하면 원래 프로토타입을 유지해야 합니다. 런타임에 데코레이터를 적용하는 로직은 이를 수행하지 않기 때문입니다. 위 코드에서는 기존의 프로토타입을 유지하기 위해 적용되는 클래스의 <code>constructor</code>를 <code>extends</code> 합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@classDecorator</span></div><div class="line"><span class="keyword">class</span> Pet &#123;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Pet(<span class="string">"async"</span>);</div><div class="line"><span class="built_in">console</span>.log(pet.newProperty); <span class="comment">// new Property</span></div></pre></td></tr></table></figure>
<p><code>classDecorator</code> 데코레이터가 적용된 <code>Pet</code> 클래스의 인스턴스에는 <code>newProperty</code>가 존재하지 않지만 데코레이터 함수에서 해당 클래스의 constructor를 재정의했기 대문에 <code>newProperty</code>에 접근할 수 있습니다.</p>
<p><br></p>
<h2 id="Decorator-with-parameter"><a href="#Decorator-with-parameter" class="headerlink" title="Decorator with parameter"></a>Decorator with parameter</h2><blockquote>
<p>파라미터를 받는 데코레이터</p>
</blockquote>
<p>데코레이터 함수에 인자를 넘겨줄 수 있습니다. 이 인자는 무엇이든 될 수 있습니다. 예제 코드로 descriptor의 <code>enumerable</code> 속성을 변경하는 데코레이터를 만들어보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerableToFalse</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">  descriptor.enumerable = <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이렇게 정의하면 <code>enumerableToFalse</code>이 적용된 메소드의 enumerable 속성은 false가 됩니다. 위 <code>enumerableToFalse</code> 함수를 한 번 감싸서 반환하는 함수를 만들면 다음과 같습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">    descriptor.enumerable = value;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 이 함수를 데코레이터 함수로 사용할 수 있습니다. <code>value</code>에 해당하는 값으로 데코레이터를 적용하는 메소드의 <code>enumerable</code>속성을 제어할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Pet &#123;</div><div class="line">  <span class="meta">@enumerable</span>(<span class="literal">false</span>)</div><div class="line">  bark() &#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위와 같이 <code>false</code>라는 인자를 받는 데코레이터를 정의했습니다. 저 인자에는 함수도 들어갈 수 있으며 데코레이터도 들어갈 수 있습니다.</p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>target을 ES5로 지정해야 제대로 된 데코레이터를 사용할 수 있어서 아직 한계가 있는 Decorator지만 React에서는 HOC(High-Order-Component)에 많이 사용하고 있는 Decorator 였습니다!</p>
<p>감사합니다.</p>
<p><em>6. Decorator in TypeScript end</em></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="external">TypeScript Official Document - Generics</a></li>
<li><a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="external">https://github.com/wycats/javascript-decorators</a></li>
<li><a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841" target="_blank" rel="external">https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841</a></li>
<li><a href="https://www.sitepoint.com/javascript-decorators-what-they-are/" target="_blank" rel="external">https://www.sitepoint.com/javascript-decorators-what-they-are/</a></li>
<li><a href="https://cabbageapps.com/fell-love-js-decorators/" target="_blank" rel="external">https://cabbageapps.com/fell-love-js-decorators/</a></li>
<li><a href="https://javarouka.github.io/blog/2016/09/30/decorator-exploring/#class-il-gyeongu" target="_blank" rel="external">https://javarouka.github.io/blog/2016/09/30/decorator-exploring/#class-il-gyeongu</a></li>
<li><a href="https://github.com/jayphelps/core-decorators" target="_blank" rel="external">https://github.com/jayphelps/core-decorators</a></li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/01/09/TS-6-Decorator/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2018/01/09/TS-6-Decorator/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/12/30/TS-5-Generics-in-TypeScript/">
                            [TS] 5. Generics in TypeScript
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-12-30T16:11:41+09:00">
	
		    Dec 30, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-5-Generics-in-TypeScript"><a href="#TS-5-Generics-in-TypeScript" class="headerlink" title="[TS] 5. Generics in TypeScript"></a>[TS] 5. Generics in TypeScript</h1><p><code>Generics</code>는 자바스크립트 개발자에게 친숙하지 않은 용어일꺼라고 생각됩니다. 하지만 정적 타이핑에 있어서 큰 부분을 차지하고 있는 Generics syntax에 대해 알아봅니다.</p>
<h4 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h4><ul>
<li>Generics?</li>
<li>Generics to Class</li>
<li>Generics to Function</li>
</ul>
<p><br></p>
<h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics?"></a>Generics?</h2><p>이전에 다뤘던 인터페이스가 어떠한 ‘틀’을 지정하여 함수 또는 클래스를 정의했다면, 제네릭을 통하여 함수 또는 클래스에 ‘틀’을 ‘주입’하여 그 확장성을 보다 높일 수 있습니다. 즉, 제네릭의 목적은 재사용성(reusable)을 높이고 함수나 클래스의 확장성을 높여 중복된 코드를 방지하기 위함이라고 할 수 있습니다.</p>
<p><br></p>
<h2 id="Generics-to-Class"><a href="#Generics-to-Class" class="headerlink" title="Generics to Class"></a>Generics to Class</h2><p>어떠한 장바구니(Basket)에 물건(Item)을 넣어야 한다고 가정을 해봅시다. 이 때, 하나의 장바구니에는 모두 동일한 타입의 물건이 들어있어야 합니다. 이 경우 모든 경우의 수에 해당하는 장바구니를 각각의 클래스로 만들어줘야 하는 문제점이 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BookBasket &#123; ... &#125;</div><div class="line"><span class="keyword">class</span> CupBasket &#123; ... &#125;</div><div class="line"><span class="keyword">class</span> DollBasket &#123; ... &#125;</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure></p>
<p>이럴 경우, 제네릭을 사용하여 하나의 클래스에서 타입을 <strong>주입받아</strong> 모든 경우의 수에 해당하는 장바구니를 만들 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Basket&lt;T&gt; &#123;</div><div class="line">  <span class="keyword">private</span> item: T[];</div><div class="line"></div><div class="line">  getItem(index: <span class="built_in">number</span>): T &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.item[index];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>아주 간단한 <code>Basket</code>클래스를 만들어 보았습니다. 일반 클래스를 정의할 때와는 다르게 <code>&lt;T&gt;</code>라는 것이 클래스 이름 옆에 추가된 것을 확인하실 수 있는데요, 해당 클래스 내에서 사용할 타입을 <code>T</code>라는 값으로 받을 수 있게 되는 것입니다. 여기서 <code>T</code>는 별 뜻이 있는게 아니라 Type의 약자입니다. 이렇게 정의한 클래스를 이용하여 여러 경우에 해당하는 장바구니를 생성할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bookBasket = <span class="keyword">new</span> Basket&lt;Book&gt;();</div><div class="line"><span class="keyword">const</span> cupBasket = <span class="keyword">new</span> Basket&lt;Cup&gt;();</div><div class="line"><span class="keyword">const</span> dollBasket = <span class="keyword">new</span> Basket&lt;Doll&gt;();</div></pre></td></tr></table></figure></p>
<p><code>new</code> 키워드를 통해 인스턴스를 생성할 때 정의할 때와 마찬가지로 <code>&lt;&gt;</code>와 함께 타입을 지정하여 인스턴스를 생성해줍니다. (<code>Book</code>, <code>Cup</code>, <code>Doll</code>에 대한 인터페이스 정의는 생략합니다.)</p>
<p><br></p>
<h2 id="Generics-to-Function"><a href="#Generics-to-Function" class="headerlink" title="Generics to Function"></a>Generics to Function</h2><p>제네릭스는 클래스 뿐만 아니라 함수에도 적용될 수 있는데요, 이전에 살펴보았던 AjaxUtils를 예제로 제네릭에 대해 알아보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">param: fetchDataParam</span>): <span class="title">Promise</span>&lt;<span class="title">DataFormat</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위 함수는 <code>fetchDataParam</code>이라는 타입의 인자만 받을 수 있으며 <code>Promise&lt;DataFormat&gt;</code>이라는 타입의 반환만 할 수 있게 설계되어 있습니다. 그러나 함수의 body가 여러 곳에서 중복된다면 <code>fetchDataParam</code> 또는 <code>DataFormat</code>을 위 함수에 주입하여 여러 상황에 대응할 수 있는 함수로 변환시킬 수 있습니다. 이 때, 제네릭이 사용됩니다.</p>
<p>위 함수에 제네릭을 적용하여 함수의 재사용성을 높여보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchDataOf</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">param: T</span>): <span class="title">Promise</span>&lt;<span class="title">U</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`<span class="subst">$&#123;param&#125;</span>`</span>);</div><div class="line">    <span class="keyword">return</span> response.json();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>arrow function에도 마찬가지로 적용할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fetchDataOf = <span class="keyword">async</span> &lt;T, U&gt;(param: T): <span class="built_in">Promise</span>&lt;U&gt; =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`<span class="subst">$&#123;param&#125;</span>`</span>);</div><div class="line">    <span class="keyword">return</span> response.json();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>이렇게 정의를 하면 다음과 같이 호출할 수 있습니다. 여기서 T와 U는 그냥 type의 종류를 나타내는 character라고 생각하시면 됩니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> data: DataFormat = <span class="keyword">await</span> fetchDataOf&lt;<span class="built_in">string</span>, DataFormat&gt;(baseUrl);</div></pre></td></tr></table></figure>
<p><code>param</code>으로 넘겨주게 되는 인자의 타입이 다르거나, 반환하게 되는 값의 타입이 다를 경우에도 <code>&lt;&gt;</code>에 해당 타입을 지정하여 하나의 함수를 사용할 수 있게 됩니다.</p>
<p>물론 <any>의 형식으로도 사용할 수 있지만(이럴바에 차라리 자바스크립트를 사용하는 것이 생산성 측면에서 더 좋을 것 같습니다.) 특정 타입을 받아 해당 타입으로 반환한다는 측면에 있어서 안정성과 확장성 두 마리 토끼를 모두 잡을 수 있습니다.</any></p>
<p><br></p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>실제 개발해서보다는 라이브러리를 개발할 때 많이 사용할 수 있는 Generics에 대해 알아봤습니다. 해당 포스팅 외 다른 타입스크립트 포스팅은 <a href="https://github.com/JaeYeopHan/typescript_tutorial_docs" target="_blank" rel="external">여기</a>에서 보실 수 있으며 예제에 사용된 코드는 <a href="https://github.com/JaeYeopHan/typescript_playground" target="_blank" rel="external">여기</a>에서 확인하실 수 있습니다.<br>감사합니다.</p>
<p><em>5. Generic in TypeScript end</em></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="external">TypeScript Official Document - Generics</a></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/12/30/TS-5-Generics-in-TypeScript/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/12/30/TS-5-Generics-in-TypeScript/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/12/28/TS-4-Interface-in-TypeScript/">
                            [TS] 4. Interface in TypeScript
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-12-28T10:10:52+09:00">
	
		    Dec 28, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-4-Interface-in-TypeScript"><a href="#TS-4-Interface-in-TypeScript" class="headerlink" title="[TS] 4. Interface in TypeScript"></a>[TS] 4. Interface in TypeScript</h1><p><code>interface</code>는 자바스크립트 개발자에게 친숙하지 않은 용어일꺼라고 생각됩니다. 하지만 정적 타이핑에 있어서 큰 부분을 차지하고 있는 syntax에 대해 알아봅니다.</p>
<h4 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h4><ul>
<li>Interface?</li>
<li>Useful Interface</li>
<li>Available properties<ul>
<li>Optional</li>
<li>readonly</li>
</ul>
</li>
<li>Interface Type<ul>
<li>Function Type</li>
<li>Indexable Type</li>
</ul>
</li>
<li>Class interface</li>
</ul>
<p><br></p>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface?"></a>Interface?</h2><p><code>interface</code>란 <strong>객체의 껍데기 또는 설계도</strong> 라고 할 수 있을 것 같습니다. 자바스크립트에서는 클래스도 함수도 결국 모두 객체인데요, 클래스 또는 함수의 ‘틀’을 정의할 때 사용할 수 있는 것이 인터페이스 입니다.</p>
<p>여러 함수가 특정한 시그니처를 동일하게 가져야 할 경우 또는 여러 클래스가 동일한 명세를 정의해야하는 경우 인터페이스를 통해서 정의할 수 있습니다. 인터페이스는 특정 타입으로서 사용될 수 있으며, <code>implements</code>의 대상이 될 수 있습니다. 객체에 인터페이스를 적용하는 경우 또는 반환값 등을 설정할 때 타입으로 이용될 수 있습니다.</p>
<p><br></p>
<h2 id="Useful-Interface"><a href="#Useful-Interface" class="headerlink" title="Useful Interface"></a>Useful Interface</h2><p>함수에서 어떤 객체를 받아야 할 경우, 해당 type을 어떻게 정의할 수 있을까요?<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AjaxUtils.ts</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchBasic</span>(<span class="params">param: &#123;url: <span class="built_in">string</span>&#125;</span>): <span class="title">Promise</span>&lt;<span class="title">Response</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(param.url);</div><div class="line">  <span class="keyword">return</span> response.json();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위와 같이 <code>param</code>이라는 인자의 타입을 literal 형식으로 정의할 수 있습니다. 그런데 그 객체의 프로퍼티가 많아지는 경우에는 어떻게 정의할까요? (반환값 형식에 <code>Promise&lt;?&gt;</code>형식으로 지정을 해줬는데요, 이는 Generics 부분에서 다룰 예정입니다.)</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">param: &#123;baseUrl: <span class="built_in">string</span>, <span class="keyword">type</span>: <span class="built_in">string</span>, subject?: <span class="built_in">string</span>&#125;</span>): <span class="title">Promise</span>&lt;<span class="title">Response</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123;baseUrl, <span class="keyword">type</span>, subject&#125; = param;</div><div class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`<span class="subst">$&#123;baseUrl&#125;</span>/<span class="subst">$&#123;subject&#125;</span>`</span>);</div><div class="line">  <span class="keyword">const</span> contentType = response.headers.get(<span class="string">"content-type"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (response.ok &amp;&amp; contentType &amp;&amp; contentType.includes(<span class="keyword">type</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> response.json();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Invalid baseUrl or subject"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>literal로 인자의 타입을 정의하다보니 함수의 signature가 너무 길어졌습니다. 그런데 여기서 <code>Promise&lt;Response&gt;</code> 이 부분도 정의가 필요합니다. 따라서 다음과 같이 길어집니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">param: &#123;</span></span></div><div class="line">  baseUrl: <span class="built_in">string</span>,</div><div class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>,</div><div class="line">  subject?: <span class="built_in">string</span></div><div class="line">&#125;): <span class="title">Promise</span>&lt;&#123;</div><div class="line">  id: <span class="built_in">number</span>;</div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">  company: <span class="built_in">string</span>;</div><div class="line">&#125;[]&gt; &#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>뭔가 최대한 가독성을 좋게 하기 위해서 개행을 했지만 성공하진 못한 것 같습니다. 문제는 여기서 끝이 아닙니다. 이 함수를 호출하는 곳에서는 다음과 같은 일이 벌어집니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">async</span> ajax(): <span class="built_in">Promise</span>&lt;&#123;id: <span class="built_in">number</span>; name: <span class="built_in">string</span>; company: <span class="built_in">string</span>;&#125;[]&gt; &#123;</div><div class="line">  <span class="keyword">const</span> data: &#123;id: <span class="built_in">number</span>; name: <span class="built_in">string</span>; company: <span class="built_in">string</span>;&#125;[] = <span class="keyword">await</span> fetchData(&#123;</div><div class="line">    baseUrl: <span class="string">"http://localhost:3000"</span>,</div><div class="line">    subject: <span class="string">"users"</span>,</div><div class="line">    <span class="keyword">type</span>: <span class="string">"application/json"</span></div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// ...do something</span></div><div class="line">  <span class="keyword">return</span> data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 혼란의 상황을 interface를 통해 깔끔하게 정리할 수 있습니다. 인자와 반환값을 interface를 통해 정리해보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// interfaces.ts</span></div><div class="line"><span class="keyword">interface</span> Character &#123;</div><div class="line">  id: <span class="built_in">number</span>;</div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">  company: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">interface</span> dataFormat &#123;</div><div class="line">  charaters: Character[];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">interface</span> fetchDataParam &#123;</div><div class="line">  baseUrl: <span class="built_in">string</span>;</div><div class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</div><div class="line">  subject: <span class="built_in">string</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위와 같이 <code>interfaces.ts</code>라는 파일을 생성하여 인터페이스들을 정의할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AjaxUtils.ts</span></div><div class="line"><span class="keyword">import</span> &#123; fetchDataParam, dataFormat &#125; <span class="keyword">from</span> <span class="string">"./interfaces"</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">param: fetchDataParam</span>): <span class="title">Promise</span>&lt;<span class="title">dataFormat</span>&gt; </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AjaxUtils.ts</code>에서는 정의한 인터페이스를 import하여 인자와 반환값에 해당 인터페이스를 통해 타입을 정의할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Controller.ts</span></div><div class="line"><span class="keyword">import</span> &#123; fetchDataParam, dataFormat &#125; <span class="keyword">from</span> <span class="string">"./interfaces"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">async</span> ajaxCall(): <span class="built_in">Promise</span>&lt;dataFormat&gt; &#123;</div><div class="line">  <span class="keyword">const</span> param: fetchDataParam = &#123;</div><div class="line">    baseUrl: <span class="string">"http://localhost:3000"</span>,</div><div class="line">    subject: <span class="string">"users"</span>,</div><div class="line">    <span class="keyword">type</span>: <span class="string">"application/json"</span></div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">const</span> data: dataFormat = <span class="keyword">await</span> fetchData(param);</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">  <span class="keyword">return</span> data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>호출하는 부분에서도 마찬가지로 <code>interfaces.ts</code>파일에서 필요한 인터페이스를 import하여 타입을 지정해줍니다. 예시 코드에서 처럼 인터페이스를 정의하여 인자에 정의하던 타입들을 깔끔하게 정리할 수 있습니다. 또한 다른 파일에서 해당 함수를 정의하는 부분과 호출하는 부분이 다를 때, 하나의 인터페이스를 공유할 수 있습니다. 인터페이스를 통일시키는 것이 중요할 때 매우 유용하게 사용할 수 있습니다.</p>
<p><br></p>
<h2 id="Available-properties"><a href="#Available-properties" class="headerlink" title="Available properties"></a>Available properties</h2><p>인터페이스에도 클래스와 동일하게 optional하게 property를 지정할 수 있으며 readonly 타입으로 property를 지정할 수 있습니다.</p>
<h3 id="Optional-properties"><a href="#Optional-properties" class="headerlink" title="Optional properties"></a>Optional properties</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> WeatherSpec &#123;</div><div class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</div><div class="line">  amount?: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> rainfall: WeatherSpec = &#123;</div><div class="line">  <span class="keyword">type</span>: <span class="string">"rainfall"</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>optional property로 지정한 <code>amount</code>에 대해서는 구현하지 않아도 에러가 발생하지 않는 것을 확인할 수 있습니다.</p>
<p><br></p>
<h3 id="Readonly-properties"><a href="#Readonly-properties" class="headerlink" title="Readonly properties"></a>Readonly properties</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">interface</span> WeatherSpec &#123;</div><div class="line">  readonly <span class="keyword">type</span>: <span class="built_in">string</span>;</div><div class="line">  amount: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> rainfall: WeatherSpec = &#123;</div><div class="line">  <span class="keyword">type</span>: <span class="string">"rainfall"</span>,</div><div class="line">  amount: <span class="number">24</span>,</div><div class="line">&#125;</div><div class="line">rainfall.type = <span class="string">"snow"</span>; <span class="comment">// Error!</span></div><div class="line">rainfall.amout += <span class="number">3</span>; <span class="comment">// OK!</span></div></pre></td></tr></table></figure>
<p>에러 메시지는 다음과 같습니다. <code>[!] Error: Cannot assign to &#39;type&#39; because it is a constant or a read-only property.</code> 위와 같이 interface에서 readonly로 지정한 프로퍼티에 대해서는 그 값을 바꿀 수 없습니다. 이는 변수를 사용할 때 사용하는 <code>const</code>키워드와 동일한 역할을 수행한다고 이해할 수 있습니다.</p>
<p><br></p>
<h2 id="Interface-Types"><a href="#Interface-Types" class="headerlink" title="Interface Types"></a>Interface Types</h2><p>인터페이스에 프로퍼티를 정의할 때 여러 가지 형식으로 정의할 수 있습니다.</p>
<h3 id="Function-Type"><a href="#Function-Type" class="headerlink" title="Function Type"></a>Function Type</h3><p>인터페이스의 프로퍼티로 함수의 시그니처를 정의할 수 있습니다. 반환하는 형식 또는 그 값이 다르지만 시그니처를 통일시켜야 하는 경우가 존재할 수 있습니다. 그럴 경우 다음과 같이 interface를 설계하여 함수를 구현할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> TimeFunc &#123;</div><div class="line">  (hour: <span class="built_in">number</span>, minutes: <span class="built_in">number</span>): <span class="built_in">any</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> buildTimeStamp: TimeFunc = (hour, minutes): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (minutes &lt; <span class="number">10</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(<span class="string">`<span class="subst">$&#123;hour&#125;</span>0<span class="subst">$&#123;minutes&#125;</span>`</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span>  <span class="built_in">Number</span>(<span class="string">`<span class="subst">$&#123;hour&#125;</span><span class="subst">$&#123;minutes&#125;</span>`</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> buildTimeText: TimeFunc = (hour, minutes): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (minutes &lt; <span class="number">10</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;hour&#125;</span>시 0<span class="subst">$&#123;minutes&#125;</span>분`</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;hour&#125;</span>시 <span class="subst">$&#123;minutes&#125;</span>분`</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">buildTimeStamp(<span class="number">12</span>, <span class="number">33</span>); <span class="comment">//1233</span></div><div class="line">buildTimeText(<span class="number">12</span>, <span class="number">33</span>); <span class="comment">//12시 33분</span></div></pre></td></tr></table></figure></p>
<p>반환 타입을 제외하고 동일한 형식의 함수를 정의했습니다. 이것은 특정 콜백 함수를 받는 함수를 구현할 때 그 유용성이 더 빛을 발합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> buildTime = <span class="function">(<span class="params">timeText: <span class="built_in">string</span>, cb: TimeFunc</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> hour: <span class="built_in">number</span> = <span class="built_in">Number</span>(timeText.split(<span class="string">":"</span>)[<span class="number">0</span>]);</div><div class="line">  <span class="keyword">const</span> minutes: <span class="built_in">number</span> = <span class="built_in">Number</span>(timeText.split(<span class="string">":"</span>)[<span class="number">1</span>]);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> cb(hour, minutes);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(buildTime(<span class="string">"12:33"</span>, buildTimeStamp)); <span class="comment">//1233</span></div><div class="line"><span class="built_in">console</span>.log(buildTime(<span class="string">"12:33"</span>, buildTimeText)); <span class="comment">//12시 33분</span></div></pre></td></tr></table></figure>
<p>콜백 함수를 인자로 받을 때 해당하는 시그니처가 통일되어야 하는 부분을 인터페이스를 통해 해결할 수 있습니다.</p>
<p><br></p>
<h3 id="Indexable-Types"><a href="#Indexable-Types" class="headerlink" title="Indexable Types"></a>Indexable Types</h3><p>자바스크립트에서 다음과 같은 코드는 매우 자연스럽습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">first</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">second</span>: <span class="number">2</span>,</div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> <span class="built_in">console</span>.log(obj[key]));</div></pre></td></tr></table></figure></p>
<p>즉, 객체의 프로퍼티에 접근할 때, 동적으로 생성된 <code>key</code>를 통해 객체의 프로퍼티에 <code>[]</code> 표기법으로 접근하는 경우입니다. 하지만 이 코드는 타입스크립트에서 동작하지 않습니다.</p>
<p><code>[!] Element implicitly has an &#39;any&#39; type because type &#39;{ first: number; second: number; }&#39; has no index signature.</code>이란 에러를 발생시킵니다. 왜냐하면 정의한 <code>obj</code>라는 객체에 index signature가 없기 때문입니다. 따라서 이 에러는 다음과 같이 해결할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Indexable &#123;</div><div class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> obj: Indexable = &#123;</div><div class="line">  first: <span class="number">1</span>,</div><div class="line">  second: <span class="number">2</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key: <span class="built_in">string</span></span>) =&gt;</span> obj[key]);</div></pre></td></tr></table></figure></p>
<p><code>Indexable</code>이란 이름의 인터페이스를 정의해준 다음, <code>string</code> 타입의 key에 <code>any</code> 타입을 지정해줍니다. 이 인터페이스를 통해서 객체를 생성하면 <code>[]</code> 표기법을 통해 객체의 프로퍼티에 접근할 수 있습니다.</p>
<p><br></p>
<h2 id="Class-interface"><a href="#Class-interface" class="headerlink" title="Class interface"></a>Class interface</h2><p>인터페이스를 클래스에서도 사용할 수 있습니다. 상위 클래스를 <code>extends</code>라는 키워드로 상속하듯이 <code>implements</code>라는 키워드로 인터페이스를 구현할 수 있습니다. 클래스는 인터페이스를 <code>implements</code>하면서 인터페이스에 명세되어 있는 기능들을 구현해야 하는 의무를 갖게 됩니다.</p>
<p>인터페이스에서는 클래스의 프로퍼티(필드 멤버), 메소드 등을 정의할 수 있습니다. 또한 optional 한 명세 또한 정의할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Movable &#123;</div><div class="line">  velocity: <span class="built_in">number</span>;</div><div class="line">  move(time: <span class="built_in">number</span>): Position;</div><div class="line">  startPos?: Position;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> BMWCar <span class="keyword">implements</span> Movable &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>여기까지 입력했을 때 나타나는 에러 메세지는 다음과 같습니다. <code>[!] Class &#39;Car&#39; incorrectly implements interface &#39;Movable&#39;.</code>. 특정 인터페이스를 구현한 클래스는 인터페이스에 정의된 명세를 구현해야 합니다.</p>
<p>즉 여기서는 <code>velocity</code>라는 프로퍼티를 포함해야 하며, <code>move</code>라는 메소드를 구현해야만 합니다. 이 <code>BMWCar</code> 클래스는 생성할 때 다음과 같이 생성할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BMWCar <span class="keyword">implements</span> Movable &#123;</div><div class="line">  velocity: <span class="built_in">number</span>;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params">velocity</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.velocity = velocity;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  move(time: <span class="built_in">number</span>): Position &#123;</div><div class="line">    <span class="comment">//... do something</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> bmw: Movable = <span class="keyword">new</span> BMWCar();</div></pre></td></tr></table></figure></p>
<p><code>BMWCar</code>라는 타입 말고도 해당 클래스에서 구현한 인터페이스인 <code>Movable</code> 타입으로 지정할 수 있습니다.</p>
<h3 id="Public-Property"><a href="#Public-Property" class="headerlink" title="Public Property"></a>Public Property</h3><p>TypeScript Official Document에 <code>Interfaces describe the public side of the class, rather than both the public and private side.</code> 이런 말이 나옵니다. <code>인터페이스</code>를 통해 구현해야 함을 명시하는 메소드는 <code>private</code> 접근 제어자로 정의될 메소드가 아니라 <code>public</code> 접근 제어자로 정의될 메소드이어야 한다고 합니다.</p>
<p>즉, 인터페이스를 통해 명세를 정의할 때는 <code>private</code> 속성말고 <code>public</code> 속성에 대해 정의합니다.</p>
<p><br></p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>인터페이스를 통해 보다 세밀한 구조 설계와 추상화가 가능해졌습니다. 해당 포스팅 외 다른 타입스크립트 포스팅은 <a href="https://github.com/JaeYeopHan/typescript_tutorial_docs" target="_blank" rel="external">여기</a>에서 보실 수 있으며 예제에 사용된 코드는 <a href="https://github.com/JaeYeopHan/typescript_playground" target="_blank" rel="external">여기</a>에서 확인하실 수 있습니다.<br>감사합니다.</p>
<p><em>3. Interface in TypeScript end</em></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="external">TypeScript Official Document - Interface</a></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/12/28/TS-4-Interface-in-TypeScript/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/12/28/TS-4-Interface-in-TypeScript/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/12/18/TS-3-Function-in-TypeScript/">
                            [TS] 3. Function in TypeScript
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-12-18T12:15:32+09:00">
	
		    Dec 18, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TypeScript/">TypeScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/images/typescript.png" alt=""></p>
<h1 id="TS-3-Function-in-TypeScript"><a href="#TS-3-Function-in-TypeScript" class="headerlink" title="[TS] 3. Function in TypeScript"></a>[TS] 3. Function in TypeScript</h1><p><a href="https://jaeyeophan.github.io/2017/12/13/TS-2-Class/">&lt; 이전: Class in TypeScript &lt;</a></p>
<p>TypeScript에서 함수를 정의하는데 있어서 몇 가지 추가된 기능에 대해 살펴봅니다.</p>
<h4 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h4><ul>
<li>Return type, Parameter type</li>
<li>Default Parameter / Rest Parameter</li>
<li>Optional Parameter</li>
<li>Union Type</li>
<li>Overloading</li>
</ul>
<h2 id="인자와-반환값의-타입을-설정한다"><a href="#인자와-반환값의-타입을-설정한다" class="headerlink" title="인자와 반환값의 타입을 설정한다."></a>인자와 반환값의 타입을 설정한다.</h2><p>함수 또는 메소드를 정의할 때, 타입을 정의해줍니다.<br><em>ES6 code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthFromString</span>(<span class="params">dateOfStringFormat</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> monthOfNumberFormat = <span class="built_in">parseInt</span>(dateOfStringFormat.substring(<span class="number">4</span>, <span class="number">6</span>), <span class="number">10</span>);</div><div class="line">  <span class="keyword">return</span> monthOfNumberFormat;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위 함수는 ‘201712’이라는 문자열을 받아서 해당하는 월을 반환하는 함수입니다. (반환값의 형식을 명시하기 위해 바로 return하지 않고 변수에 임시로 받아준 뒤 반환합니다.) 위와 같이 String 타입의 인자를 받아야 한다는 것을 명시해줘야 하기 때문에 변수명부터 굉장히 이상해집니다. 자바스크립트에는 타입이라는 것이 없기 때문에 메소드명 또는 변수명에 타입을 명시할 수 밖에 없습니다.</p>
<p>만약 Number 타입의 201712를 인자로 넘겨준다면 Number에는 substring이라는 함수가 없기 때문에 에러가 발생합니다. 위 함수를 보다 안정적으로 작성하기 위해서는 다음과 같은 if 문이 필요하게 됩니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthFromString</span>(<span class="params">dateOfStringFormat</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> dateOfStringFormat !== <span class="string">"string"</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Invalid format of parameter"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> monthOfNumberFormat = <span class="built_in">parseInt</span>(dateOfStringFormat.substring(<span class="number">4</span>, <span class="number">6</span>), <span class="number">10</span>);</div><div class="line">  <span class="keyword">return</span> monthOfNumberFormat;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>기본적으로 함수가 수행해야하는 비즈니스 로직 외 불필요한 방어코드가 코드를 더럽히고 있습니다. 위 함수를 TypeScript 함수로 변경해보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> getMonth = (date: <span class="built_in">string</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(date.substring(<span class="number">4</span>, <span class="number">6</span>), <span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>인자와 반환값에 타입을 설정하여 메소드 이름과 변수명이 훨씬 짧아졌습니다. 그럼에도 불구하고 해당 함수가 하는 역할을 ES6로 작성했을 때보다 명확해졌으며, 불필요한 방어코드 마저 사라졌습니다.<br><a href="https://github.com/denysdovhan/wtfjs" target="_blank" rel="external">wtfjs</a>에서 확인하실 수 있지만 자바스크립트에서는 타입이 멋대로(사실은 매우 다양한 규칙을 기반으로) 캐스팅되는 경우가 많은데요, 이를 방지하기 위해 우리는 불필요한 방어코드를 작성해왔습니다. 타입을 지정함으로써 이러한 작업을 최소화 할 수 있습니다.</p>
<p><br></p>
<h2 id="Default-Parameter-Rest-Parameter"><a href="#Default-Parameter-Rest-Parameter" class="headerlink" title="Default Parameter, Rest Parameter"></a>Default Parameter, Rest Parameter</h2><p>해당 스펙은 ES6 표준 스펙에서도 지원하고 있는 스펙이므로 구체적은 설명은 넘어가겠습니다. 자세한 내용은 첨부하는 포스팅을 확인해주세요.</p>
<ul>
<li><a href="https://jaeyeophan.github.io/2017/04/18/ES6-4-Spread-Rest-parameter/">ES6. Rest Parameter</a></li>
<li><a href="https://jaeyeophan.github.io/2017/04/18/ES6-5-Destructuring-and-Default-Parameter/">ES6. Default Parameter</a></li>
</ul>
<p>TypeScript에서도 해당 스펙을 지원합니다.<br><em>Default parameter TypeScript code</em><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> getRandomNumber = (min: <span class="built_in">number</span> = <span class="number">0</span>, max: <span class="built_in">number</span> = <span class="number">10</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min)) + min;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getRandomNumber(<span class="number">1</span>)); <span class="comment">// OK!</span></div></pre></td></tr></table></figure></p>
<p>위 코드에서는 인자가 넘겨지지 않았을 경우(<code>undefined</code>), 지정해준 값으로 인자를 설정합니다. 명시적으로 <code>null</code>을 인자로 넘겨주면 default로 설정된 parameter를 무시하고 <code>null</code>을 인자로 넘깁니다. 지정한 인자를 모두 넘기지 않으면 에러를 뱉던 TypeScript도 default parameter가 지정되어 있으면 에러를 발생시키지 않습니다.</p>
<p><em>Rest parameter TypeScript code</em><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> setSkills = (...skills: <span class="built_in">string</span>[]): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>rest parameter</code>의 타입은 배열(array)이므로 인자에 해당하는 타입을 설정해줍니다.</p>
<p><br></p>
<h2 id="Optional-Parameter"><a href="#Optional-Parameter" class="headerlink" title="Optional Parameter"></a>Optional Parameter</h2><p>TypeScript에서는 default parameter 없을 경우, signature에서 정의한대로 인자를 넘겨주지 않으면 에러가 발생합니다. 하지만 파라미터를 넘겨주지 않아도 되도록 설정할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> setSpec = (major: <span class="built_in">string</span>, option?: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(major);</div><div class="line">  <span class="built_in">console</span>.log(option);</div><div class="line">&#125;</div><div class="line">setSpec(<span class="string">"Computer Science"</span>);</div><div class="line"><span class="comment">// console&gt; Computer Science</span></div><div class="line"><span class="comment">// console&gt; undefined</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>?</code>를 통해서 함수에 optional한 parameter를 지정할 수 있습니다.</p>
</blockquote>
<p><br></p>
<h2 id="Union-Type"><a href="#Union-Type" class="headerlink" title="Union Type"></a>Union Type</h2><p>파라미터에 타입을 지정할 때, 두 가지 이상의 타입이 지정할 필요가 있을 수 있는데요, 그럴 때 Union type을 통해서 파라미터의 타입을 지정해줄 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sayName(position: <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> position === <span class="string">"string"</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`string type position`</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> position === <span class="string">"boolean"</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`boolean type position`</span>)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`else`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위 코드에서는 <code>position</code>이라는 파라미터가 <code>string</code>, <code>boolean</code>, <code>number</code> 세 가지의 타입일 수 있다고 signature를 지정했습니다. (예제가 송구스럽네요)</p>
<p><br></p>
<h2 id="Overloading"><a href="#Overloading" class="headerlink" title="Overloading"></a>Overloading</h2><p>바로 이전 <a href="https://jaeyeophan.github.io/2017/12/13/TS-2-Class/">Class 포스팅</a>에서 자바와 같은 오버로딩을 지원하지 않는다고 했는데요, <code>optional parameter</code>와 <code>union type</code> 그리고 <code>any</code>라는 타입을 사용하면 자바에서 구현하는 것과는 조금 다르지만 오버로딩을 구현할 수 있습니다.</p>
<figure class="highlight ts"><figcaption><span>Person.ts</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">  <span class="comment">//..</span></div><div class="line">  sayName(position: <span class="built_in">string</span>, option?: <span class="built_in">string</span>): <span class="built_in">void</span>;</div><div class="line">  sayName(position: <span class="built_in">boolean</span>, option: <span class="built_in">string</span>): <span class="built_in">void</span>;</div><div class="line">  sayName(position: <span class="built_in">string</span> | <span class="built_in">boolean</span>, option: <span class="built_in">any</span>): <span class="built_in">any</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> position === <span class="string">"string"</span>) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`string type position`</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> position === <span class="string">"boolean"</span>) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`boolean type position`</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`else`</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//..</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위와 같이 동일한 메소드 명에 대해 여러 Signature를 정의할 수 있습니다. 위 코드에서는 <code>sayName</code>이라는 메소드의 Signature가 세 개이며 마지막 메소드에서만 이를 구현하고 있습니다. 그리고 메소드 body에서는 parameter의 타입으로 분기를 하여 로직을 수행하고 있습니다.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const person: Person = new Person();</div><div class="line"></div><div class="line">person.sayName("FrontEnd");</div><div class="line">person.sayName("FrontEnd", "optional);</div><div class="line">person.sayName(false, "option required");</div><div class="line">// person.sayName(true); Error! (1)</div><div class="line">// person.sayName(1); Error! (2)</div></pre></td></tr></table></figure></p>
<p><code>sayName</code>을 호출하게 되면, 메소드를 <strong>호출하는 시점에서</strong> 각 상황에 맞는 signature가 적용됩니다. <code>Error (1)</code>을 보면 <code>boolean</code> 타입이 인자로 넘어갔을 경우의 signature에 따라 <code>option</code>이 <code>required</code> 인자이므로 에러가 발생합니다. <code>Error (2)</code>는 어느 signature와도 일치하지 않으니 에러가 발생합니다. 이렇게 TypeScript에서는 여러 signature를 정의한 뒤 메소드 내에서 이를 분기하여 오버로딩을 구현할 수 있습니다.</p>
<p><br></p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>TypeScript 좀 더 안정성 있는, 간결한, 가독성이 좋은 함수를 작성할 수 있게 되었습니다. 어떻게 보면 타이핑이 길어지는 결과처럼 보일 수 있겠지만 타입의 명시가 필요한 부분에 있어서는 오히려 코드가 더 짧아지게 되었습니다.</p>
<p>해당 포스팅 외 다른 타입스크립트 포스팅은 <a href="https://github.com/JaeYeopHan/typescript_tutorial_docs" target="_blank" rel="external">여기</a>에서 보실 수 있으며 예제에 사용된 코드는 <a href="https://github.com/JaeYeopHan/typescript_playground" target="_blank" rel="external">여기</a>에서 확인하실 수 있습니다.<br>감사합니다.</p>
<p><em>3. Function in TypeScript end</em></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.typescriptlang.org/docs/handbook/functions.html" target="_blank" rel="external">TypeScript Official Document - Function</a></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/12/18/TS-3-Function-in-TypeScript/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2017/12/18/TS-3-Function-in-TypeScript/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/tags/ts/page/2/">
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 1 of 2</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Jbee. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Jbee</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
